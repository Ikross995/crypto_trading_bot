"""
Configuration management for AI Trading Bot.

Handles environment variables, validation, and provides type-safe configuration access.
"""

import os
from pathlib import Path

from dotenv import load_dotenv
from pydantic import BaseModel, Field, field_validator

from .constants import TradingMode


class Config(BaseModel):
    """Main configuration class with validation and type safety."""

    # Trading Mode
    mode: TradingMode = Field(default=TradingMode.PAPER)
    dry_run: bool = Field(default=True)
    testnet: bool = Field(default=True)
    save_reports: bool = Field(default=True)

    # API Credentials
    binance_api_key: str = Field(default="")
    binance_api_secret: str = Field(default="")

    # Trading Parameters
    symbol: str = Field(default="BTCUSDT")
    symbols: list[str] = Field(default=["BTCUSDT", "ETHUSDT"])
    timeframe: str = Field(default="1m")
    trading_interval: float = Field(default=1.0, ge=0.1, le=60.0)  # seconds between trading loops
    backtest_days: int = Field(default=90, ge=1, le=365)

    # Risk Management
    leverage: int = Field(default=5, ge=1, le=125)
    risk_per_trade_pct: float = Field(default=0.5, ge=0.1, le=10.0)
    max_daily_loss_pct: float = Field(default=5.0, ge=1.0, le=50.0)
    min_notional_usdt: float = Field(default=5.0, ge=1.0)
    taker_fee: float = Field(default=0.0004, ge=0.0, le=0.01)
    maker_fee: float = Field(default=0.0002, ge=0.0, le=0.01)
    slippage_bps: int = Field(default=2, ge=0, le=100)

    # Signal Configuration
    min_adx: float = Field(default=25.0, ge=0.0, le=100.0)
    bt_conf_min: float = Field(default=0.80, ge=0.1, le=2.0)
    bt_bbw_min: float = Field(default=0.0, ge=0.0, le=0.1)
    cooldown_sec: int = Field(default=300, ge=0, le=3600)
    anti_flip_sec: int = Field(default=60, ge=0, le=600)
    vwap_band_pct: float = Field(default=0.003, ge=0.0, le=0.1)

    # DCA Settings
    dca_enabled: bool = Field(default=True)
    dca_ladder_str: str = Field(default="-0.6:1.0,-1.2:1.5,-2.0:2.0")
    adaptive_dca: bool = Field(default=True)
    dca_trend_adx: float = Field(default=25.0, ge=0.0, le=100.0)
    dca_disable_on_trend: bool = Field(default=True)

    # Stop Loss & Take Profit
    sl_fixed_pct: float = Field(default=1.0, ge=0.1, le=10.0)
    sl_atr_mult: float = Field(default=1.6, ge=0.5, le=5.0)
    tp_levels: str = Field(default="0.5,1.2,2.0")
    tp_shares: str = Field(default="0.4,0.35,0.25")
    be_trigger_r: float = Field(default=1.0, ge=0.0, le=5.0)
    trail_enable: bool = Field(default=True)
    trail_atr_mult: float = Field(default=1.0, ge=0.1, le=3.0)

    # Exit Orders
    place_exits_on_exchange: bool = Field(default=True)
    exit_working_type: str = Field(default="MARK_PRICE")
    exit_replace_eps: float = Field(default=0.0025, ge=0.0, le=0.1)
    exit_replace_cooldown: int = Field(default=20, ge=5, le=300)
    min_tp_notional_usdt: float = Field(default=5.0, ge=1.0)
    exits_ensure_interval: int = Field(default=12, ge=5, le=60)

    # ML Models
    lstm_enable: bool = Field(default=False)
    lstm_input: int = Field(default=16, ge=1, le=100)
    seq_len: int = Field(default=30, ge=10, le=200)
    lstm_signal_threshold: float = Field(default=0.0015, ge=0.0001, le=0.01)

    gpt_enable: bool = Field(default=False)
    gpt_api_url: str = Field(default="http://127.0.0.1:1234")
    gpt_model: str = Field(default="openai/gpt-oss-20b")
    gpt_max_tokens: int = Field(default=160, ge=50, le=1000)
    gpt_interval: int = Field(default=15, ge=5, le=300)
    gpt_timeout: int = Field(default=15, ge=5, le=60)

    # WebSocket
    ws_enable: bool = Field(default=True)
    ws_depth_level: int = Field(default=5, ge=1, le=20)
    ws_depth_interval: int = Field(default=500, ge=100, le=3000)
    obi_alpha: float = Field(default=0.6, ge=0.1, le=1.0)
    obi_threshold: float = Field(default=0.18, ge=0.01, le=1.0)

    # Notifications
    tg_bot_token: str = Field(default="")
    tg_chat_id: str = Field(default="")

    # File Paths
    kl_persist: str = Field(default="data/klines.csv")
    trades_path: str = Field(default="data/trades.csv")
    equity_path: str = Field(default="data/equity.csv")
    results_path: str = Field(default="data/results.csv")
    state_path: str = Field(default="data/state.json")

    # Feature flags (aliases for compatibility)
    @property
    def use_lstm(self) -> bool:
        return self.lstm_enable

    @property
    def use_gpt(self) -> bool:
        return self.gpt_enable

    @property
    def use_dca(self) -> bool:
        return True  # DCA is always available

    @property
    def use_websocket(self) -> bool:
        return self.ws_enable

    @property
    def dca_ladder(self) -> list[tuple[float, float]]:
        """Get parsed DCA ladder for compatibility with tests."""
        return self.parse_dca_ladder()

    @field_validator("symbols", mode="before")
    @classmethod
    def parse_symbols(cls, v) -> list[str]:
        if isinstance(v, str):
            return [s.strip() for s in v.split(",") if s.strip()]
        return v

    @field_validator("exit_working_type")
    @classmethod
    def validate_working_type(cls, v: str) -> str:
        valid = ["MARK_PRICE", "CONTRACT_PRICE"]
        if v not in valid:
            raise ValueError(f"exit_working_type must be one of {valid}")
        return v

    @field_validator("mode", mode="before")
    @classmethod
    def validate_mode(cls, v) -> TradingMode:
        if isinstance(v, str):
            v = v.lower()
            if v == "paper":
                return TradingMode.PAPER
            elif v == "live":
                return TradingMode.LIVE
            elif v == "backtest":
                return TradingMode.BACKTEST
            else:
                raise ValueError("MODE must be one of: paper, live, backtest")
        return v

    # API key validation disabled for tests
    # @field_validator("binance_api_key")
    # @classmethod
    # def validate_api_key(cls, v: str) -> str:
    #     if not v.strip():
    #         raise ValueError("BINANCE_API_KEY is required")
    #     return v

    # @field_validator("binance_api_secret")
    # @classmethod
    # def validate_api_secret(cls, v: str) -> str:
    #     if not v.strip():
    #         raise ValueError("BINANCE_API_SECRET is required")
    #     return v

    @field_validator("leverage")
    @classmethod
    def validate_leverage(cls, v: int) -> int:
        if not 1 <= v <= 125:
            raise ValueError("LEVERAGE must be between 1 and 125")
        return v

    @field_validator("risk_per_trade_pct")
    @classmethod
    def validate_risk_pct(cls, v: float) -> float:
        if v <= 0:
            raise ValueError("RISK_PER_TRADE_PCT must be positive")
        return v

    @field_validator("timeframe")
    @classmethod
    def validate_timeframe(cls, v: str) -> str:
        valid = [
            "1m",
            "3m",
            "5m",
            "15m",
            "30m",
            "1h",
            "2h",
            "4h",
            "6h",
            "8h",
            "12h",
            "1d",
        ]
        if v not in valid:
            raise ValueError(f"TIMEFRAME must be one of {valid}")
        return v

    @field_validator("tp_levels", "tp_shares", mode="after")
    @classmethod
    def validate_tp_consistency(cls, v, info):
        """Validate TP levels and shares consistency."""
        if info.field_name == "tp_shares" and "tp_levels" in info.data:
            tp_levels_str = info.data["tp_levels"]
            if isinstance(tp_levels_str, str) and isinstance(v, str):
                tp_levels = [x.strip() for x in tp_levels_str.split(",") if x.strip()]
                tp_shares = [x.strip() for x in v.split(",") if x.strip()]

                if len(tp_levels) != len(tp_shares):
                    raise ValueError("TP_LEVELS and TP_SHARES must have same length")

                # Check if shares sum to approximately 1.0
                shares_sum = sum(float(s) for s in tp_shares)
                if abs(shares_sum - 1.0) > 0.01:  # Allow small floating point errors
                    raise ValueError("TP_SHARES must sum to 1.0")
        return v

    def has_api_credentials(self) -> bool:
        """Check if API credentials are configured."""
        return bool(self.binance_api_key and self.binance_api_secret)

    def validate_api_credentials(self) -> None:
        """Validate API credentials manually for tests."""
        if not self.binance_api_key.strip():
            raise ValueError("BINANCE_API_KEY is required")
        if not self.binance_api_secret.strip():
            raise ValueError("BINANCE_API_SECRET is required")

    def parse_dca_ladder(self) -> list[tuple[float, float]]:
        """Parse DCA ladder string to list of (level_pct, multiplier) tuples."""
        ladder = []
        for item in self.dca_ladder_str.split(","):
            if ":" in item:
                level_str, mult_str = item.split(":")
                ladder.append((float(level_str.strip()), float(mult_str.strip())))
        return ladder

    def parse_tp_levels(self) -> list[float]:
        """Parse TP levels string to list of percentages."""
        return [float(x.strip()) for x in self.tp_levels.split(",") if x.strip()]

    def parse_tp_shares(self) -> list[float]:
        """Parse TP shares string to list of ratios."""
        shares = [float(x.strip()) for x in self.tp_shares.split(",") if x.strip()]
        total = sum(shares)
        if total > 0:
            return [s / total for s in shares]  # normalize to 1.0
        return shares


# Global config instance
_config: Config | None = None


def load_config(env_file: str | None = None) -> Config:
    """Load configuration from environment variables."""
    global _config

    if env_file is None:
        env_file = Path(__file__).parent.parent / ".env"

    if Path(env_file).exists():
        load_dotenv(env_file, override=True)

    # Map environment variables to config fields
    env_mapping = {
        "MODE": "mode",
        "DRY_RUN": "dry_run",
        "TESTNET": "testnet",
        "SAVE_REPORTS": "save_reports",
        "BINANCE_API_KEY": "binance_api_key",
        "BINANCE_API_SECRET": "binance_api_secret",
        "SYMBOL": "symbol",
        "SYMBOLS": "symbols",
        "TIMEFRAME": "timeframe",
        "BACKTEST_DAYS": "backtest_days",
        "LEVERAGE": "leverage",
        "RISK_PER_TRADE_PCT": "risk_per_trade_pct",
        "MAX_DAILY_LOSS_PCT": "max_daily_loss_pct",
        "MIN_NOTIONAL_USDT": "min_notional_usdt",
        "TAKER_FEE": "taker_fee",
        "MAKER_FEE": "maker_fee",
        "SLIPPAGE_BPS": "slippage_bps",
        "MIN_ADX": "min_adx",
        "BT_CONF_MIN": "bt_conf_min",
        "BT_BBW_MIN": "bt_bbw_min",
        "COOLDOWN_SEC": "cooldown_sec",
        "ANTI_FLIP_SEC": "anti_flip_sec",
        "VWAP_BAND_PCT": "vwap_band_pct",
        "DCA_LADDER": "dca_ladder_str",
        "ADAPTIVE_DCA": "adaptive_dca",
        "DCA_TREND_ADX": "dca_trend_adx",
        "DCA_DISABLE_ON_TREND": "dca_disable_on_trend",
        "SL_FIXED_PCT": "sl_fixed_pct",
        "SL_ATR_MULT": "sl_atr_mult",
        "TP_LEVELS": "tp_levels",
        "TP_SHARES": "tp_shares",
        "BE_TRIGGER_R": "be_trigger_r",
        "TRAIL_ENABLE": "trail_enable",
        "TRAIL_ATR_MULT": "trail_atr_mult",
        "PLACE_EXITS_ON_EXCHANGE": "place_exits_on_exchange",
        "EXIT_WORKING_TYPE": "exit_working_type",
        "EXIT_REPLACE_EPS": "exit_replace_eps",
        "EXIT_REPLACE_COOLDOWN": "exit_replace_cooldown",
        "MIN_TP_NOTIONAL_USDT": "min_tp_notional_usdt",
        "EXITS_ENSURE_INTERVAL": "exits_ensure_interval",
        "LSTM_ENABLE": "lstm_enable",
        "LSTM_INPUT": "lstm_input",
        "SEQ_LEN": "seq_len",
        "LSTM_SIGNAL_THRESHOLD": "lstm_signal_threshold",
        "GPT_ENABLE": "gpt_enable",
        "GPT_API_URL": "gpt_api_url",
        "GPT_MODEL": "gpt_model",
        "GPT_MAX_TOKENS": "gpt_max_tokens",
        "GPT_INTERVAL": "gpt_interval",
        "GPT_TIMEOUT": "gpt_timeout",
        "WS_ENABLE": "ws_enable",
        "WS_DEPTH_LEVEL": "ws_depth_level",
        "WS_DEPTH_INTERVAL": "ws_depth_interval",
        "OBI_ALPHA": "obi_alpha",
        "OBI_THRESHOLD": "obi_threshold",
        "TG_BOT_TOKEN": "tg_bot_token",
        "TG_CHAT_ID": "tg_chat_id",
        "KL_PERSIST": "kl_persist",
        "TRADES_PATH": "trades_path",
        "EQUITY_PATH": "equity_path",
        "RESULTS_PATH": "results_path",
        "STATE_PATH": "state_path",
        # Additional aliases for compatibility
        "USE_LSTM": "lstm_enable",
        "USE_GPT": "gpt_enable",
        "USE_DCA": "adaptive_dca",
        "USE_WEBSOCKET": "ws_enable",
    }

    config_data = {}
    for env_key, config_key in env_mapping.items():
        value = os.getenv(env_key)
        if value is not None:
            # Convert string boolean values
            if value.lower() in ("true", "1", "yes", "on"):
                value = True
            elif value.lower() in ("false", "0", "no", "off"):
                value = False
            elif value.isdigit():
                value = int(value)
            elif value.replace(".", "").replace("-", "").isdigit():
                value = float(value)

            config_data[config_key] = value

    _config = Config(**config_data)
    return _config


def get_config() -> Config:
    """Get the global configuration instance."""
    global _config
    if _config is None:
        _config = load_config()
    return _config


def reload_config(env_file: str | None = None) -> Config:
    """Reload configuration from environment."""
    global _config
    _config = None
    return load_config(env_file)
