"""
Trading signal generation optimized for MAXIMUM demo trading activity.

This version is specifically designed to generate frequent, realistic trading signals
for demonstration purposes with very low thresholds.
"""

import logging
from typing import Optional, List
from decimal import Decimal
from datetime import datetime, timezone

import numpy as np
import pandas as pd

from core.config import Config
from core.types import MarketData, TradingSignal
from core.constants import SignalType


class SignalGenerator:
    """Generates trading signals with ultra-low thresholds for demo trading."""
    
    def __init__(self, config: Config):
        """Initialize signal generator with AGGRESSIVE configuration."""
        self.config = config
        self.logger = logging.getLogger(__name__)
        
        # ULTRA AGGRESSIVE Signal parameters - GUARANTEED to generate signals
        self.fast_ma_period = 5      # Very fast MA
        self.slow_ma_period = 10     # Very slow MA  
        self.min_signal_strength = 0.01  # Only 1% strength needed!
        
        # State tracking
        self.last_signal: Optional[TradingSignal] = None
        self.last_signal_time: Optional[datetime] = None
        self.signal_count = 0
        
        self.logger.info("üöÄ ULTRA AGGRESSIVE SignalGenerator initialized")
        self.logger.info(f"Min signal strength: {self.min_signal_strength}")
        self.logger.info(f"MA periods: {self.fast_ma_period}/{self.slow_ma_period}")
    
    def initialize(self) -> None:
        """Initialize the signal generator."""
        self.logger.info("Signal generator initialized for MAXIMUM TRADING ACTIVITY")
    
    def generate_signal(self, market_data: MarketData) -> Optional[TradingSignal]:
        """
        Generate trading signals with MAXIMUM sensitivity for demo trading.
        
        This version WILL generate signals frequently for demonstration.
        """
        self.signal_count += 1
        self.logger.debug(f"üîç Signal attempt #{self.signal_count} for {market_data.symbol if market_data else 'None'}")
        
        if not market_data or len(market_data.close) < max(self.slow_ma_period, 10):
            self.logger.debug(f"‚ùå Insufficient data: need {max(self.slow_ma_period, 10)}, got {len(market_data.close) if market_data else 0}")
            return None
            
        try:
            # Create simple price data
            prices = market_data.close[-20:]  # Use last 20 prices
            timestamps = market_data.timestamp[-20:]
            volumes = market_data.volume[-20:]
            
            # Calculate simple moving averages
            fast_ma = np.mean(prices[-self.fast_ma_period:])
            slow_ma = np.mean(prices[-self.slow_ma_period:])
            
            current_price = prices[-1]
            current_timestamp = timestamps[-1]
            
            self.logger.debug(f"üìä MA values: fast={fast_ma:.2f}, slow={slow_ma:.2f}, price={current_price:.2f}")
            
            # Check cooldown period
            if self._is_in_cooldown(current_timestamp):
                self.logger.debug("‚è∞ Still in cooldown period")
                return None
            
            # ULTRA SENSITIVE signal detection - ALMOST ALWAYS GENERATES SIGNAL
            signal_type = None
            strength = 0.0
            
            # Calculate the difference percentage
            ma_diff_pct = abs(fast_ma - slow_ma) / slow_ma
            
            # ANY difference > 0.001% triggers a signal (extremely sensitive)
            if fast_ma > slow_ma:
                signal_type = SignalType.BUY
                strength = min(0.9, 0.5 + ma_diff_pct * 100)  # At least 50% strength
                
            elif fast_ma < slow_ma:
                signal_type = SignalType.SELL  
                strength = min(0.9, 0.5 + ma_diff_pct * 100)  # At least 50% strength
            
            # Even if no MA difference, generate random signals for demo
            elif self.signal_count % 10 == 0:  # Every 10th attempt
                signal_type = SignalType.BUY if (self.signal_count % 20) < 10 else SignalType.SELL
                strength = 0.6  # Decent strength for demo
                self.logger.debug("üé≤ Generated demo signal (no MA signal)")
            
            # Check minimum strength (very low threshold)
            if not signal_type or strength < self.min_signal_strength:
                self.logger.debug(f"‚ùå Signal rejected: type={signal_type}, strength={strength:.3f}, min_req={self.min_signal_strength}")
                return None
                
            # Create trading signal
            signal = TradingSignal(
                symbol=market_data.symbol,
                signal_type=signal_type,
                strength=strength,
                timestamp=current_timestamp,
                metadata={
                    'fast_ma': float(fast_ma),
                    'slow_ma': float(slow_ma),
                    'current_price': float(current_price),
                    'volume': float(volumes[-1]) if volumes else 0.0,
                    'strategy': 'ULTRA_DEMO_TRADING',
                    'signal_attempt': self.signal_count
                }
            )
            
            self.last_signal = signal
            self.last_signal_time = current_timestamp
            
            self.logger.info(f"üöÄ GENERATED {signal_type.value} signal for {market_data.symbol} "
                           f"(strength: {strength:.2f}, price: {current_price:.4f}, attempt: #{self.signal_count})")
            
            return signal
            
        except Exception as e:
            self.logger.error(f"‚ùå Error generating signal: {e}")
            import traceback
            self.logger.error(traceback.format_exc())
            return None
    
    def _is_in_cooldown(self, current_time: datetime) -> bool:
        """Check if we're still in cooldown period from last signal."""
        if not self.last_signal_time:
            return False
            
        cooldown_seconds = self.config.cooldown_sec
        
        # Handle timezone-aware and naive datetimes
        if current_time.tzinfo is None and self.last_signal_time.tzinfo is not None:
            current_time = current_time.replace(tzinfo=timezone.utc)
        elif current_time.tzinfo is not None and self.last_signal_time.tzinfo is None:
            self.last_signal_time = self.last_signal_time.replace(tzinfo=timezone.utc)
        
        time_since_last = (current_time - self.last_signal_time).total_seconds()
        
        is_cooling = time_since_last < cooldown_seconds
        if is_cooling:
            self.logger.debug(f"‚è∞ Cooldown: {time_since_last:.1f}s < {cooldown_seconds}s")
        
        return is_cooling
    
    def get_signal_summary(self) -> dict:
        """Get summary of signal generator state."""
        return {
            'fast_ma_period': self.fast_ma_period,
            'slow_ma_period': self.slow_ma_period,
            'min_signal_strength': self.min_signal_strength,
            'signal_count': self.signal_count,
            'last_signal': {
                'type': self.last_signal.signal_type.value if self.last_signal else None,
                'strength': self.last_signal.strength if self.last_signal else None,
                'timestamp': self.last_signal.timestamp.isoformat() if self.last_signal else None
            } if self.last_signal else None
        }


class SimpleScalper:
    """Ultra aggressive scalping strategy - ALWAYS generates signals."""
    
    def __init__(self, config: Config):
        """Initialize scalper with ULTRA aggressive configuration."""
        self.config = config
        self.logger = logging.getLogger(__name__)
        
        # ULTRA AGGRESSIVE Scalping parameters
        self.momentum_period = 3  # Very short period
        self.momentum_threshold = 0.0001  # 0.01% threshold
        
        self.signal_count = 0
        
    def generate_signal(self, market_data: MarketData) -> Optional[TradingSignal]:
        """Generate ULTRA aggressive scalping signals - ALWAYS produces signals."""
        self.signal_count += 1
        
        if not market_data or len(market_data.close) < 5:
            return None
            
        try:
            current_price = market_data.close[-1]
            prev_price = market_data.close[-2]
            
            # Simple momentum: ANY movement triggers signal
            price_change = (current_price - prev_price) / prev_price
            
            if price_change > 0:
                signal_type = SignalType.BUY
                strength = min(0.95, 0.7 + abs(price_change) * 1000)
            else:
                signal_type = SignalType.SELL  
                strength = min(0.95, 0.7 + abs(price_change) * 1000)
                
            signal = TradingSignal(
                symbol=market_data.symbol,
                signal_type=signal_type,
                strength=strength,
                timestamp=market_data.timestamp[-1],
                metadata={
                    'current_price': current_price,
                    'prev_price': prev_price,
                    'price_change_pct': price_change * 100,
                    'strategy': 'ULTRA_SCALPING'
                }
            )
            
            self.logger.info(f"üéØ SCALPING {signal_type.value} signal for {market_data.symbol} "
                           f"(strength: {strength:.2f}, change: {price_change*100:.3f}%)")
            
            return signal
            
        except Exception as e:
            self.logger.error(f"Error in scalping signal: {e}")
            return None
