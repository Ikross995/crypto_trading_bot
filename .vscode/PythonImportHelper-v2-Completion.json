[
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "annotations",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "ClassVar",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Sequence",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Protocol",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Mapping",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "field_validator",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "model_validator",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "BaseModel",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Field",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "field_validator",
        "importPath": "pydantic",
        "description": "pydantic",
        "isExtraImport": true,
        "detail": "pydantic",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "Enum",
        "importPath": "enum",
        "description": "enum",
        "isExtraImport": true,
        "detail": "enum",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "asdict",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "field",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timedelta",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "timezone",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "datetime",
        "importPath": "datetime",
        "description": "datetime",
        "isExtraImport": true,
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "ROUND_FLOOR",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "getcontext",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "ROUND_DOWN",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "ROUND_DOWN",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "Decimal",
        "importPath": "decimal",
        "description": "decimal",
        "isExtraImport": true,
        "detail": "decimal",
        "documentation": {}
    },
    {
        "label": "hashlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hashlib",
        "description": "hashlib",
        "detail": "hashlib",
        "documentation": {}
    },
    {
        "label": "math",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "math",
        "description": "math",
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "gzip",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gzip",
        "description": "gzip",
        "detail": "gzip",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "gc",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "gc",
        "description": "gc",
        "detail": "gc",
        "documentation": {}
    },
    {
        "label": "psutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "psutil",
        "description": "psutil",
        "detail": "psutil",
        "documentation": {}
    },
    {
        "label": "joblib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "joblib",
        "description": "joblib",
        "detail": "joblib",
        "documentation": {}
    },
    {
        "label": "MarketData",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "MarketData",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Position",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Order",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Position",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Order",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Position",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "MarketData",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "OrderUpdate",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "MarketData",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "TradingSignal",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Order",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Order",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Position",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Signal",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Trade",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "BacktestResult",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Order",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Position",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Signal",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Trade",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Order",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Position",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Signal",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Order",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Position",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Signal",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Order",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Position",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Signal",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Order",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Position",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Signal",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "OrderSide",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Order",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Position",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Position",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Signal",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "MarketData",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "TradingSignal",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "MarketData",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "MarketData",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Order",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Position",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Signal",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Order",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Position",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Signal",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "BacktestResult",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "MarketData",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "TradingSignal",
        "importPath": "core.types",
        "description": "core.types",
        "isExtraImport": true,
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "TIMEFRAME_TO_MINUTES",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "TradingMode",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "OrderSide",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "OrderSide",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "OrderType",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "OrderStatus",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "TimeInForce",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "WorkingType",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "OrderSide",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "OrderType",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "OrderStatus",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "TimeInForce",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "WorkingType",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "PositionSide",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "SignalType",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "OrderSide",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "OrderType",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "Timeframe",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "OrderType",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "OrderType",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "OrderType",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "OrderType",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "SignalType",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "PositionSide",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "OrderSide",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "OrderType",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "WorkingType",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "SignalType",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "PositionSide",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "SignalType",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "TradingMode",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "OrderType",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "OrderType",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "TradingMode",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "TradingMode",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "SignalType",
        "importPath": "core.constants",
        "description": "core.constants",
        "isExtraImport": true,
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "BinanceClient",
        "importPath": "exchange.client",
        "description": "exchange.client",
        "isExtraImport": true,
        "detail": "exchange.client",
        "documentation": {}
    },
    {
        "label": "BinanceClient",
        "importPath": "exchange.client",
        "description": "exchange.client",
        "isExtraImport": true,
        "detail": "exchange.client",
        "documentation": {}
    },
    {
        "label": "BinanceClient",
        "importPath": "exchange.client",
        "description": "exchange.client",
        "isExtraImport": true,
        "detail": "exchange.client",
        "documentation": {}
    },
    {
        "label": "BinanceClient",
        "importPath": "exchange.client",
        "description": "exchange.client",
        "isExtraImport": true,
        "detail": "exchange.client",
        "documentation": {}
    },
    {
        "label": "BinanceClient",
        "importPath": "exchange.client",
        "description": "exchange.client",
        "isExtraImport": true,
        "detail": "exchange.client",
        "documentation": {}
    },
    {
        "label": "BinanceClient",
        "importPath": "exchange.client",
        "description": "exchange.client",
        "isExtraImport": true,
        "detail": "exchange.client",
        "documentation": {}
    },
    {
        "label": "MockBinanceClient",
        "importPath": "exchange.client",
        "description": "exchange.client",
        "isExtraImport": true,
        "detail": "exchange.client",
        "documentation": {}
    },
    {
        "label": "BinanceMarketDataClient",
        "importPath": "exchange.client",
        "description": "exchange.client",
        "isExtraImport": true,
        "detail": "exchange.client",
        "documentation": {}
    },
    {
        "label": "BinanceClient",
        "importPath": "exchange.client",
        "description": "exchange.client",
        "isExtraImport": true,
        "detail": "exchange.client",
        "documentation": {}
    },
    {
        "label": "BinanceClient",
        "importPath": "exchange.client",
        "description": "exchange.client",
        "isExtraImport": true,
        "detail": "exchange.client",
        "documentation": {}
    },
    {
        "label": "BinanceMarketDataClient",
        "importPath": "exchange.client",
        "description": "exchange.client",
        "isExtraImport": true,
        "detail": "exchange.client",
        "documentation": {}
    },
    {
        "label": "MockBinanceClient",
        "importPath": "exchange.client",
        "description": "exchange.client",
        "isExtraImport": true,
        "detail": "exchange.client",
        "documentation": {}
    },
    {
        "label": "BinanceClient",
        "importPath": "exchange.client",
        "description": "exchange.client",
        "isExtraImport": true,
        "detail": "exchange.client",
        "documentation": {}
    },
    {
        "label": "BinanceClient",
        "importPath": "exchange.client",
        "description": "exchange.client",
        "isExtraImport": true,
        "detail": "exchange.client",
        "documentation": {}
    },
    {
        "label": "BinanceClient",
        "importPath": "exchange.client",
        "description": "exchange.client",
        "isExtraImport": true,
        "detail": "exchange.client",
        "documentation": {}
    },
    {
        "label": "BinanceClient",
        "importPath": "exchange.client",
        "description": "exchange.client",
        "isExtraImport": true,
        "detail": "exchange.client",
        "documentation": {}
    },
    {
        "label": "BinanceClient",
        "importPath": "exchange.client",
        "description": "exchange.client",
        "isExtraImport": true,
        "detail": "exchange.client",
        "documentation": {}
    },
    {
        "label": "jit",
        "importPath": "core.utils",
        "description": "core.utils",
        "isExtraImport": true,
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "HAS_NUMBA",
        "importPath": "core.utils",
        "description": "core.utils",
        "isExtraImport": true,
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "sklearn_components",
        "importPath": "core.utils",
        "description": "core.utils",
        "isExtraImport": true,
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "round_price",
        "importPath": "core.utils",
        "description": "core.utils",
        "isExtraImport": true,
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "round_qty",
        "importPath": "core.utils",
        "description": "core.utils",
        "isExtraImport": true,
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "update_symbol_filters",
        "importPath": "core.utils",
        "description": "core.utils",
        "isExtraImport": true,
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "round_price",
        "importPath": "core.utils",
        "description": "core.utils",
        "isExtraImport": true,
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "round_qty",
        "importPath": "core.utils",
        "description": "core.utils",
        "isExtraImport": true,
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "update_symbol_filters",
        "importPath": "core.utils",
        "description": "core.utils",
        "isExtraImport": true,
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "format_currency",
        "importPath": "core.utils",
        "description": "core.utils",
        "isExtraImport": true,
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "calculate_pnl",
        "importPath": "core.utils",
        "description": "core.utils",
        "isExtraImport": true,
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "format_currency",
        "importPath": "core.utils",
        "description": "core.utils",
        "isExtraImport": true,
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "calculate_pnl",
        "importPath": "core.utils",
        "description": "core.utils",
        "isExtraImport": true,
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "format_currency",
        "importPath": "core.utils",
        "description": "core.utils",
        "isExtraImport": true,
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "calculate_pnl",
        "importPath": "core.utils",
        "description": "core.utils",
        "isExtraImport": true,
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "format_currency",
        "importPath": "core.utils",
        "description": "core.utils",
        "isExtraImport": true,
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "calculate_pnl",
        "importPath": "core.utils",
        "description": "core.utils",
        "isExtraImport": true,
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "format_currency",
        "importPath": "core.utils",
        "description": "core.utils",
        "isExtraImport": true,
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "format_price",
        "importPath": "core.utils",
        "description": "core.utils",
        "isExtraImport": true,
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "round_price",
        "importPath": "core.utils",
        "description": "core.utils",
        "isExtraImport": true,
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "calculate_pnl",
        "importPath": "core.utils",
        "description": "core.utils",
        "isExtraImport": true,
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "format_currency",
        "importPath": "core.utils",
        "description": "core.utils",
        "isExtraImport": true,
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "calculate_pnl",
        "importPath": "core.utils",
        "description": "core.utils",
        "isExtraImport": true,
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "format_currency",
        "importPath": "core.utils",
        "description": "core.utils",
        "isExtraImport": true,
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "load_config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "reload_config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "load_config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "load_config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "load_config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "load_config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "Config",
        "importPath": "core.config",
        "description": "core.config",
        "isExtraImport": true,
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "create_processor",
        "importPath": "data.large_datasets.klines_processor",
        "description": "data.large_datasets.klines_processor",
        "isExtraImport": true,
        "detail": "data.large_datasets.klines_processor",
        "documentation": {}
    },
    {
        "label": "TrainingConfig",
        "importPath": "data.large_datasets.ml_data_manager",
        "description": "data.large_datasets.ml_data_manager",
        "isExtraImport": true,
        "detail": "data.large_datasets.ml_data_manager",
        "documentation": {}
    },
    {
        "label": "create_ml_manager",
        "importPath": "data.large_datasets.ml_data_manager",
        "description": "data.large_datasets.ml_data_manager",
        "isExtraImport": true,
        "detail": "data.large_datasets.ml_data_manager",
        "documentation": {}
    },
    {
        "label": "hmac,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hmac.",
        "description": "hmac.",
        "detail": "hmac.",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "hmac",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hmac",
        "description": "hmac",
        "detail": "hmac",
        "documentation": {}
    },
    {
        "label": "MarketSimulator",
        "importPath": "data.simulator",
        "description": "data.simulator",
        "isExtraImport": true,
        "detail": "data.simulator",
        "documentation": {}
    },
    {
        "label": "SimulatedMarketData",
        "importPath": "data.simulator",
        "description": "data.simulator",
        "isExtraImport": true,
        "detail": "data.simulator",
        "documentation": {}
    },
    {
        "label": "MarketSimulator",
        "importPath": "data.simulator",
        "description": "data.simulator",
        "isExtraImport": true,
        "detail": "data.simulator",
        "documentation": {}
    },
    {
        "label": "urlopen",
        "importPath": "urllib.request",
        "description": "urllib.request",
        "isExtraImport": true,
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "Request",
        "importPath": "urllib.request",
        "description": "urllib.request",
        "isExtraImport": true,
        "detail": "urllib.request",
        "documentation": {}
    },
    {
        "label": "urlencode",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "time,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time.",
        "description": "time.",
        "detail": "time.",
        "documentation": {}
    },
    {
        "label": "Client",
        "importPath": "binance.client",
        "description": "binance.client",
        "isExtraImport": true,
        "detail": "binance.client",
        "documentation": {}
    },
    {
        "label": "Client",
        "importPath": "binance.client",
        "description": "binance.client",
        "isExtraImport": true,
        "detail": "binance.client",
        "documentation": {}
    },
    {
        "label": "BinanceAPIException",
        "importPath": "binance.exceptions",
        "description": "binance.exceptions",
        "isExtraImport": true,
        "detail": "binance.exceptions",
        "documentation": {}
    },
    {
        "label": "BinanceAPIException",
        "importPath": "binance.exceptions",
        "description": "binance.exceptions",
        "isExtraImport": true,
        "detail": "binance.exceptions",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Callable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "loguru",
        "description": "loguru",
        "isExtraImport": true,
        "detail": "loguru",
        "documentation": {}
    },
    {
        "label": "statistics",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "statistics",
        "description": "statistics",
        "detail": "statistics",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "deque",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "sqlite3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sqlite3",
        "description": "sqlite3",
        "detail": "sqlite3",
        "documentation": {}
    },
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "FeatureEngineer",
        "importPath": "data.preprocessing",
        "description": "data.preprocessing",
        "isExtraImport": true,
        "detail": "data.preprocessing",
        "documentation": {}
    },
    {
        "label": "FeatureEngineer",
        "importPath": "data.preprocessing",
        "description": "data.preprocessing",
        "isExtraImport": true,
        "detail": "data.preprocessing",
        "documentation": {}
    },
    {
        "label": "ExitManager",
        "importPath": "strategy.exits",
        "description": "strategy.exits",
        "isExtraImport": true,
        "detail": "strategy.exits",
        "documentation": {}
    },
    {
        "label": "ExitManager",
        "importPath": "strategy.exits",
        "description": "strategy.exits",
        "isExtraImport": true,
        "detail": "strategy.exits",
        "documentation": {}
    },
    {
        "label": "ExitManager",
        "importPath": "strategy.exits",
        "description": "strategy.exits",
        "isExtraImport": true,
        "detail": "strategy.exits",
        "documentation": {}
    },
    {
        "label": "ExitManager",
        "importPath": "strategy.exits",
        "description": "strategy.exits",
        "isExtraImport": true,
        "detail": "strategy.exits",
        "documentation": {}
    },
    {
        "label": "ExitManager",
        "importPath": "strategy.exits",
        "description": "strategy.exits",
        "isExtraImport": true,
        "detail": "strategy.exits",
        "documentation": {}
    },
    {
        "label": "ExitManager",
        "importPath": "strategy.exits",
        "description": "strategy.exits",
        "isExtraImport": true,
        "detail": "strategy.exits",
        "documentation": {}
    },
    {
        "label": "ExitManager",
        "importPath": "strategy.exits",
        "description": "strategy.exits",
        "isExtraImport": true,
        "detail": "strategy.exits",
        "documentation": {}
    },
    {
        "label": "HistoricalDataFetcher",
        "importPath": "data.fetchers",
        "description": "data.fetchers",
        "isExtraImport": true,
        "detail": "data.fetchers",
        "documentation": {}
    },
    {
        "label": "TechnicalIndicators",
        "importPath": "data.indicators",
        "description": "data.indicators",
        "isExtraImport": true,
        "detail": "data.indicators",
        "documentation": {}
    },
    {
        "label": "setup_structured_logging",
        "importPath": "infra.logging",
        "description": "infra.logging",
        "isExtraImport": true,
        "detail": "infra.logging",
        "documentation": {}
    },
    {
        "label": "setup_structured_logging",
        "importPath": "infra.logging",
        "description": "infra.logging",
        "isExtraImport": true,
        "detail": "infra.logging",
        "documentation": {}
    },
    {
        "label": "setup_structured_logging",
        "importPath": "infra.logging",
        "description": "infra.logging",
        "isExtraImport": true,
        "detail": "infra.logging",
        "documentation": {}
    },
    {
        "label": "setup_structured_logging",
        "importPath": "infra.logging",
        "description": "infra.logging",
        "isExtraImport": true,
        "detail": "infra.logging",
        "documentation": {}
    },
    {
        "label": "setup_structured_logging",
        "importPath": "infra.logging",
        "description": "infra.logging",
        "isExtraImport": true,
        "detail": "infra.logging",
        "documentation": {}
    },
    {
        "label": "setup_structured_logging",
        "importPath": "infra.logging",
        "description": "infra.logging",
        "isExtraImport": true,
        "detail": "infra.logging",
        "documentation": {}
    },
    {
        "label": "setup_structured_logging",
        "importPath": "infra.logging",
        "description": "infra.logging",
        "isExtraImport": true,
        "detail": "infra.logging",
        "documentation": {}
    },
    {
        "label": "DCAManager",
        "importPath": "strategy.dca",
        "description": "strategy.dca",
        "isExtraImport": true,
        "detail": "strategy.dca",
        "documentation": {}
    },
    {
        "label": "DCAManager",
        "importPath": "strategy.dca",
        "description": "strategy.dca",
        "isExtraImport": true,
        "detail": "strategy.dca",
        "documentation": {}
    },
    {
        "label": "DCAManager",
        "importPath": "strategy.dca",
        "description": "strategy.dca",
        "isExtraImport": true,
        "detail": "strategy.dca",
        "documentation": {}
    },
    {
        "label": "DCAManager",
        "importPath": "strategy.dca",
        "description": "strategy.dca",
        "isExtraImport": true,
        "detail": "strategy.dca",
        "documentation": {}
    },
    {
        "label": "DCAManager",
        "importPath": "strategy.dca",
        "description": "strategy.dca",
        "isExtraImport": true,
        "detail": "strategy.dca",
        "documentation": {}
    },
    {
        "label": "DCAManager",
        "importPath": "strategy.dca",
        "description": "strategy.dca",
        "isExtraImport": true,
        "detail": "strategy.dca",
        "documentation": {}
    },
    {
        "label": "DCAManager",
        "importPath": "strategy.dca",
        "description": "strategy.dca",
        "isExtraImport": true,
        "detail": "strategy.dca",
        "documentation": {}
    },
    {
        "label": "RiskManager",
        "importPath": "strategy.risk",
        "description": "strategy.risk",
        "isExtraImport": true,
        "detail": "strategy.risk",
        "documentation": {}
    },
    {
        "label": "RiskManager",
        "importPath": "strategy.risk",
        "description": "strategy.risk",
        "isExtraImport": true,
        "detail": "strategy.risk",
        "documentation": {}
    },
    {
        "label": "RiskManager",
        "importPath": "strategy.risk",
        "description": "strategy.risk",
        "isExtraImport": true,
        "detail": "strategy.risk",
        "documentation": {}
    },
    {
        "label": "RiskManager",
        "importPath": "strategy.risk",
        "description": "strategy.risk",
        "isExtraImport": true,
        "detail": "strategy.risk",
        "documentation": {}
    },
    {
        "label": "RiskManager",
        "importPath": "strategy.risk",
        "description": "strategy.risk",
        "isExtraImport": true,
        "detail": "strategy.risk",
        "documentation": {}
    },
    {
        "label": "RiskManager",
        "importPath": "strategy.risk",
        "description": "strategy.risk",
        "isExtraImport": true,
        "detail": "strategy.risk",
        "documentation": {}
    },
    {
        "label": "RiskManager",
        "importPath": "strategy.risk",
        "description": "strategy.risk",
        "isExtraImport": true,
        "detail": "strategy.risk",
        "documentation": {}
    },
    {
        "label": "SignalGenerator",
        "importPath": "strategy.signals",
        "description": "strategy.signals",
        "isExtraImport": true,
        "detail": "strategy.signals",
        "documentation": {}
    },
    {
        "label": "SignalGenerator",
        "importPath": "strategy.signals",
        "description": "strategy.signals",
        "isExtraImport": true,
        "detail": "strategy.signals",
        "documentation": {}
    },
    {
        "label": "SignalGenerator",
        "importPath": "strategy.signals",
        "description": "strategy.signals",
        "isExtraImport": true,
        "detail": "strategy.signals",
        "documentation": {}
    },
    {
        "label": "SignalGenerator",
        "importPath": "strategy.signals",
        "description": "strategy.signals",
        "isExtraImport": true,
        "detail": "strategy.signals",
        "documentation": {}
    },
    {
        "label": "SignalGenerator",
        "importPath": "strategy.signals",
        "description": "strategy.signals",
        "isExtraImport": true,
        "detail": "strategy.signals",
        "documentation": {}
    },
    {
        "label": "SignalGenerator",
        "importPath": "strategy.signals",
        "description": "strategy.signals",
        "isExtraImport": true,
        "detail": "strategy.signals",
        "documentation": {}
    },
    {
        "label": "SignalGenerator",
        "importPath": "strategy.signals",
        "description": "strategy.signals",
        "isExtraImport": true,
        "detail": "strategy.signals",
        "documentation": {}
    },
    {
        "label": "SignalGenerator",
        "importPath": "strategy.signals",
        "description": "strategy.signals",
        "isExtraImport": true,
        "detail": "strategy.signals",
        "documentation": {}
    },
    {
        "label": "SignalGenerator",
        "importPath": "strategy.signals",
        "description": "strategy.signals",
        "isExtraImport": true,
        "detail": "strategy.signals",
        "documentation": {}
    },
    {
        "label": "logging,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging.",
        "description": "logging.",
        "detail": "logging.",
        "documentation": {}
    },
    {
        "label": "ensure_exits_on_exchange",
        "importPath": "exchange.exits_addon",
        "description": "exchange.exits_addon",
        "isExtraImport": true,
        "detail": "exchange.exits_addon",
        "documentation": {}
    },
    {
        "label": "ensure_exits_on_exchange",
        "importPath": "exchange.exits_addon",
        "description": "exchange.exits_addon",
        "isExtraImport": true,
        "detail": "exchange.exits_addon",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "asynccontextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "asynccontextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "asynccontextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "asynccontextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "asynccontextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "asynccontextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "RuntimeOverridesWatcher",
        "importPath": "infra.settings",
        "description": "infra.settings",
        "isExtraImport": true,
        "detail": "infra.settings",
        "documentation": {}
    },
    {
        "label": "apply_settings_to_config",
        "importPath": "infra.settings",
        "description": "infra.settings",
        "isExtraImport": true,
        "detail": "infra.settings",
        "documentation": {}
    },
    {
        "label": "RuntimeOverridesWatcher",
        "importPath": "infra.settings",
        "description": "infra.settings",
        "isExtraImport": true,
        "detail": "infra.settings",
        "documentation": {}
    },
    {
        "label": "apply_settings_to_config",
        "importPath": "infra.settings",
        "description": "infra.settings",
        "isExtraImport": true,
        "detail": "infra.settings",
        "documentation": {}
    },
    {
        "label": "load_profile",
        "importPath": "infra.settings",
        "description": "infra.settings",
        "isExtraImport": true,
        "detail": "infra.settings",
        "documentation": {}
    },
    {
        "label": "load_overrides",
        "importPath": "infra.settings",
        "description": "infra.settings",
        "isExtraImport": true,
        "detail": "infra.settings",
        "documentation": {}
    },
    {
        "label": "apply_settings_to_config",
        "importPath": "infra.settings",
        "description": "infra.settings",
        "isExtraImport": true,
        "detail": "infra.settings",
        "documentation": {}
    },
    {
        "label": "MetricsCollector",
        "importPath": "infra.metrics",
        "description": "infra.metrics",
        "isExtraImport": true,
        "detail": "infra.metrics",
        "documentation": {}
    },
    {
        "label": "MetricsCollector",
        "importPath": "infra.metrics",
        "description": "infra.metrics",
        "isExtraImport": true,
        "detail": "infra.metrics",
        "documentation": {}
    },
    {
        "label": "MetricsCollector",
        "importPath": "infra.metrics",
        "description": "infra.metrics",
        "isExtraImport": true,
        "detail": "infra.metrics",
        "documentation": {}
    },
    {
        "label": "MetricsCollector",
        "importPath": "infra.metrics",
        "description": "infra.metrics",
        "isExtraImport": true,
        "detail": "infra.metrics",
        "documentation": {}
    },
    {
        "label": "MetricsCollector",
        "importPath": "infra.metrics",
        "description": "infra.metrics",
        "isExtraImport": true,
        "detail": "infra.metrics",
        "documentation": {}
    },
    {
        "label": "MetricsCollector",
        "importPath": "infra.metrics",
        "description": "infra.metrics",
        "isExtraImport": true,
        "detail": "infra.metrics",
        "documentation": {}
    },
    {
        "label": "StateManager",
        "importPath": "infra.persistence",
        "description": "infra.persistence",
        "isExtraImport": true,
        "detail": "infra.persistence",
        "documentation": {}
    },
    {
        "label": "StateManager",
        "importPath": "infra.persistence",
        "description": "infra.persistence",
        "isExtraImport": true,
        "detail": "infra.persistence",
        "documentation": {}
    },
    {
        "label": "StateManager",
        "importPath": "infra.persistence",
        "description": "infra.persistence",
        "isExtraImport": true,
        "detail": "infra.persistence",
        "documentation": {}
    },
    {
        "label": "StateManager",
        "importPath": "infra.persistence",
        "description": "infra.persistence",
        "isExtraImport": true,
        "detail": "infra.persistence",
        "documentation": {}
    },
    {
        "label": "StateManager",
        "importPath": "infra.persistence",
        "description": "infra.persistence",
        "isExtraImport": true,
        "detail": "infra.persistence",
        "documentation": {}
    },
    {
        "label": "StateManager",
        "importPath": "infra.persistence",
        "description": "infra.persistence",
        "isExtraImport": true,
        "detail": "infra.persistence",
        "documentation": {}
    },
    {
        "label": "OrderManager",
        "importPath": "exchange.orders",
        "description": "exchange.orders",
        "isExtraImport": true,
        "detail": "exchange.orders",
        "documentation": {}
    },
    {
        "label": "OrderManager",
        "importPath": "exchange.orders",
        "description": "exchange.orders",
        "isExtraImport": true,
        "detail": "exchange.orders",
        "documentation": {}
    },
    {
        "label": "OrderManager",
        "importPath": "exchange.orders",
        "description": "exchange.orders",
        "isExtraImport": true,
        "detail": "exchange.orders",
        "documentation": {}
    },
    {
        "label": "OrderManager",
        "importPath": "exchange.orders",
        "description": "exchange.orders",
        "isExtraImport": true,
        "detail": "exchange.orders",
        "documentation": {}
    },
    {
        "label": "OrderManager",
        "importPath": "exchange.orders",
        "description": "exchange.orders",
        "isExtraImport": true,
        "detail": "exchange.orders",
        "documentation": {}
    },
    {
        "label": "OrderManager",
        "importPath": "exchange.orders",
        "description": "exchange.orders",
        "isExtraImport": true,
        "detail": "exchange.orders",
        "documentation": {}
    },
    {
        "label": "PositionManager",
        "importPath": "exchange.positions",
        "description": "exchange.positions",
        "isExtraImport": true,
        "detail": "exchange.positions",
        "documentation": {}
    },
    {
        "label": "PositionManager",
        "importPath": "exchange.positions",
        "description": "exchange.positions",
        "isExtraImport": true,
        "detail": "exchange.positions",
        "documentation": {}
    },
    {
        "label": "PositionManager",
        "importPath": "exchange.positions",
        "description": "exchange.positions",
        "isExtraImport": true,
        "detail": "exchange.positions",
        "documentation": {}
    },
    {
        "label": "PositionManager",
        "importPath": "exchange.positions",
        "description": "exchange.positions",
        "isExtraImport": true,
        "detail": "exchange.positions",
        "documentation": {}
    },
    {
        "label": "PositionManager",
        "importPath": "exchange.positions",
        "description": "exchange.positions",
        "isExtraImport": true,
        "detail": "exchange.positions",
        "documentation": {}
    },
    {
        "label": "PositionManager",
        "importPath": "exchange.positions",
        "description": "exchange.positions",
        "isExtraImport": true,
        "detail": "exchange.positions",
        "documentation": {}
    },
    {
        "label": "PositionManager",
        "importPath": "exchange.positions",
        "description": "exchange.positions",
        "isExtraImport": true,
        "detail": "exchange.positions",
        "documentation": {}
    },
    {
        "label": "PositionManager",
        "importPath": "exchange.positions",
        "description": "exchange.positions",
        "isExtraImport": true,
        "detail": "exchange.positions",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "TradeExecutor",
        "importPath": "runner.execution",
        "description": "runner.execution",
        "isExtraImport": true,
        "detail": "runner.execution",
        "documentation": {}
    },
    {
        "label": "patch",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "MagicMock",
        "importPath": "unittest.mock",
        "description": "unittest.mock",
        "isExtraImport": true,
        "detail": "unittest.mock",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "load_sample_data",
        "importPath": "data.samples",
        "description": "data.samples",
        "isExtraImport": true,
        "detail": "data.samples",
        "documentation": {}
    },
    {
        "label": "get_latest_price",
        "importPath": "data.samples",
        "description": "data.samples",
        "isExtraImport": true,
        "detail": "data.samples",
        "documentation": {}
    },
    {
        "label": "get_sample_market_data",
        "importPath": "data.samples",
        "description": "data.samples",
        "isExtraImport": true,
        "detail": "data.samples",
        "documentation": {}
    },
    {
        "label": "get_available_symbols",
        "importPath": "data.samples",
        "description": "data.samples",
        "isExtraImport": true,
        "detail": "data.samples",
        "documentation": {}
    },
    {
        "label": "validate_sample_data",
        "importPath": "data.samples",
        "description": "data.samples",
        "isExtraImport": true,
        "detail": "data.samples",
        "documentation": {}
    },
    {
        "label": "load_sample_data",
        "importPath": "data.samples",
        "description": "data.samples",
        "isExtraImport": true,
        "detail": "data.samples",
        "documentation": {}
    },
    {
        "label": "get_latest_price",
        "importPath": "data.samples",
        "description": "data.samples",
        "isExtraImport": true,
        "detail": "data.samples",
        "documentation": {}
    },
    {
        "label": "get_sample_market_data",
        "importPath": "data.samples",
        "description": "data.samples",
        "isExtraImport": true,
        "detail": "data.samples",
        "documentation": {}
    },
    {
        "label": "get_available_symbols",
        "importPath": "data.samples",
        "description": "data.samples",
        "isExtraImport": true,
        "detail": "data.samples",
        "documentation": {}
    },
    {
        "label": "validate_sample_data",
        "importPath": "data.samples",
        "description": "data.samples",
        "isExtraImport": true,
        "detail": "data.samples",
        "documentation": {}
    },
    {
        "label": "load_sample_data",
        "importPath": "data.samples",
        "description": "data.samples",
        "isExtraImport": true,
        "detail": "data.samples",
        "documentation": {}
    },
    {
        "label": "get_latest_price",
        "importPath": "data.samples",
        "description": "data.samples",
        "isExtraImport": true,
        "detail": "data.samples",
        "documentation": {}
    },
    {
        "label": "get_sample_market_data",
        "importPath": "data.samples",
        "description": "data.samples",
        "isExtraImport": true,
        "detail": "data.samples",
        "documentation": {}
    },
    {
        "label": "get_available_symbols",
        "importPath": "data.samples",
        "description": "data.samples",
        "isExtraImport": true,
        "detail": "data.samples",
        "documentation": {}
    },
    {
        "label": "validate_sample_data",
        "importPath": "data.samples",
        "description": "data.samples",
        "isExtraImport": true,
        "detail": "data.samples",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "threading,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading.",
        "description": "threading.",
        "detail": "threading.",
        "documentation": {}
    },
    {
        "label": "get_client",
        "importPath": "exchange.binance_client",
        "description": "exchange.binance_client",
        "isExtraImport": true,
        "detail": "exchange.binance_client",
        "documentation": {}
    },
    {
        "label": "safe_call",
        "importPath": "exchange.binance_client",
        "description": "exchange.binance_client",
        "isExtraImport": true,
        "detail": "exchange.binance_client",
        "documentation": {}
    },
    {
        "label": "adjust_price",
        "importPath": "exchange.precision",
        "description": "exchange.precision",
        "isExtraImport": true,
        "detail": "exchange.precision",
        "documentation": {}
    },
    {
        "label": "typer",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "typer",
        "description": "typer",
        "detail": "typer",
        "documentation": {}
    },
    {
        "label": "Console",
        "importPath": "rich.console",
        "description": "rich.console",
        "isExtraImport": true,
        "detail": "rich.console",
        "documentation": {}
    },
    {
        "label": "Table",
        "importPath": "rich.table",
        "description": "rich.table",
        "isExtraImport": true,
        "detail": "rich.table",
        "documentation": {}
    },
    {
        "label": "re,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re.",
        "description": "re.",
        "detail": "re.",
        "documentation": {}
    },
    {
        "label": "dedent",
        "importPath": "textwrap",
        "description": "textwrap",
        "isExtraImport": true,
        "detail": "textwrap",
        "documentation": {}
    },
    {
        "label": "dedent",
        "importPath": "textwrap",
        "description": "textwrap",
        "isExtraImport": true,
        "detail": "textwrap",
        "documentation": {}
    },
    {
        "label": "dedent",
        "importPath": "textwrap",
        "description": "textwrap",
        "isExtraImport": true,
        "detail": "textwrap",
        "documentation": {}
    },
    {
        "label": "dedent",
        "importPath": "textwrap",
        "description": "textwrap",
        "isExtraImport": true,
        "detail": "textwrap",
        "documentation": {}
    },
    {
        "label": "builtins",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "builtins",
        "description": "builtins",
        "detail": "builtins",
        "documentation": {}
    },
    {
        "label": "compat",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "compat",
        "description": "compat",
        "detail": "compat",
        "documentation": {}
    },
    {
        "label": "inspect,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect.",
        "description": "inspect.",
        "detail": "inspect.",
        "documentation": {}
    },
    {
        "label": "SimpleNamespace",
        "importPath": "types",
        "description": "types",
        "isExtraImport": true,
        "detail": "types",
        "documentation": {}
    },
    {
        "label": "importlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib",
        "description": "importlib",
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "wraps",
        "importPath": "functools",
        "description": "functools",
        "isExtraImport": true,
        "detail": "functools",
        "documentation": {}
    },
    {
        "label": "importlib.util",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib.util",
        "description": "importlib.util",
        "detail": "importlib.util",
        "documentation": {}
    },
    {
        "label": "aiohttp",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "aiohttp",
        "description": "aiohttp",
        "detail": "aiohttp",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "core.config",
        "description": "core.config",
        "peekOfCode": "class Config(BaseModel):\n    \"\"\"Main configuration object with validation helpers.\"\"\"\n    env_file_default: ClassVar[Optional[Path]] = None\n    # Trading mode / behaviour\n    mode: TradingMode = Field(default=TradingMode.PAPER)\n    dry_run: bool = Field(default=True)\n    testnet: bool = Field(default=True)\n    save_reports: bool = Field(default=True)\n    # API credentials\n    binance_api_key: str = Field(default=\"\")",
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "load_config",
        "kind": 2,
        "importPath": "core.config",
        "description": "core.config",
        "peekOfCode": "def load_config(env_file: Optional[str] = None) -> Config:\n    global _config\n    _config = Config.from_env(env_file)\n    return _config\ndef get_config() -> Config:\n    global _config\n    if _config is None:\n        _config = load_config()\n    return _config\ndef reload_config(env_file: Optional[str] = None) -> Config:",
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "get_config",
        "kind": 2,
        "importPath": "core.config",
        "description": "core.config",
        "peekOfCode": "def get_config() -> Config:\n    global _config\n    if _config is None:\n        _config = load_config()\n    return _config\ndef reload_config(env_file: Optional[str] = None) -> Config:\n    global _config\n    _config = None\n    return load_config(env_file)",
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "reload_config",
        "kind": 2,
        "importPath": "core.config",
        "description": "core.config",
        "peekOfCode": "def reload_config(env_file: Optional[str] = None) -> Config:\n    global _config\n    _config = None\n    return load_config(env_file)",
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "_BOOL_TRUE",
        "kind": 5,
        "importPath": "core.config",
        "description": "core.config",
        "peekOfCode": "_BOOL_TRUE = {\"true\", \"1\", \"yes\", \"y\", \"on\"}\n_BOOL_FALSE = {\"false\", \"0\", \"no\", \"n\", \"off\"}\n_VALID_TIMEFRAMES = {tf.value for tf in Timeframe}\ndef _parse_bool(value: object, default: bool) -> bool:\n    \"\"\"Parse truthy/falsey values from environment variables.\"\"\"\n    if isinstance(value, bool):\n        return value\n    if value is None:\n        return default\n    text = str(value).strip().lower()",
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "_BOOL_FALSE",
        "kind": 5,
        "importPath": "core.config",
        "description": "core.config",
        "peekOfCode": "_BOOL_FALSE = {\"false\", \"0\", \"no\", \"n\", \"off\"}\n_VALID_TIMEFRAMES = {tf.value for tf in Timeframe}\ndef _parse_bool(value: object, default: bool) -> bool:\n    \"\"\"Parse truthy/falsey values from environment variables.\"\"\"\n    if isinstance(value, bool):\n        return value\n    if value is None:\n        return default\n    text = str(value).strip().lower()\n    if text in _BOOL_TRUE:",
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "_VALID_TIMEFRAMES",
        "kind": 5,
        "importPath": "core.config",
        "description": "core.config",
        "peekOfCode": "_VALID_TIMEFRAMES = {tf.value for tf in Timeframe}\ndef _parse_bool(value: object, default: bool) -> bool:\n    \"\"\"Parse truthy/falsey values from environment variables.\"\"\"\n    if isinstance(value, bool):\n        return value\n    if value is None:\n        return default\n    text = str(value).strip().lower()\n    if text in _BOOL_TRUE:\n        return True",
        "detail": "core.config",
        "documentation": {}
    },
    {
        "label": "TradingMode",
        "kind": 6,
        "importPath": "core.constants",
        "description": "core.constants",
        "peekOfCode": "class TradingMode(Enum):\n    \"\"\"Trading execution modes.\"\"\"\n    LIVE = \"live\"\n    PAPER = \"paper\"\n    BACKTEST = \"backtest\"\nclass OrderSide(Enum):\n    \"\"\"Order side directions.\"\"\"\n    BUY = \"BUY\"\n    SELL = \"SELL\"\nclass OrderType(Enum):",
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "OrderSide",
        "kind": 6,
        "importPath": "core.constants",
        "description": "core.constants",
        "peekOfCode": "class OrderSide(Enum):\n    \"\"\"Order side directions.\"\"\"\n    BUY = \"BUY\"\n    SELL = \"SELL\"\nclass OrderType(Enum):\n    \"\"\"Order types.\"\"\"\n    MARKET = \"MARKET\"\n    LIMIT = \"LIMIT\"\n    STOP = \"STOP\"\n    STOP_MARKET = \"STOP_MARKET\"",
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "OrderType",
        "kind": 6,
        "importPath": "core.constants",
        "description": "core.constants",
        "peekOfCode": "class OrderType(Enum):\n    \"\"\"Order types.\"\"\"\n    MARKET = \"MARKET\"\n    LIMIT = \"LIMIT\"\n    STOP = \"STOP\"\n    STOP_MARKET = \"STOP_MARKET\"\n    TAKE_PROFIT = \"TAKE_PROFIT\"\n    TAKE_PROFIT_MARKET = \"TAKE_PROFIT_MARKET\"\nclass PositionSide(Enum):\n    \"\"\"Position sides for futures trading.\"\"\"",
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "PositionSide",
        "kind": 6,
        "importPath": "core.constants",
        "description": "core.constants",
        "peekOfCode": "class PositionSide(Enum):\n    \"\"\"Position sides for futures trading.\"\"\"\n    LONG = \"LONG\"\n    SHORT = \"SHORT\"\n    BOTH = \"BOTH\"\nclass SignalType(Enum):\n    \"\"\"Trading signal types.\"\"\"\n    BUY = \"BUY\"\n    SELL = \"SELL\"\n    HOLD = \"HOLD\"",
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "SignalType",
        "kind": 6,
        "importPath": "core.constants",
        "description": "core.constants",
        "peekOfCode": "class SignalType(Enum):\n    \"\"\"Trading signal types.\"\"\"\n    BUY = \"BUY\"\n    SELL = \"SELL\"\n    HOLD = \"HOLD\"\nclass ExitReason(Enum):\n    \"\"\"Reasons for position exits.\"\"\"\n    STOP_LOSS = \"STOP_LOSS\"\n    TAKE_PROFIT = \"TAKE_PROFIT\"\n    TRAILING_STOP = \"TRAILING_STOP\"",
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "ExitReason",
        "kind": 6,
        "importPath": "core.constants",
        "description": "core.constants",
        "peekOfCode": "class ExitReason(Enum):\n    \"\"\"Reasons for position exits.\"\"\"\n    STOP_LOSS = \"STOP_LOSS\"\n    TAKE_PROFIT = \"TAKE_PROFIT\"\n    TRAILING_STOP = \"TRAILING_STOP\"\n    SIGNAL_REVERSE = \"SIGNAL_REVERSE\"\n    RISK_MANAGEMENT = \"RISK_MANAGEMENT\"\n    MANUAL = \"MANUAL\"\nclass OrderStatus(Enum):\n    \"\"\"Order status types.\"\"\"",
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "OrderStatus",
        "kind": 6,
        "importPath": "core.constants",
        "description": "core.constants",
        "peekOfCode": "class OrderStatus(Enum):\n    \"\"\"Order status types.\"\"\"\n    NEW = \"NEW\"\n    PARTIALLY_FILLED = \"PARTIALLY_FILLED\"\n    FILLED = \"FILLED\"\n    CANCELED = \"CANCELED\"\n    REJECTED = \"REJECTED\"\n    EXPIRED = \"EXPIRED\"\nclass Regime(Enum):\n    \"\"\"Market regime types.\"\"\"",
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "Regime",
        "kind": 6,
        "importPath": "core.constants",
        "description": "core.constants",
        "peekOfCode": "class Regime(Enum):\n    \"\"\"Market regime types.\"\"\"\n    TRENDING = \"TRENDING\"\n    RANGING = \"RANGING\"\n    VOLATILE = \"VOLATILE\"\n    STABLE = \"STABLE\"\nclass SignalDirection(Enum):\n    \"\"\"Signal direction types.\"\"\"\n    LONG = \"LONG\"\n    SHORT = \"SHORT\"",
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "SignalDirection",
        "kind": 6,
        "importPath": "core.constants",
        "description": "core.constants",
        "peekOfCode": "class SignalDirection(Enum):\n    \"\"\"Signal direction types.\"\"\"\n    LONG = \"LONG\"\n    SHORT = \"SHORT\"\n    NEUTRAL = \"NEUTRAL\"\n    CLOSE = \"CLOSE\"\nclass WorkingType(Enum):\n    \"\"\"Order working types for futures trading.\"\"\"\n    MARK_PRICE = \"MARK_PRICE\"\n    CONTRACT_PRICE = \"CONTRACT_PRICE\"",
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "WorkingType",
        "kind": 6,
        "importPath": "core.constants",
        "description": "core.constants",
        "peekOfCode": "class WorkingType(Enum):\n    \"\"\"Order working types for futures trading.\"\"\"\n    MARK_PRICE = \"MARK_PRICE\"\n    CONTRACT_PRICE = \"CONTRACT_PRICE\"\nclass TimeInForce(Enum):\n    \"\"\"Order time in force types.\"\"\"\n    GTC = \"GTC\"  # Good Till Cancel\n    IOC = \"IOC\"  # Immediate or Cancel  \n    FOK = \"FOK\"  # Fill or Kill\n    GTX = \"GTX\"  # Good Till Crossing",
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "TimeInForce",
        "kind": 6,
        "importPath": "core.constants",
        "description": "core.constants",
        "peekOfCode": "class TimeInForce(Enum):\n    \"\"\"Order time in force types.\"\"\"\n    GTC = \"GTC\"  # Good Till Cancel\n    IOC = \"IOC\"  # Immediate or Cancel  \n    FOK = \"FOK\"  # Fill or Kill\n    GTX = \"GTX\"  # Good Till Crossing\nclass Timeframe(Enum):\n    \"\"\"Trading timeframe intervals.\"\"\"\n    M1 = \"1m\"    # 1 minute\n    M3 = \"3m\"    # 3 minutes",
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "Timeframe",
        "kind": 6,
        "importPath": "core.constants",
        "description": "core.constants",
        "peekOfCode": "class Timeframe(Enum):\n    \"\"\"Trading timeframe intervals.\"\"\"\n    M1 = \"1m\"    # 1 minute\n    M3 = \"3m\"    # 3 minutes\n    M5 = \"5m\"    # 5 minutes\n    M15 = \"15m\"  # 15 minutes\n    M30 = \"30m\"  # 30 minutes\n    H1 = \"1h\"    # 1 hour\n    H2 = \"2h\"    # 2 hours\n    H4 = \"4h\"    # 4 hours",
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_LOT_SIZE",
        "kind": 5,
        "importPath": "core.constants",
        "description": "core.constants",
        "peekOfCode": "DEFAULT_LOT_SIZE = 0.001\nDEFAULT_TICK_SIZE = 0.01\nVALID_SYMBOLS = [\n    \"BTCUSDT\", \"ETHUSDT\", \"BNBUSDT\", \"ADAUSDT\", \"DOGEUSDT\",\n    \"XRPUSDT\", \"DOTUSDT\", \"UNIUSDT\", \"LINKUSDT\", \"LTCUSDT\"\n]\n# Timeframe mappings in milliseconds\nTIMEFRAME_MS = {\n    '1m': 60 * 1000,\n    '3m': 3 * 60 * 1000,",
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "DEFAULT_TICK_SIZE",
        "kind": 5,
        "importPath": "core.constants",
        "description": "core.constants",
        "peekOfCode": "DEFAULT_TICK_SIZE = 0.01\nVALID_SYMBOLS = [\n    \"BTCUSDT\", \"ETHUSDT\", \"BNBUSDT\", \"ADAUSDT\", \"DOGEUSDT\",\n    \"XRPUSDT\", \"DOTUSDT\", \"UNIUSDT\", \"LINKUSDT\", \"LTCUSDT\"\n]\n# Timeframe mappings in milliseconds\nTIMEFRAME_MS = {\n    '1m': 60 * 1000,\n    '3m': 3 * 60 * 1000,\n    '5m': 5 * 60 * 1000,",
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "VALID_SYMBOLS",
        "kind": 5,
        "importPath": "core.constants",
        "description": "core.constants",
        "peekOfCode": "VALID_SYMBOLS = [\n    \"BTCUSDT\", \"ETHUSDT\", \"BNBUSDT\", \"ADAUSDT\", \"DOGEUSDT\",\n    \"XRPUSDT\", \"DOTUSDT\", \"UNIUSDT\", \"LINKUSDT\", \"LTCUSDT\"\n]\n# Timeframe mappings in milliseconds\nTIMEFRAME_MS = {\n    '1m': 60 * 1000,\n    '3m': 3 * 60 * 1000,\n    '5m': 5 * 60 * 1000,\n    '15m': 15 * 60 * 1000,",
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "TIMEFRAME_MS",
        "kind": 5,
        "importPath": "core.constants",
        "description": "core.constants",
        "peekOfCode": "TIMEFRAME_MS = {\n    '1m': 60 * 1000,\n    '3m': 3 * 60 * 1000,\n    '5m': 5 * 60 * 1000,\n    '15m': 15 * 60 * 1000,\n    '30m': 30 * 60 * 1000,\n    '1h': 60 * 60 * 1000,\n    '2h': 2 * 60 * 60 * 1000,\n    '4h': 4 * 60 * 60 * 1000,\n    '6h': 6 * 60 * 60 * 1000,",
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "TIMEFRAME_TO_MINUTES",
        "kind": 5,
        "importPath": "core.constants",
        "description": "core.constants",
        "peekOfCode": "TIMEFRAME_TO_MINUTES = {\n    '1m': 1,\n    '3m': 3,\n    '5m': 5,\n    '15m': 15,\n    '30m': 30,\n    '1h': 60,\n    '2h': 120,\n    '4h': 240,\n    '6h': 360,",
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "core.constants",
        "description": "core.constants",
        "peekOfCode": "__all__ = [\n    \"TradingMode\",\n    \"OrderSide\", \n    \"OrderType\",\n    \"OrderStatus\",\n    \"PositionSide\",\n    \"SignalType\",\n    \"SignalDirection\",\n    \"ExitReason\",\n    \"Regime\",",
        "detail": "core.constants",
        "documentation": {}
    },
    {
        "label": "apply_default_overrides",
        "kind": 2,
        "importPath": "core.env_overrides",
        "description": "core.env_overrides",
        "peekOfCode": "def apply_default_overrides(config, explicit_env_path: Optional[str] = None):\n    # 1) Подгружаем .env, если указан путь\n    env_path = explicit_env_path or os.getenv(\"BOT_CONFIG_PATH\") or os.getenv(\"CONFIG_PATH\")\n    try:\n        from dotenv import load_dotenv\n    except Exception:\n        load_dotenv = None\n    if env_path and load_dotenv:\n        try:\n            load_dotenv(env_path, override=True)",
        "detail": "core.env_overrides",
        "documentation": {}
    },
    {
        "label": "SignalSource",
        "kind": 6,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "class SignalSource(str, Enum):\n    \"\"\"Source of trading signals.\"\"\"\n    TECHNICAL = \"technical\"\n    FUNDAMENTAL = \"fundamental\"\n    ML_MODEL = \"ml_model\"\n    NEWS = \"news\"\n    MANUAL = \"manual\"\nclass SignalType(str, Enum):\n    \"\"\"Type of trading signal.\"\"\"\n    BUY = \"buy\"",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "SignalType",
        "kind": 6,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "class SignalType(str, Enum):\n    \"\"\"Type of trading signal.\"\"\"\n    BUY = \"buy\"\n    SELL = \"sell\"\n    HOLD = \"hold\"\n@dataclass\nclass Position:\n    \"\"\"Represents a trading position.\"\"\"\n    symbol: str\n    side: int  # 1 for long, -1 for short, 0 for flat",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Position",
        "kind": 6,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "class Position:\n    \"\"\"Represents a trading position.\"\"\"\n    symbol: str\n    side: int  # 1 for long, -1 for short, 0 for flat\n    size: float\n    entry_price: float\n    unrealized_pnl: float = 0.0\n    realized_pnl: float = 0.0\n    timestamp: datetime | None = None\n    @property",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Order",
        "kind": 6,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "class Order:\n    \"\"\"Represents a trading order.\"\"\"\n    symbol: str\n    side: OrderSide\n    type: OrderType\n    quantity: float\n    price: float | None = None\n    stop_price: float | None = None\n    order_id: str | None = None\n    client_order_id: str | None = None",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Trade",
        "kind": 6,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "class Trade:\n    \"\"\"Represents a completed trade.\"\"\"\n    symbol: str\n    side: int  # 1 for long, -1 for short\n    entry_price: float\n    exit_price: float | None\n    quantity: float\n    pnl: float\n    fee: float\n    entry_time: datetime",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Signal",
        "kind": 6,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "class Signal:\n    \"\"\"Represents a trading signal.\"\"\"\n    name: str\n    direction: SignalDirection\n    strength: float  # 0.0 to 1.0\n    symbol: str\n    price: float\n    timestamp: datetime\n    info: dict[str, Any]\n    @property",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "MarketData",
        "kind": 6,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "class MarketData:\n    \"\"\"Market data snapshot.\"\"\"\n    symbol: str\n    price: float\n    bid: float\n    ask: float\n    volume: float\n    timestamp: datetime\n    funding_rate: float | None = None\n    open_interest: float | None = None",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Candle",
        "kind": 6,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "class Candle:\n    \"\"\"OHLCV candle data.\"\"\"\n    timestamp: datetime\n    open: float\n    high: float\n    low: float\n    close: float\n    volume: float\n    @property\n    def body_size(self) -> float:",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "TechnicalIndicators",
        "kind": 6,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "class TechnicalIndicators:\n    \"\"\"Technical analysis indicators.\"\"\"\n    rsi: float | None = None\n    macd: float | None = None\n    macd_signal: float | None = None\n    macd_hist: float | None = None\n    bb_upper: float | None = None\n    bb_mid: float | None = None\n    bb_lower: float | None = None\n    bb_width: float | None = None",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "RegimeInfo",
        "kind": 6,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "class RegimeInfo:\n    \"\"\"Market regime information.\"\"\"\n    type: Regime\n    adx: float\n    bb_width: float\n    confidence: float = 0.0\n@dataclass\nclass RiskMetrics:\n    \"\"\"Risk management metrics.\"\"\"\n    position_size_usd: float",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "RiskMetrics",
        "kind": 6,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "class RiskMetrics:\n    \"\"\"Risk management metrics.\"\"\"\n    position_size_usd: float\n    leverage_used: float\n    account_risk_pct: float\n    daily_pnl: float\n    max_drawdown: float\n    var_95: float | None = None\n    @property\n    def is_risk_exceeded(self) -> bool:",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "BacktestResult",
        "kind": 6,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "class BacktestResult:\n    \"\"\"Backtest results and metrics.\"\"\"\n    symbol: str\n    start_date: datetime\n    end_date: datetime\n    initial_balance: float\n    final_balance: float\n    total_trades: int\n    winning_trades: int\n    losing_trades: int",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "PriceProvider",
        "kind": 6,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "class PriceProvider(Protocol):\n    \"\"\"Protocol for price data providers.\"\"\"\n    def get_current_price(self, symbol: str) -> float:\n        \"\"\"Get current market price for symbol.\"\"\"\n        ...\n    def get_historical_data(\n        self, symbol: str, timeframe: str, limit: int\n    ) -> list[Candle]:\n        \"\"\"Get historical candle data.\"\"\"\n        ...",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "OrderExecutor",
        "kind": 6,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "class OrderExecutor(Protocol):\n    \"\"\"Protocol for order execution.\"\"\"\n    def place_order(self, order: Order) -> Order:\n        \"\"\"Place a new order.\"\"\"\n        ...\n    def cancel_order(self, symbol: str, order_id: str) -> bool:\n        \"\"\"Cancel an existing order.\"\"\"\n        ...\n    def get_open_orders(self, symbol: str | None = None) -> list[Order]:\n        \"\"\"Get all open orders.\"\"\"",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "OrderUpdate",
        "kind": 6,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "class OrderUpdate:\n    \"\"\"WebSocket order update message.\"\"\"\n    symbol: str\n    order_id: int\n    client_order_id: str\n    side: str\n    order_type: str\n    status: str\n    quantity: float\n    price: float | None",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "PositionUpdate",
        "kind": 6,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "class PositionUpdate:\n    \"\"\"WebSocket position update message.\"\"\"\n    symbol: str\n    position_side: str\n    position_amount: float\n    entry_price: float\n    unrealized_pnl: float\n    timestamp: datetime\n    @property\n    def is_long(self) -> bool:",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "PositionManager",
        "kind": 6,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "class PositionManager(Protocol):\n    \"\"\"Protocol for position management.\"\"\"\n    def get_position(self, symbol: str) -> Position:\n        \"\"\"Get current position for symbol.\"\"\"\n        ...\n    def get_all_positions(self) -> list[Position]:\n        \"\"\"Get all open positions.\"\"\"\n        ...\n# Type aliases for commonly used types\nPriceDict = dict[str, float]",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "PriceDict",
        "kind": 5,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "PriceDict = dict[str, float]\nIndicatorDict = dict[str, float | int | str]\nSignalDict = dict[str, Any]\nConfigDict = dict[str, Any]\nSymbolFilters = dict[str, dict[str, float]]\n# Union types\nNumeric = int | float | Decimal\nTimestampType = int | float | datetime\nOrderID = str | int",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "IndicatorDict",
        "kind": 5,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "IndicatorDict = dict[str, float | int | str]\nSignalDict = dict[str, Any]\nConfigDict = dict[str, Any]\nSymbolFilters = dict[str, dict[str, float]]\n# Union types\nNumeric = int | float | Decimal\nTimestampType = int | float | datetime\nOrderID = str | int",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "SignalDict",
        "kind": 5,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "SignalDict = dict[str, Any]\nConfigDict = dict[str, Any]\nSymbolFilters = dict[str, dict[str, float]]\n# Union types\nNumeric = int | float | Decimal\nTimestampType = int | float | datetime\nOrderID = str | int",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "ConfigDict",
        "kind": 5,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "ConfigDict = dict[str, Any]\nSymbolFilters = dict[str, dict[str, float]]\n# Union types\nNumeric = int | float | Decimal\nTimestampType = int | float | datetime\nOrderID = str | int",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "SymbolFilters",
        "kind": 5,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "SymbolFilters = dict[str, dict[str, float]]\n# Union types\nNumeric = int | float | Decimal\nTimestampType = int | float | datetime\nOrderID = str | int",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "Numeric",
        "kind": 5,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "Numeric = int | float | Decimal\nTimestampType = int | float | datetime\nOrderID = str | int",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "TimestampType",
        "kind": 5,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "TimestampType = int | float | datetime\nOrderID = str | int",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "OrderID",
        "kind": 5,
        "importPath": "core.types",
        "description": "core.types",
        "peekOfCode": "OrderID = str | int",
        "detail": "core.types",
        "documentation": {}
    },
    {
        "label": "_IdentityScaler",
        "kind": 6,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "class _IdentityScaler:\n    def fit(self, X, y=None): return self\n    def transform(self, X): return X\n    def fit_transform(self, X, y=None): return X\n    def inverse_transform(self, X): return X\nclass _IdentitySelector:\n    def __init__(self, k=10): self.k = k\n    def fit(self, X, y=None): return self\n    def transform(self, X): return X\n    def get_support(self, indices=False):",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "_IdentitySelector",
        "kind": 6,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "class _IdentitySelector:\n    def __init__(self, k=10): self.k = k\n    def fit(self, X, y=None): return self\n    def transform(self, X): return X\n    def get_support(self, indices=False):\n        import numpy as _np\n        if indices: return _np.arange(0, 0, dtype=int)\n        return []\ndef _f_regression_stub(X, y):  # совместимость с API\n    import numpy as _np",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "_SklearnComponents",
        "kind": 6,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "class _SklearnComponents:\n    \"\"\"\n    Гибрид: поддерживает и `obj['Name']`, и `obj.Name`.\n    \"\"\"\n    def __init__(self):\n        try:\n            from sklearn.preprocessing import StandardScaler as _StandardScaler  # type: ignore\n            from sklearn.preprocessing import MinMaxScaler as _MinMaxScaler     # type: ignore\n            from sklearn.preprocessing import RobustScaler as _RobustScaler     # type: ignore\n            from sklearn.feature_selection import SelectKBest as _SelectKBest   # type: ignore",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "safe_float",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def safe_float(value: Any, default: float = 0.0) -> float:\n    try:\n        if value is None:\n            return float(default)\n        if isinstance(value, (int, float)):\n            return float(value)\n        s = str(value).strip()\n        if s == \"\" or s.lower() in (\"none\", \"null\", \"nan\"):\n            return float(default)\n        return float(s)",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "safe_int",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def safe_int(value: Any, default: int = 0) -> int:\n    try:\n        if value is None:\n            return int(default)\n        if isinstance(value, (int, float)):\n            return int(value)\n        s = str(value).strip()\n        if s == \"\" or s.lower() in (\"none\", \"null\", \"nan\"):\n            return int(default)\n        return int(float(s))",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "clamp",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def clamp(x: float, lo: float, hi: float) -> float:\n    return max(lo, min(hi, x))\ndef exponential_backoff(attempt: int, base_delay: float = 1.0, max_delay: float = 60.0) -> float:\n    delay = base_delay * (2 ** max(0, int(attempt)))\n    jitter = random.uniform(0.1, 0.9) * delay\n    return min(max_delay, delay + jitter)\ndef now_ms() -> int:\n    return int(time.time() * 1000)\ndef get_current_timestamp() -> int:\n    return now_ms()",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "exponential_backoff",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def exponential_backoff(attempt: int, base_delay: float = 1.0, max_delay: float = 60.0) -> float:\n    delay = base_delay * (2 ** max(0, int(attempt)))\n    jitter = random.uniform(0.1, 0.9) * delay\n    return min(max_delay, delay + jitter)\ndef now_ms() -> int:\n    return int(time.time() * 1000)\ndef get_current_timestamp() -> int:\n    return now_ms()\ndef milliseconds_to_datetime(ts_ms: int) -> datetime:\n    return datetime.fromtimestamp(ts_ms / 1000.0, tz=timezone.utc)",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "now_ms",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def now_ms() -> int:\n    return int(time.time() * 1000)\ndef get_current_timestamp() -> int:\n    return now_ms()\ndef milliseconds_to_datetime(ts_ms: int) -> datetime:\n    return datetime.fromtimestamp(ts_ms / 1000.0, tz=timezone.utc)\ndef datetime_to_milliseconds(dt: datetime) -> int:\n    return int(dt.timestamp() * 1000)\n# ---------------------------------------------------------------------\n# Symbols normalization",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "get_current_timestamp",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def get_current_timestamp() -> int:\n    return now_ms()\ndef milliseconds_to_datetime(ts_ms: int) -> datetime:\n    return datetime.fromtimestamp(ts_ms / 1000.0, tz=timezone.utc)\ndef datetime_to_milliseconds(dt: datetime) -> int:\n    return int(dt.timestamp() * 1000)\n# ---------------------------------------------------------------------\n# Symbols normalization\n# ---------------------------------------------------------------------\ndef normalize_symbol(symbol: str) -> str:",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "milliseconds_to_datetime",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def milliseconds_to_datetime(ts_ms: int) -> datetime:\n    return datetime.fromtimestamp(ts_ms / 1000.0, tz=timezone.utc)\ndef datetime_to_milliseconds(dt: datetime) -> int:\n    return int(dt.timestamp() * 1000)\n# ---------------------------------------------------------------------\n# Symbols normalization\n# ---------------------------------------------------------------------\ndef normalize_symbol(symbol: str) -> str:\n    \"\"\"\n    Привести символ к UM Futures формату.",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "datetime_to_milliseconds",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def datetime_to_milliseconds(dt: datetime) -> int:\n    return int(dt.timestamp() * 1000)\n# ---------------------------------------------------------------------\n# Symbols normalization\n# ---------------------------------------------------------------------\ndef normalize_symbol(symbol: str) -> str:\n    \"\"\"\n    Привести символ к UM Futures формату.\n    - Убирает '/', '-', '_' и пробелы.\n    - Верхний регистр.",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "normalize_symbol",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def normalize_symbol(symbol: str) -> str:\n    \"\"\"\n    Привести символ к UM Futures формату.\n    - Убирает '/', '-', '_' и пробелы.\n    - Верхний регистр.\n    - Автосуффикс USDT для распространённых баз, если без суффикса.\n    Примеры: 'btc' -> 'BTCUSDT', 'ETH/USDT' -> 'ETHUSDT', 'SOL' -> 'SOLUSDT'.\n    \"\"\"\n    if not symbol:\n        return \"\"",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "validate_symbol_format",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def validate_symbol_format(symbol: str) -> bool:\n    try:\n        n = normalize_symbol(symbol)\n        return len(n) >= 6 and n.isalnum()\n    except Exception:\n        return False\n# ---------------------------------------------------------------------\n# Precision cache & rounding helpers (symbol-aware, для exchange.orders)  # :contentReference[oaicite:6]{index=6}\n# ---------------------------------------------------------------------\n# Кэш: {SYMBOL: {\"tick\": .., \"step\": .., \"min_notional\": ..}}",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "update_symbol_filters",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def update_symbol_filters(arg1, *args, **kwargs):\n    \"\"\"\n    Совмещённая функция для двух сигнатур:\n    1) Новый паттерн, ожидаемый ордерным слоем:\n       update_symbol_filters(symbol: str, tick: float, step: float, min_notional: float)\n    2) Ваш прежний паттерн (dict):\n       update_symbol_filters(symbol_info: dict, symbol: str = \"\")\n       -> возвращает нормализованный dict-фильтр (оставлен для совместимости).\n    Обе ветки обновляют внутренний кэш _SYMBOL_FILTERS, если известны symbol/tick/step/min_notional.\n    \"\"\"",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "get_symbol_filters_tuple",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def get_symbol_filters_tuple(symbol: str) -> Tuple[float, float, float]:\n    \"\"\"Вернёт (tick, step, min_notional) для symbol (или дефолты).\"\"\"\n    f = _SYMBOL_FILTERS.get(str(symbol).upper(), {}) if symbol else {}\n    tick = float(f.get(\"tick\", 0.01) or 0.01)\n    step = float(f.get(\"step\", 0.001) or 0.001)\n    mn   = float(f.get(\"min_notional\", 5.0) or 5.0)\n    return tick, step, mn\ndef get_symbol_filters_dict(symbol: str) -> Dict[str, Any]:\n    \"\"\"Dict-представление фильтров (обратная совместимость с вашим кодом).\"\"\"\n    tick, step, mn = get_symbol_filters_tuple(symbol)",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "get_symbol_filters_dict",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def get_symbol_filters_dict(symbol: str) -> Dict[str, Any]:\n    \"\"\"Dict-представление фильтров (обратная совместимость с вашим кодом).\"\"\"\n    tick, step, mn = get_symbol_filters_tuple(symbol)\n    return {\n        'symbol': symbol,\n        'status': 'TRADING',\n        'baseAsset': symbol.replace('USDT', ''),\n        'quoteAsset': 'USDT' if 'USDT' in symbol else 'BUSD' if 'BUSD' in symbol else 'USD',\n        'minPrice': 0.0,\n        'maxPrice': float('inf'),",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "get_symbol_filters",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def get_symbol_filters(symbol: str) -> Dict[str, Any]:\n    return get_symbol_filters_dict(symbol)\ndef round_price(symbol: str, price: float, tick_size: Optional[float] = None) -> float:\n    \"\"\"\n    Округлить цену ВНИЗ к сетке биржи (в отличие от обычного round(...)).\n    Это безопаснее для лимитов/стопов и согласовано с ордерным слоем.  # :contentReference[oaicite:7]{index=7}\n    \"\"\"\n    tick, _, _ = get_symbol_filters_tuple(symbol)\n    ts = float(tick_size) if tick_size is not None else tick\n    return _floor_to_step(float(price), float(ts))",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "round_price",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def round_price(symbol: str, price: float, tick_size: Optional[float] = None) -> float:\n    \"\"\"\n    Округлить цену ВНИЗ к сетке биржи (в отличие от обычного round(...)).\n    Это безопаснее для лимитов/стопов и согласовано с ордерным слоем.  # :contentReference[oaicite:7]{index=7}\n    \"\"\"\n    tick, _, _ = get_symbol_filters_tuple(symbol)\n    ts = float(tick_size) if tick_size is not None else tick\n    return _floor_to_step(float(price), float(ts))\ndef round_qty(symbol: str, qty: float, step_size: Optional[float] = None) -> float:\n    \"\"\"Округлить количество ВНИЗ к шагу LOT_SIZE.\"\"\"",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "round_qty",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def round_qty(symbol: str, qty: float, step_size: Optional[float] = None) -> float:\n    \"\"\"Округлить количество ВНИЗ к шагу LOT_SIZE.\"\"\"\n    _, step, _ = get_symbol_filters_tuple(symbol)\n    ss = float(step_size) if step_size is not None else step\n    return _floor_to_step(abs(float(qty)), float(ss))\n# Алиасы для старого кода (без symbol)\ndef round_quantity(quantity: float, step_size: float = 0.001) -> float:\n    \"\"\"Alias (без symbol). Лучше использовать round_qty(symbol, qty, step).\"\"\"\n    return _floor_to_step(abs(float(quantity)), float(step_size))\ndef round_price_simple(price: float, tick_size: float = 0.01) -> float:",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "round_quantity",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def round_quantity(quantity: float, step_size: float = 0.001) -> float:\n    \"\"\"Alias (без symbol). Лучше использовать round_qty(symbol, qty, step).\"\"\"\n    return _floor_to_step(abs(float(quantity)), float(step_size))\ndef round_price_simple(price: float, tick_size: float = 0.01) -> float:\n    \"\"\"Alias к round_price без symbol (оставлен для старых мест).\"\"\"\n    return _floor_to_step(float(price), float(tick_size))\ndef get_precision_from_stepsize(step_size: str | float) -> int:\n    \"\"\"Подсчитать количество знаков после запятой по stepSize.\"\"\"\n    s = str(step_size)\n    if \".\" in s:",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "round_price_simple",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def round_price_simple(price: float, tick_size: float = 0.01) -> float:\n    \"\"\"Alias к round_price без symbol (оставлен для старых мест).\"\"\"\n    return _floor_to_step(float(price), float(tick_size))\ndef get_precision_from_stepsize(step_size: str | float) -> int:\n    \"\"\"Подсчитать количество знаков после запятой по stepSize.\"\"\"\n    s = str(step_size)\n    if \".\" in s:\n        return max(0, len(s.split(\".\")[1].rstrip(\"0\")))\n    return 0\ndef fmt_price(symbol: str, price: float, tick_size: Optional[float] = None) -> str:",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "get_precision_from_stepsize",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def get_precision_from_stepsize(step_size: str | float) -> int:\n    \"\"\"Подсчитать количество знаков после запятой по stepSize.\"\"\"\n    s = str(step_size)\n    if \".\" in s:\n        return max(0, len(s.split(\".\")[1].rstrip(\"0\")))\n    return 0\ndef fmt_price(symbol: str, price: float, tick_size: Optional[float] = None) -> str:\n    tick, _, _ = get_symbol_filters_tuple(symbol)\n    ts = float(tick_size) if tick_size is not None else tick\n    d = _decimals_from_step(ts)",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "fmt_price",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def fmt_price(symbol: str, price: float, tick_size: Optional[float] = None) -> str:\n    tick, _, _ = get_symbol_filters_tuple(symbol)\n    ts = float(tick_size) if tick_size is not None else tick\n    d = _decimals_from_step(ts)\n    p = round_price(symbol, price, ts)\n    return f\"{p:.{d}f}\"\ndef fmt_qty(symbol: str, qty: float, step_size: Optional[float] = None) -> str:\n    _, step, _ = get_symbol_filters_tuple(symbol)\n    ss = float(step_size) if step_size is not None else step\n    d = _decimals_from_step(ss)",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "fmt_qty",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def fmt_qty(symbol: str, qty: float, step_size: Optional[float] = None) -> str:\n    _, step, _ = get_symbol_filters_tuple(symbol)\n    ss = float(step_size) if step_size is not None else step\n    d = _decimals_from_step(ss)\n    q = round_qty(symbol, qty, ss)\n    return f\"{q:.{d}f}\"\n# ---------------------------------------------------------------------\n# Formatting helpers\n# ---------------------------------------------------------------------\ndef format_currency(amount: float, currency: str = \"USDT\", decimals: int = 2) -> str:",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "format_currency",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def format_currency(amount: float, currency: str = \"USDT\", decimals: int = 2) -> str:\n    try:\n        return f\"{float(amount):,.{int(decimals)}f} {currency}\"\n    except Exception:\n        return f\"{amount} {currency}\"\ndef format_percentage(value: float, decimals: int = 2) -> str:\n    try:\n        return f\"{float(value):.{int(decimals)}f}%\"\n    except Exception:\n        return f\"{value}%\"",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "format_percentage",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def format_percentage(value: float, decimals: int = 2) -> str:\n    try:\n        return f\"{float(value):.{int(decimals)}f}%\"\n    except Exception:\n        return f\"{value}%\"\ndef format_price_value(price: float, precision: int = 2) -> str:\n    return f\"{float(price):.{int(precision)}f}\"\ndef format_time_duration(seconds: float) -> str:\n    s = float(seconds)\n    if s < 60: return f\"{s:.1f}s\"",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "format_price_value",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def format_price_value(price: float, precision: int = 2) -> str:\n    return f\"{float(price):.{int(precision)}f}\"\ndef format_time_duration(seconds: float) -> str:\n    s = float(seconds)\n    if s < 60: return f\"{s:.1f}s\"\n    if s < 3600: return f\"{s/60:.1f}m\"\n    if s < 86400: return f\"{s/3600:.1f}h\"\n    return f\"{s/86400:.1f}d\"\ndef format_timestamp(ts: datetime | int | float, fmt: str = \"%Y-%m-%d %H:%M:%S\") -> str:\n    if isinstance(ts, (int, float)):",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "format_time_duration",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def format_time_duration(seconds: float) -> str:\n    s = float(seconds)\n    if s < 60: return f\"{s:.1f}s\"\n    if s < 3600: return f\"{s/60:.1f}m\"\n    if s < 86400: return f\"{s/3600:.1f}h\"\n    return f\"{s/86400:.1f}d\"\ndef format_timestamp(ts: datetime | int | float, fmt: str = \"%Y-%m-%d %H:%M:%S\") -> str:\n    if isinstance(ts, (int, float)):\n        t = float(ts)\n        if t > 1e10:  # мс",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "format_timestamp",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def format_timestamp(ts: datetime | int | float, fmt: str = \"%Y-%m-%d %H:%M:%S\") -> str:\n    if isinstance(ts, (int, float)):\n        t = float(ts)\n        if t > 1e10:  # мс\n            t = t / 1000.0\n        dt = datetime.fromtimestamp(t, tz=timezone.utc)\n    else:\n        dt = ts\n    return dt.strftime(fmt)\n# ---------------------------------------------------------------------",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "calculate_pnl",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def calculate_pnl(*args, **kwargs) -> float:\n    \"\"\"\n    Универсальный расчёт PnL.\n    - Вариант А: calculate_pnl(position_obj) — если первый аргумент объект позиции.\n      Использует .realized_pnl/closed_pnl если есть; иначе пытается из entry/exit/size.\n    - Вариант Б: calculate_pnl(entry_price, current_price, quantity, side=\"LONG\")\n      side: \"LONG\"|\"SHORT\"\n    Возвращает PnL в котируемой валюте.\n    \"\"\"\n    if not args:",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "calculate_position_size",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def calculate_position_size(\n    account_balance: float,\n    risk_percentage: float,\n    entry_price: float,\n    stop_price: float,\n    leverage: int = 1\n) -> float:\n    \"\"\"\n    Размер позиции из риска на сделку.\n    risk_percentage — доля, 0.01 = 1%.",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "calculate_position_size_pct",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def calculate_position_size_pct(\n    balance: float, \n    risk_percentage_pct: float, \n    entry_price: float, \n    stop_loss_price: float,\n    leverage: int = 1\n) -> float:\n    \"\"\"\n    Вариант как в части вашего кода: риск передаётся в процентах (напр. 0.5 -> 0.5%).\n    \"\"\"",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "calculate_percentage_change",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def calculate_percentage_change(old_value: float, new_value: float) -> float:\n    if old_value == 0: return 0.0\n    return ((float(new_value) - float(old_value)) / float(old_value)) * 100.0\ndef calculate_sharpe_ratio(returns: Iterable[float], risk_free_rate: float = 0.0) -> float:\n    arr = [float(x) for x in (returns or [])]\n    if len(arr) < 2: return 0.0\n    import statistics\n    mean = statistics.mean(arr) - float(risk_free_rate)\n    stdev = statistics.pstdev(arr) or 0.0\n    return (mean / stdev) if stdev else 0.0",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "calculate_sharpe_ratio",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def calculate_sharpe_ratio(returns: Iterable[float], risk_free_rate: float = 0.0) -> float:\n    arr = [float(x) for x in (returns or [])]\n    if len(arr) < 2: return 0.0\n    import statistics\n    mean = statistics.mean(arr) - float(risk_free_rate)\n    stdev = statistics.pstdev(arr) or 0.0\n    return (mean / stdev) if stdev else 0.0\ndef calculate_max_drawdown(equity_curve: Iterable[float]) -> Tuple[float, float]:\n    vals = [float(x) for x in (equity_curve or [])]\n    if len(vals) < 2: return 0.0, 0.0",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "calculate_max_drawdown",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def calculate_max_drawdown(equity_curve: Iterable[float]) -> Tuple[float, float]:\n    vals = [float(x) for x in (equity_curve or [])]\n    if len(vals) < 2: return 0.0, 0.0\n    peak = vals[0]; max_dd_abs = 0.0; max_dd_pct = 0.0\n    for v in vals[1:]:\n        if v > peak: peak = v\n        dd_abs = peak - v\n        dd_pct = (dd_abs / peak * 100.0) if peak > 0 else 0.0\n        if dd_abs > max_dd_abs: max_dd_abs = dd_abs\n        if dd_pct > max_dd_pct: max_dd_pct = dd_pct",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "format_price",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def format_price(price: float, precision: int = 2) -> str:\n    \"\"\"Старый алиас (совместимость).\"\"\"\n    return format_price_value(price, precision)\ndef round_qty_alias(quantity: float, step_size: float = 0.001) -> float:\n    \"\"\"Алиас для старого имени round_quantity.\"\"\"\n    return round_quantity(quantity, step_size)\n# Явные экспорты\n__all__ = [\n    # numba\n    \"HAS_NUMBA\", \"jit\", \"njit\", \"prange\",",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "round_qty_alias",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def round_qty_alias(quantity: float, step_size: float = 0.001) -> float:\n    \"\"\"Алиас для старого имени round_quantity.\"\"\"\n    return round_quantity(quantity, step_size)\n# Явные экспорты\n__all__ = [\n    # numba\n    \"HAS_NUMBA\", \"jit\", \"njit\", \"prange\",\n    # sklearn\n    \"sklearn_components\",\n    # symbol/precision",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "validate_symbol",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def validate_symbol(sym: str) -> str:\n    try:\n        return str(sym).strip().upper()\n    except Exception:\n        return \"\"\ndef csv_to_list(val):\n    if not val:\n        return []\n    if isinstance(val, (list, tuple)):\n        return [str(x).strip() for x in val if str(x).strip()]",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "csv_to_list",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def csv_to_list(val):\n    if not val:\n        return []\n    if isinstance(val, (list, tuple)):\n        return [str(x).strip() for x in val if str(x).strip()]\n    raw = str(val)\n    parts = [x.strip() for x in raw.replace(\" \", \"\").split(\",\") if x.strip()]\n    return parts\ndef ensure_attr(obj, name, default):\n    try:",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "ensure_attr",
        "kind": 2,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "def ensure_attr(obj, name, default):\n    try:\n        return getattr(obj, name)\n    except Exception:\n        try:\n            setattr(obj, name, default)\n        except Exception:\n            pass\n        return default",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "sklearn_components",
        "kind": 5,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "sklearn_components = _SklearnComponents()  # используется как dict и как объект  # :contentReference[oaicite:5]{index=5}\n# ---------------------------------------------------------------------\n# Base helpers\n# ---------------------------------------------------------------------\ndef safe_float(value: Any, default: float = 0.0) -> float:\n    try:\n        if value is None:\n            return float(default)\n        if isinstance(value, (int, float)):\n            return float(value)",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "core.utils",
        "description": "core.utils",
        "peekOfCode": "__all__ = [\n    # numba\n    \"HAS_NUMBA\", \"jit\", \"njit\", \"prange\",\n    # sklearn\n    \"sklearn_components\",\n    # symbol/precision\n    \"normalize_symbol\", \"validate_symbol_format\",\n    \"update_symbol_filters\", \"get_symbol_filters\", \"get_symbol_filters_tuple\", \"get_symbol_filters_dict\",\n    \"round_price\", \"round_qty\", \"round_quantity\", \"round_price_simple\",\n    \"fmt_price\", \"fmt_qty\", \"get_precision_from_stepsize\",",
        "detail": "core.utils",
        "documentation": {}
    },
    {
        "label": "KlinesMetadata",
        "kind": 6,
        "importPath": "data.large_datasets.klines_processor",
        "description": "data.large_datasets.klines_processor",
        "peekOfCode": "class KlinesMetadata:\n    \"\"\"Metadata about a klines dataset.\"\"\"\n    filename: str\n    total_rows: int\n    date_range_start: str\n    date_range_end: str\n    symbols: List[str]\n    timeframes: List[str] \n    file_size_mb: float\n    columns: List[str]",
        "detail": "data.large_datasets.klines_processor",
        "documentation": {}
    },
    {
        "label": "LargeKlinesProcessor",
        "kind": 6,
        "importPath": "data.large_datasets.klines_processor",
        "description": "data.large_datasets.klines_processor",
        "peekOfCode": "class LargeKlinesProcessor:\n    \"\"\"\n    Processes large klines CSV files with memory efficiency.\n    Features:\n    - Chunked processing for files of any size\n    - In-memory caching of frequently used data\n    - Smart sampling for ML training\n    - Data validation and cleaning\n    - Multiple output formats\n    \"\"\"",
        "detail": "data.large_datasets.klines_processor",
        "documentation": {}
    },
    {
        "label": "create_processor",
        "kind": 2,
        "importPath": "data.large_datasets.klines_processor",
        "description": "data.large_datasets.klines_processor",
        "peekOfCode": "def create_processor(cache_dir: str = \"data/cache\", memory_limit_mb: int = 1000) -> LargeKlinesProcessor:\n    \"\"\"Create a configured klines processor.\"\"\"\n    return LargeKlinesProcessor(cache_dir=cache_dir, memory_limit_mb=memory_limit_mb)",
        "detail": "data.large_datasets.klines_processor",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "data.large_datasets.klines_processor",
        "description": "data.large_datasets.klines_processor",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass KlinesMetadata:\n    \"\"\"Metadata about a klines dataset.\"\"\"\n    filename: str\n    total_rows: int\n    date_range_start: str\n    date_range_end: str\n    symbols: List[str]\n    timeframes: List[str] ",
        "detail": "data.large_datasets.klines_processor",
        "documentation": {}
    },
    {
        "label": "TrainingConfig",
        "kind": 6,
        "importPath": "data.large_datasets.ml_data_manager",
        "description": "data.large_datasets.ml_data_manager",
        "peekOfCode": "class TrainingConfig:\n    \"\"\"Configuration for ML training data preparation.\"\"\"\n    sequence_length: int = 60\n    prediction_horizon: int = 1\n    features: Optional[List[str]] = None\n    target_column: str = 'close'\n    train_split: float = 0.8\n    validation_split: float = 0.1\n    test_split: float = 0.1\n    normalize: bool = True",
        "detail": "data.large_datasets.ml_data_manager",
        "documentation": {}
    },
    {
        "label": "MLDataManager",
        "kind": 6,
        "importPath": "data.large_datasets.ml_data_manager",
        "description": "data.large_datasets.ml_data_manager",
        "peekOfCode": "class MLDataManager:\n    \"\"\"\n    Manages ML training data from large klines datasets.\n    Features:\n    - Memory-efficient data loading and preprocessing\n    - Train/validation/test splitting with time awareness\n    - Feature engineering and normalization\n    - Model training data preparation\n    - Results caching and persistence\n    \"\"\"",
        "detail": "data.large_datasets.ml_data_manager",
        "documentation": {}
    },
    {
        "label": "create_ml_manager",
        "kind": 2,
        "importPath": "data.large_datasets.ml_data_manager",
        "description": "data.large_datasets.ml_data_manager",
        "peekOfCode": "def create_ml_manager(processor: Optional[LargeKlinesProcessor] = None,\n                     cache_dir: str = \"data/ml_cache\",\n                     memory_limit_gb: float = 2.0) -> MLDataManager:\n    \"\"\"Convenience function to create ML data manager.\"\"\"\n    return MLDataManager(processor, cache_dir, memory_limit_gb)",
        "detail": "data.large_datasets.ml_data_manager",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "data.large_datasets.ml_data_manager",
        "description": "data.large_datasets.ml_data_manager",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass TrainingConfig:\n    \"\"\"Configuration for ML training data preparation.\"\"\"\n    sequence_length: int = 60\n    prediction_horizon: int = 1\n    features: Optional[List[str]] = None\n    target_column: str = 'close'\n    train_split: float = 0.8\n    validation_split: float = 0.1",
        "detail": "data.large_datasets.ml_data_manager",
        "documentation": {}
    },
    {
        "label": "TrainingConfig",
        "kind": 6,
        "importPath": "data.large_datasets.ml_data_manager_fixed",
        "description": "data.large_datasets.ml_data_manager_fixed",
        "peekOfCode": "class TrainingConfig:\n    \"\"\"Configuration for ML training data preparation.\"\"\"\n    sequence_length: int = 60\n    prediction_horizon: int = 1\n    features: Optional[List[str]] = None\n    target_column: str = 'close'\n    train_split: float = 0.8\n    validation_split: float = 0.1\n    test_split: float = 0.1\n    normalize: bool = True",
        "detail": "data.large_datasets.ml_data_manager_fixed",
        "documentation": {}
    },
    {
        "label": "MLDataManager",
        "kind": 6,
        "importPath": "data.large_datasets.ml_data_manager_fixed",
        "description": "data.large_datasets.ml_data_manager_fixed",
        "peekOfCode": "class MLDataManager:\n    \"\"\"\n    Manages ML training data from large klines datasets.\n    Features:\n    - Memory-efficient data loading and preprocessing\n    - Train/validation/test splitting with time awareness\n    - Feature engineering and normalization\n    - Model training data preparation\n    - Results caching and persistence\n    \"\"\"",
        "detail": "data.large_datasets.ml_data_manager_fixed",
        "documentation": {}
    },
    {
        "label": "create_ml_manager",
        "kind": 2,
        "importPath": "data.large_datasets.ml_data_manager_fixed",
        "description": "data.large_datasets.ml_data_manager_fixed",
        "peekOfCode": "def create_ml_manager(processor: Optional[LargeKlinesProcessor] = None,\n                     cache_dir: str = \"data/ml_cache\",\n                     memory_limit_gb: float = 2.0) -> MLDataManager:\n    \"\"\"Convenience function to create ML data manager.\"\"\"\n    return MLDataManager(processor, cache_dir, memory_limit_gb)",
        "detail": "data.large_datasets.ml_data_manager_fixed",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "data.large_datasets.ml_data_manager_fixed",
        "description": "data.large_datasets.ml_data_manager_fixed",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass TrainingConfig:\n    \"\"\"Configuration for ML training data preparation.\"\"\"\n    sequence_length: int = 60\n    prediction_horizon: int = 1\n    features: Optional[List[str]] = None\n    target_column: str = 'close'\n    train_split: float = 0.8\n    validation_split: float = 0.1",
        "detail": "data.large_datasets.ml_data_manager_fixed",
        "documentation": {}
    },
    {
        "label": "SampleSeries",
        "kind": 6,
        "importPath": "data.samples.sample_loader",
        "description": "data.samples.sample_loader",
        "peekOfCode": "class SampleSeries:\n    \"\"\"Lightweight container that behaves like a sequence and a scalar.\"\"\"\n    def __init__(self, values: Iterable[float]) -> None:\n        self._values: List[float] = [float(v) for v in values]\n    def __iter__(self):\n        return iter(self._values)\n    def __len__(self) -> int:\n        return len(self._values)\n    def __getitem__(self, item):\n        return self._values[item]",
        "detail": "data.samples.sample_loader",
        "documentation": {}
    },
    {
        "label": "load_sample_data",
        "kind": 2,
        "importPath": "data.samples.sample_loader",
        "description": "data.samples.sample_loader",
        "peekOfCode": "def load_sample_data(\n    symbol: str = \"BTCUSDT\",\n    timeframe: str = \"1m\",\n    start_rows: Optional[int] = None,\n    end_rows: Optional[int] = None,\n) -> pd.DataFrame:\n    \"\"\"Load candlestick sample data as a pandas DataFrame.\"\"\"\n    filepath = _resolve_file(symbol, timeframe)\n    df = _load_csv(filepath)\n    if start_rows is not None or end_rows is not None:",
        "detail": "data.samples.sample_loader",
        "documentation": {}
    },
    {
        "label": "get_latest_price",
        "kind": 2,
        "importPath": "data.samples.sample_loader",
        "description": "data.samples.sample_loader",
        "peekOfCode": "def get_latest_price(symbol: str = \"BTCUSDT\") -> float:\n    \"\"\"Return the latest closing price from the sample dataset.\"\"\"\n    df = load_sample_data(symbol)\n    return float(df[\"close\"].iloc[-1])\ndef get_sample_market_data(symbol: str = \"BTCUSDT\", rows: int = 30) -> MarketData:\n    \"\"\"Return recent market data formatted as :class:`MarketData`.\"\"\"\n    df = load_sample_data(symbol, end_rows=rows)\n    if df.empty:\n        raise ValueError(f\"No sample data available for {symbol}\")\n    latest_close = float(df[\"close\"].iloc[-1])",
        "detail": "data.samples.sample_loader",
        "documentation": {}
    },
    {
        "label": "get_sample_market_data",
        "kind": 2,
        "importPath": "data.samples.sample_loader",
        "description": "data.samples.sample_loader",
        "peekOfCode": "def get_sample_market_data(symbol: str = \"BTCUSDT\", rows: int = 30) -> MarketData:\n    \"\"\"Return recent market data formatted as :class:`MarketData`.\"\"\"\n    df = load_sample_data(symbol, end_rows=rows)\n    if df.empty:\n        raise ValueError(f\"No sample data available for {symbol}\")\n    latest_close = float(df[\"close\"].iloc[-1])\n    bid = latest_close * 0.999\n    ask = latest_close * 1.001\n    volume = float(df[\"volume\"].iloc[-1])\n    market = MarketData(",
        "detail": "data.samples.sample_loader",
        "documentation": {}
    },
    {
        "label": "get_available_symbols",
        "kind": 2,
        "importPath": "data.samples.sample_loader",
        "description": "data.samples.sample_loader",
        "peekOfCode": "def get_available_symbols() -> list[str]:\n    \"\"\"List all symbols with bundled sample data.\"\"\"\n    symbols = []\n    for file in _DATA_DIR.glob(\"*_1m_sample.csv\"):\n        symbols.append(file.stem.replace(\"_1m_sample\", \"\"))\n    return sorted(symbols)\ndef validate_sample_data() -> dict[str, bool]:\n    \"\"\"Validate integrity of bundled sample datasets.\"\"\"\n    results: dict[str, bool] = {}\n    for symbol in get_available_symbols():",
        "detail": "data.samples.sample_loader",
        "documentation": {}
    },
    {
        "label": "validate_sample_data",
        "kind": 2,
        "importPath": "data.samples.sample_loader",
        "description": "data.samples.sample_loader",
        "peekOfCode": "def validate_sample_data() -> dict[str, bool]:\n    \"\"\"Validate integrity of bundled sample datasets.\"\"\"\n    results: dict[str, bool] = {}\n    for symbol in get_available_symbols():\n        try:\n            df = load_sample_data(symbol)\n            checks = [\n                len(df) > 0,\n                all(col in df.columns for col in _REQUIRED_COLUMNS),\n                not df.isnull().any().any(),",
        "detail": "data.samples.sample_loader",
        "documentation": {}
    },
    {
        "label": "_DATA_DIR",
        "kind": 5,
        "importPath": "data.samples.sample_loader",
        "description": "data.samples.sample_loader",
        "peekOfCode": "_DATA_DIR = Path(__file__).parent\n_REQUIRED_COLUMNS = [\"open\", \"high\", \"low\", \"close\", \"volume\"]\nclass SampleSeries:\n    \"\"\"Lightweight container that behaves like a sequence and a scalar.\"\"\"\n    def __init__(self, values: Iterable[float]) -> None:\n        self._values: List[float] = [float(v) for v in values]\n    def __iter__(self):\n        return iter(self._values)\n    def __len__(self) -> int:\n        return len(self._values)",
        "detail": "data.samples.sample_loader",
        "documentation": {}
    },
    {
        "label": "_REQUIRED_COLUMNS",
        "kind": 5,
        "importPath": "data.samples.sample_loader",
        "description": "data.samples.sample_loader",
        "peekOfCode": "_REQUIRED_COLUMNS = [\"open\", \"high\", \"low\", \"close\", \"volume\"]\nclass SampleSeries:\n    \"\"\"Lightweight container that behaves like a sequence and a scalar.\"\"\"\n    def __init__(self, values: Iterable[float]) -> None:\n        self._values: List[float] = [float(v) for v in values]\n    def __iter__(self):\n        return iter(self._values)\n    def __len__(self) -> int:\n        return len(self._values)\n    def __getitem__(self, item):",
        "detail": "data.samples.sample_loader",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "data.samples.sample_loader",
        "description": "data.samples.sample_loader",
        "peekOfCode": "__all__ = [\n    \"load_sample_data\",\n    \"get_latest_price\",\n    \"get_sample_market_data\",\n    \"get_available_symbols\",\n    \"validate_sample_data\",\n]",
        "detail": "data.samples.sample_loader",
        "documentation": {}
    },
    {
        "label": "HistoricalDataFetcher",
        "kind": 6,
        "importPath": "data.fetchers",
        "description": "data.fetchers",
        "peekOfCode": "class HistoricalDataFetcher:\n    \"\"\"\n    Fetches historical market data with intelligent caching.\n    Features:\n    - Automatic data caching to avoid redundant API calls\n    - Gap detection and filling\n    - Data validation and cleaning\n    - Multiple timeframe support\n    \"\"\"\n    def __init__(self, client: BinanceClient, cache_dir: str = \"data/cache\"):",
        "detail": "data.fetchers",
        "documentation": {}
    },
    {
        "label": "LiveDataFetcher",
        "kind": 6,
        "importPath": "data.fetchers",
        "description": "data.fetchers",
        "peekOfCode": "class LiveDataFetcher:\n    \"\"\"\n    Fetches live market data and maintains real-time feeds.\n    Features:\n    - Real-time price updates\n    - Order book snapshots\n    - Recent trades data\n    - WebSocket integration\n    \"\"\"\n    def __init__(self, client: BinanceClient):",
        "detail": "data.fetchers",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "data.fetchers",
        "description": "data.fetchers",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass HistoricalDataFetcher:\n    \"\"\"\n    Fetches historical market data with intelligent caching.\n    Features:\n    - Automatic data caching to avoid redundant API calls\n    - Gap detection and filling\n    - Data validation and cleaning\n    - Multiple timeframe support\n    \"\"\"",
        "detail": "data.fetchers",
        "documentation": {}
    },
    {
        "label": "TechnicalIndicators",
        "kind": 6,
        "importPath": "data.indicators",
        "description": "data.indicators",
        "peekOfCode": "class TechnicalIndicators:\n    \"\"\"\n    Collection of technical analysis indicators.\n    All methods are static for easy use without instantiation.\n    Calculations are optimized with numba where possible.\n    \"\"\"\n    @staticmethod\n    def sma(data: pd.Series, period: int) -> pd.Series:\n        \"\"\"Simple Moving Average.\"\"\"\n        return data.rolling(window=period).mean()",
        "detail": "data.indicators",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "data.indicators",
        "description": "data.indicators",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass TechnicalIndicators:\n    \"\"\"\n    Collection of technical analysis indicators.\n    All methods are static for easy use without instantiation.\n    Calculations are optimized with numba where possible.\n    \"\"\"\n    @staticmethod\n    def sma(data: pd.Series, period: int) -> pd.Series:\n        \"\"\"Simple Moving Average.\"\"\"",
        "detail": "data.indicators",
        "documentation": {}
    },
    {
        "label": "FeatureEngineer",
        "kind": 6,
        "importPath": "data.preprocessing",
        "description": "data.preprocessing",
        "peekOfCode": "class FeatureEngineer:\n    \"\"\"\n    Feature engineering for trading data.\n    Creates features for machine learning models including:\n    - Technical indicators\n    - Price patterns\n    - Volume features\n    - Time-based features\n    - Market microstructure features\n    \"\"\"",
        "detail": "data.preprocessing",
        "documentation": {}
    },
    {
        "label": "StandardScaler",
        "kind": 5,
        "importPath": "data.preprocessing",
        "description": "data.preprocessing",
        "peekOfCode": "StandardScaler = sklearn_components['StandardScaler']\nMinMaxScaler = sklearn_components['MinMaxScaler']\nRobustScaler = sklearn_components['RobustScaler']\nSelectKBest = sklearn_components['SelectKBest']\nf_regression = sklearn_components['f_regression']\nimport warnings  # noqa: E402\nwarnings.filterwarnings('ignore')\nfrom .indicators import TechnicalIndicators  # noqa: E402\nlogger = logging.getLogger(__name__)\nclass FeatureEngineer:",
        "detail": "data.preprocessing",
        "documentation": {}
    },
    {
        "label": "MinMaxScaler",
        "kind": 5,
        "importPath": "data.preprocessing",
        "description": "data.preprocessing",
        "peekOfCode": "MinMaxScaler = sklearn_components['MinMaxScaler']\nRobustScaler = sklearn_components['RobustScaler']\nSelectKBest = sklearn_components['SelectKBest']\nf_regression = sklearn_components['f_regression']\nimport warnings  # noqa: E402\nwarnings.filterwarnings('ignore')\nfrom .indicators import TechnicalIndicators  # noqa: E402\nlogger = logging.getLogger(__name__)\nclass FeatureEngineer:\n    \"\"\"",
        "detail": "data.preprocessing",
        "documentation": {}
    },
    {
        "label": "RobustScaler",
        "kind": 5,
        "importPath": "data.preprocessing",
        "description": "data.preprocessing",
        "peekOfCode": "RobustScaler = sklearn_components['RobustScaler']\nSelectKBest = sklearn_components['SelectKBest']\nf_regression = sklearn_components['f_regression']\nimport warnings  # noqa: E402\nwarnings.filterwarnings('ignore')\nfrom .indicators import TechnicalIndicators  # noqa: E402\nlogger = logging.getLogger(__name__)\nclass FeatureEngineer:\n    \"\"\"\n    Feature engineering for trading data.",
        "detail": "data.preprocessing",
        "documentation": {}
    },
    {
        "label": "SelectKBest",
        "kind": 5,
        "importPath": "data.preprocessing",
        "description": "data.preprocessing",
        "peekOfCode": "SelectKBest = sklearn_components['SelectKBest']\nf_regression = sklearn_components['f_regression']\nimport warnings  # noqa: E402\nwarnings.filterwarnings('ignore')\nfrom .indicators import TechnicalIndicators  # noqa: E402\nlogger = logging.getLogger(__name__)\nclass FeatureEngineer:\n    \"\"\"\n    Feature engineering for trading data.\n    Creates features for machine learning models including:",
        "detail": "data.preprocessing",
        "documentation": {}
    },
    {
        "label": "f_regression",
        "kind": 5,
        "importPath": "data.preprocessing",
        "description": "data.preprocessing",
        "peekOfCode": "f_regression = sklearn_components['f_regression']\nimport warnings  # noqa: E402\nwarnings.filterwarnings('ignore')\nfrom .indicators import TechnicalIndicators  # noqa: E402\nlogger = logging.getLogger(__name__)\nclass FeatureEngineer:\n    \"\"\"\n    Feature engineering for trading data.\n    Creates features for machine learning models including:\n    - Technical indicators",
        "detail": "data.preprocessing",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "data.preprocessing",
        "description": "data.preprocessing",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass FeatureEngineer:\n    \"\"\"\n    Feature engineering for trading data.\n    Creates features for machine learning models including:\n    - Technical indicators\n    - Price patterns\n    - Volume features\n    - Time-based features\n    - Market microstructure features",
        "detail": "data.preprocessing",
        "documentation": {}
    },
    {
        "label": "SimulatedMarketData",
        "kind": 6,
        "importPath": "data.simulator",
        "description": "data.simulator",
        "peekOfCode": "class SimulatedMarketData:\n    \"\"\"Container that mimics the structure of real market data.\"\"\"\n    symbol: str\n    interval: str\n    timestamp: List[datetime]\n    open: List[Decimal]\n    high: List[Decimal]\n    low: List[Decimal]\n    close: List[Decimal]\n    volume: List[Decimal]",
        "detail": "data.simulator",
        "documentation": {}
    },
    {
        "label": "MarketSimulator",
        "kind": 6,
        "importPath": "data.simulator",
        "description": "data.simulator",
        "peekOfCode": "class MarketSimulator:\n    \"\"\"Generate deterministic synthetic market data for tests.\"\"\"\n    _BASE_PRICES: Dict[str, Decimal] = {\n        \"BTCUSDT\": Decimal(\"97000\"),\n        \"ETHUSDT\": Decimal(\"3500\"),\n        \"SOLUSDT\": Decimal(\"180\"),\n        \"ADAUSDT\": Decimal(\"0.45\"),\n    }\n    def __init__(self, config: Optional[Config] = None, seed: Optional[int] = None) -> None:\n        self.config = config or Config()",
        "detail": "data.simulator",
        "documentation": {}
    },
    {
        "label": "getcontext().prec",
        "kind": 5,
        "importPath": "data.simulator",
        "description": "data.simulator",
        "peekOfCode": "getcontext().prec = 18\n@dataclass\nclass SimulatedMarketData:\n    \"\"\"Container that mimics the structure of real market data.\"\"\"\n    symbol: str\n    interval: str\n    timestamp: List[datetime]\n    open: List[Decimal]\n    high: List[Decimal]\n    low: List[Decimal]",
        "detail": "data.simulator",
        "documentation": {}
    },
    {
        "label": "demo_basic_processing",
        "kind": 2,
        "importPath": "examples.large_dataset_demo",
        "description": "examples.large_dataset_demo",
        "peekOfCode": "def demo_basic_processing():\n    \"\"\"Basic large dataset processing demonstration.\"\"\"\n    logger.info(\"=== Basic Large Dataset Processing Demo ===\")\n    # Initialize processor\n    processor = create_processor(\n        cache_dir=\"data/cache\",\n        memory_limit_mb=1024  # 1GB limit\n    )\n    # Example file path (user would replace with their actual file)\n    klines_file = \"klines_v14_0.csv\"  # 7GB file mentioned by user",
        "detail": "examples.large_dataset_demo",
        "documentation": {}
    },
    {
        "label": "demo_feature_preparation",
        "kind": 2,
        "importPath": "examples.large_dataset_demo",
        "description": "examples.large_dataset_demo",
        "peekOfCode": "def demo_feature_preparation():\n    \"\"\"Feature preparation for ML demonstration.\"\"\"\n    logger.info(\"=== Feature Preparation Demo ===\")\n    processor = create_processor()\n    # Use sample data if available\n    sample_files = [\n        \"data/samples/BTCUSDT_1m_sample.csv\",\n        \"data/samples/large_dataset_sample.csv\"\n    ]\n    sample_file = None",
        "detail": "examples.large_dataset_demo",
        "documentation": {}
    },
    {
        "label": "demo_ml_data_manager",
        "kind": 2,
        "importPath": "examples.large_dataset_demo",
        "description": "examples.large_dataset_demo",
        "peekOfCode": "def demo_ml_data_manager():\n    \"\"\"ML Data Manager demonstration.\"\"\"\n    logger.info(\"=== ML Data Manager Demo ===\")\n    # Initialize ML data manager\n    ml_manager = create_ml_manager(\n        cache_dir=\"data/ml_cache\",\n        memory_limit_gb=1.0\n    )\n    # Training configuration\n    config = TrainingConfig(",
        "detail": "examples.large_dataset_demo",
        "documentation": {}
    },
    {
        "label": "demo_memory_optimization",
        "kind": 2,
        "importPath": "examples.large_dataset_demo",
        "description": "examples.large_dataset_demo",
        "peekOfCode": "def demo_memory_optimization():\n    \"\"\"Memory optimization demonstration.\"\"\"\n    logger.info(\"=== Memory Optimization Demo ===\")\n    create_processor(memory_limit_mb=512)  # 512MB limit\n    logger.info(\"Memory optimization features:\")\n    logger.info(\"1. Chunked processing - processes large files in small chunks\")\n    logger.info(\"2. Memory monitoring - tracks RAM usage during processing\")\n    logger.info(\"3. Cache management - intelligent caching of processed data\")\n    logger.info(\"4. Sample generation - creates manageable subsets for testing\")\n    # Demo memory monitoring (optional - requires psutil)",
        "detail": "examples.large_dataset_demo",
        "documentation": {}
    },
    {
        "label": "demo_production_workflow",
        "kind": 2,
        "importPath": "examples.large_dataset_demo",
        "description": "examples.large_dataset_demo",
        "peekOfCode": "def demo_production_workflow():\n    \"\"\"Production workflow demonstration.\"\"\"\n    logger.info(\"=== Production Workflow Demo ===\")\n    logger.info(\"Recommended workflow for 7GB klines file:\")\n    logger.info(\"\")\n    steps = [\n        \"1. Initial Analysis\",\n        \"   - Use get_dataset_info() to understand file structure\",\n        \"   - Check available memory and set limits appropriately\",\n        \"\",",
        "detail": "examples.large_dataset_demo",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "examples.large_dataset_demo",
        "description": "examples.large_dataset_demo",
        "peekOfCode": "def main():\n    \"\"\"Run all demonstrations.\"\"\"\n    logger.info(\"Large Dataset Processing Demonstration\")\n    logger.info(\"=\" * 50)\n    try:\n        demo_basic_processing()\n        print(\"\\n\" + \"=\"*50 + \"\\n\")\n        demo_feature_preparation()\n        print(\"\\n\" + \"=\"*50 + \"\\n\")\n        demo_ml_data_manager()",
        "detail": "examples.large_dataset_demo",
        "documentation": {}
    },
    {
        "label": "project_root",
        "kind": 5,
        "importPath": "examples.large_dataset_demo",
        "description": "examples.large_dataset_demo",
        "peekOfCode": "project_root = Path(__file__).parent.parent\nsys.path.insert(0, str(project_root))\n# ruff: noqa: E402\nfrom data.large_datasets.klines_processor import create_processor\nfrom data.large_datasets.ml_data_manager import TrainingConfig, create_ml_manager\n# Setup logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'\n)",
        "detail": "examples.large_dataset_demo",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "examples.large_dataset_demo",
        "description": "examples.large_dataset_demo",
        "peekOfCode": "logger = logging.getLogger(__name__)\ndef demo_basic_processing():\n    \"\"\"Basic large dataset processing demonstration.\"\"\"\n    logger.info(\"=== Basic Large Dataset Processing Demo ===\")\n    # Initialize processor\n    processor = create_processor(\n        cache_dir=\"data/cache\",\n        memory_limit_mb=1024  # 1GB limit\n    )\n    # Example file path (user would replace with their actual file)",
        "detail": "examples.large_dataset_demo",
        "documentation": {}
    },
    {
        "label": "get_client",
        "kind": 2,
        "importPath": "exchange.binance_client",
        "description": "exchange.binance_client",
        "peekOfCode": "def get_client() -> \"Client\":\n    global _client\n    cfg = get_config()\n    if _client is not None:\n        return _client\n    if Client is None:\n        raise RuntimeError(\"python-binance is required for live/paper modes\")\n    key, sec = cfg.BINANCE_API_KEY, cfg.BINANCE_API_SECRET\n    testnet = bool(cfg.TESTNET)\n    cli = Client(api_key=key, api_secret=sec, testnet=testnet)",
        "detail": "exchange.binance_client",
        "documentation": {}
    },
    {
        "label": "safe_call",
        "kind": 2,
        "importPath": "exchange.binance_client",
        "description": "exchange.binance_client",
        "peekOfCode": "def safe_call(fn, *args, **kwargs):\n    \"\"\"\n    Unified wrapper around Binance client calls with:\n    - hard fail on auth/permission errors (-2015/-2014 or HTTP 401/403)\n    - soft retry on timestamp desync (-1021) after syncing time/sleeping\n    - soft retry by recreating client once on transport errors\n    \"\"\"\n    cfg = get_config()\n    try:\n        return fn(*args, **kwargs)",
        "detail": "exchange.binance_client",
        "documentation": {}
    },
    {
        "label": "new_order_safe",
        "kind": 2,
        "importPath": "exchange.binance_client",
        "description": "exchange.binance_client",
        "peekOfCode": "def new_order_safe(**params):\n    \"\"\"\n    Try via SDK first, then fallback to REST signing if SDK transport/signature glitches.\n    \"\"\"\n    cli = get_client()\n    try:\n        return safe_call(cli.futures_create_order, **{k: v for k, v in params.items() if v is not None})\n    except Exception as e:\n        msg = str(e)\n        if (\"_http\" in msg) or (\"send_request\" in msg) or (\"Signature\" in msg) or (\"timestamp\" in msg):",
        "detail": "exchange.binance_client",
        "documentation": {}
    },
    {
        "label": "get_open_orders_safe",
        "kind": 2,
        "importPath": "exchange.binance_client",
        "description": "exchange.binance_client",
        "peekOfCode": "def get_open_orders_safe(symbol: Optional[str] = None):\n    cli = get_client()\n    try:\n        if symbol:\n            return safe_call(cli.futures_get_open_orders, symbol=symbol.upper())\n        return safe_call(cli.futures_get_open_orders)\n    except TypeError:\n        # old signatures\n        if symbol:\n            return safe_call(cli.futures_get_open_orders, symbol.upper())",
        "detail": "exchange.binance_client",
        "documentation": {}
    },
    {
        "label": "cancel_order_safe",
        "kind": 2,
        "importPath": "exchange.binance_client",
        "description": "exchange.binance_client",
        "peekOfCode": "def cancel_order_safe(symbol: str, orderId: Optional[int] = None, origClientOrderId: Optional[str] = None):\n    cli = get_client()\n    try:\n        params = {\"symbol\": symbol.upper(), \"orderId\": orderId, \"origClientOrderId\": origClientOrderId}\n        return safe_call(cli.futures_cancel_order, **{k:v for k,v in params.items() if v is not None})\n    except Exception:\n        return _rest_call(\"DELETE\", \"/fapi/v1/order\", {\"symbol\": symbol.upper(), \"orderId\": orderId, \"origClientOrderId\": origClientOrderId})\ndef account_info_safe() -> Dict[str,Any]:\n    cli = get_client()\n    try:",
        "detail": "exchange.binance_client",
        "documentation": {}
    },
    {
        "label": "account_info_safe",
        "kind": 2,
        "importPath": "exchange.binance_client",
        "description": "exchange.binance_client",
        "peekOfCode": "def account_info_safe() -> Dict[str,Any]:\n    cli = get_client()\n    try:\n        return safe_call(cli.futures_account)\n    except Exception:\n        return _rest_call(\"GET\", \"/fapi/v2/account\", {})",
        "detail": "exchange.binance_client",
        "documentation": {}
    },
    {
        "label": "BinanceClient",
        "kind": 6,
        "importPath": "exchange.client",
        "description": "exchange.client",
        "peekOfCode": "class BinanceClient:\n    \"\"\"\n    Wrapper over python-binance REST for UM Futures with resilient behaviour.\n    Safe in LIVE and PAPER modes.\n    When DRY_RUN=true or no API keys, place_order() simulates ack/fill for MARKET.\n    \"\"\"\n    def __init__(self, *args, **kwargs) -> None:\n        cfg = get_config()\n        self.cfg = cfg\n        self.session = requests.Session()",
        "detail": "exchange.client",
        "documentation": {}
    },
    {
        "label": "BinanceMarketDataClient",
        "kind": 6,
        "importPath": "exchange.client",
        "description": "exchange.client",
        "peekOfCode": "class BinanceMarketDataClient:\n    \"\"\"Market-data facade with offline simulator fallback.\"\"\"\n    def __init__(self, config=None, underlying: Optional[BinanceClient] = None) -> None:\n        self._cfg = config or get_config()\n        self._api = underlying or BinanceClient(testnet=self._cfg.testnet)\n        self.simulator: Optional[MarketSimulator] = None\n        self._use_simulator: bool = False\n    def initialize(self) -> None:\n        symbol = getattr(self._cfg, \"symbol\", \"BTCUSDT\")\n        try:",
        "detail": "exchange.client",
        "documentation": {}
    },
    {
        "label": "MockBinanceClient",
        "kind": 6,
        "importPath": "exchange.client",
        "description": "exchange.client",
        "peekOfCode": "class MockBinanceClient(BinanceClient):\n    \"\"\"Mock client that behaves like dry-run regardless of keys; useful for paper tests.\"\"\"\n    def __init__(self, *args, **kwargs):\n        starting_balance = kwargs.pop(\"starting_balance\", None)\n        args_list = list(args)\n        if args_list:\n            starting_balance = args_list.pop(0) if starting_balance is None else starting_balance\n        super().__init__(*args_list, **kwargs)\n        self.dry_run = True\n        self.api_key = \"\"",
        "detail": "exchange.client",
        "documentation": {}
    },
    {
        "label": "create_client",
        "kind": 2,
        "importPath": "exchange.client",
        "description": "exchange.client",
        "peekOfCode": "def create_client(config=None) -> BinanceClient:\n    \"\"\"Factory used by legacy code paths.\"\"\"\n    if config is None:\n        config = get_config()\n    return BinanceClient(testnet=config.testnet)",
        "detail": "exchange.client",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "exchange.client",
        "description": "exchange.client",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# --- Optional SDK import (will work even if missing) ---\ntry:\n    from binance.client import Client as _BinanceClient\n    from binance.exceptions import BinanceAPIException\n    _SDK = \"binance\"\nexcept Exception:  # pragma: no cover\n    _BinanceClient = None\n    class BinanceAPIException(Exception):  # minimal shim\n        def __init__(self, status_code=None, message=\"\", code=None):",
        "detail": "exchange.client",
        "documentation": {}
    },
    {
        "label": "IntegratedBinanceClient",
        "kind": 5,
        "importPath": "exchange.client",
        "description": "exchange.client",
        "peekOfCode": "IntegratedBinanceClient = BinanceClient\ndef create_client(config=None) -> BinanceClient:\n    \"\"\"Factory used by legacy code paths.\"\"\"\n    if config is None:\n        config = get_config()\n    return BinanceClient(testnet=config.testnet)",
        "detail": "exchange.client",
        "documentation": {}
    },
    {
        "label": "ensure_sl_on_exchange",
        "kind": 2,
        "importPath": "exchange.exits",
        "description": "exchange.exits",
        "peekOfCode": "def ensure_sl_on_exchange(symbol: str, pos_sign_or_side, stop_price: float) -> None:\n    cfg = get_config()\n    cli = BinanceClient(testnet=cfg.testnet)\n    om = OrderManager(cli)\n    # Normalize sign to OrderSide for closePosition SL\n    sign = _pos_sign(pos_sign_or_side)\n    side = OrderSide.SELL if sign > 0 else OrderSide.BUY\n    # Use internal stop loss setup (closePosition)\n    om._setup_stop_loss(symbol, side, float(stop_price))\ndef ensure_tp_on_exchange(symbol: str, pos_sign_or_side, qty: float, entry: float, tps: List[float], tp_shares: List[float]) -> None:",
        "detail": "exchange.exits",
        "documentation": {}
    },
    {
        "label": "ensure_tp_on_exchange",
        "kind": 2,
        "importPath": "exchange.exits",
        "description": "exchange.exits",
        "peekOfCode": "def ensure_tp_on_exchange(symbol: str, pos_sign_or_side, qty: float, entry: float, tps: List[float], tp_shares: List[float]) -> None:\n    cfg = get_config()\n    cli = BinanceClient(testnet=cfg.testnet)\n    om = OrderManager(cli)\n    sign = _pos_sign(pos_sign_or_side)\n    side = OrderSide.SELL if sign > 0 else OrderSide.BUY\n    # Build pseudo-position to reuse OrderManager logic\n    pos = Position(symbol=symbol, size=(abs(float(qty)) if sign > 0 else -abs(float(qty))), entry_price=float(entry))\n    # Quantities per TP share\n    shares = tp_shares or cfg.tp_shares()",
        "detail": "exchange.exits",
        "documentation": {}
    },
    {
        "label": "ensure_exits_on_exchange",
        "kind": 2,
        "importPath": "exchange.exits",
        "description": "exchange.exits",
        "peekOfCode": "def ensure_exits_on_exchange(symbol: str, pos_sign_or_side, qty: float, sl: float, tps: List[float], tp_shares: List[float]) -> None:\n    cfg = get_config()\n    cli = BinanceClient(testnet=cfg.testnet)\n    om = OrderManager(cli)\n    sign = _pos_sign(pos_sign_or_side)\n    pos = Position(symbol=symbol, size=(abs(float(qty)) if sign > 0 else -abs(float(qty))), entry_price=0.0)\n    om.setup_exit_orders(symbol, pos, float(sl), [float(x) for x in tps], tp_shares or cfg.tp_shares())\ndef _pos_sign(s) -> int:\n    if isinstance(s, (int, float)):\n        v = int(s)",
        "detail": "exchange.exits",
        "documentation": {}
    },
    {
        "label": "ensure_exits_on_exchange",
        "kind": 2,
        "importPath": "exchange.exits_addon",
        "description": "exchange.exits_addon",
        "peekOfCode": "def ensure_exits_on_exchange(symbol: str, side: str, qty: float, entry: float, stop: float) -> Dict[str, Any]:\n    \"\"\"\n    Контракт функции сохранён. В Live можно заменить реализацией,\n    если у вас есть готовая логика выставления SL/TP на бирже.\n    Сейчас — no-op: не падаем на импорте и ничего не ломаем.\n    \"\"\"\n    return {\"status\": \"SKIP\", \"reason\": \"exits_addon shim active\", \"placed\": False}",
        "detail": "exchange.exits_addon",
        "documentation": {}
    },
    {
        "label": "_ClientAdapter",
        "kind": 6,
        "importPath": "exchange.market_data",
        "description": "exchange.market_data",
        "peekOfCode": "class _ClientAdapter:\n    \"\"\"\n    Optional adapter over exchange.client.BinanceClient.\n    Only the methods we use are referenced; calls are guarded.\n    \"\"\"\n    client: Any\n    async def ticker_price(self, symbol: str) -> Optional[float]:\n        try:\n            fn = getattr(self.client, \"ticker_price\", None) or getattr(self.client, \"get_symbol_price\", None)\n            if not fn:",
        "detail": "exchange.market_data",
        "documentation": {}
    },
    {
        "label": "MarketDataProvider",
        "kind": 6,
        "importPath": "exchange.market_data",
        "description": "exchange.market_data",
        "peekOfCode": "class MarketDataProvider:\n    def __init__(self, client: Optional[Any] = None):\n        self.adapter = _ClientAdapter(client) if client is not None else None\n    async def get_ticker(self, symbol: str) -> Dict[str, Any]:\n        sym = str(symbol).upper()\n        # Try client first\n        if self.adapter:\n            price = await self.adapter.ticker_price(sym)\n            if price is not None:\n                return {\"symbol\": sym, \"price\": float(price)}",
        "detail": "exchange.market_data",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "exchange.market_data",
        "description": "exchange.market_data",
        "peekOfCode": "log = logging.getLogger(__name__)\nBINANCE_FAPI_URL = \"https://fapi.binance.com\"\ndef _http_get_json(path: str, params: Dict[str, Any]) -> Any:\n    qs = urlencode(params)\n    url = f\"{BINANCE_FAPI_URL}{path}?{qs}\"\n    req = Request(url, headers={\"User-Agent\": \"mdp/1.0\"})\n    with urlopen(req, timeout=7) as resp:\n        raw = resp.read().decode(\"utf-8\", \"replace\")\n    return json.loads(raw)\ndef _to_float(x: Any) -> Optional[float]:",
        "detail": "exchange.market_data",
        "documentation": {}
    },
    {
        "label": "BINANCE_FAPI_URL",
        "kind": 5,
        "importPath": "exchange.market_data",
        "description": "exchange.market_data",
        "peekOfCode": "BINANCE_FAPI_URL = \"https://fapi.binance.com\"\ndef _http_get_json(path: str, params: Dict[str, Any]) -> Any:\n    qs = urlencode(params)\n    url = f\"{BINANCE_FAPI_URL}{path}?{qs}\"\n    req = Request(url, headers={\"User-Agent\": \"mdp/1.0\"})\n    with urlopen(req, timeout=7) as resp:\n        raw = resp.read().decode(\"utf-8\", \"replace\")\n    return json.loads(raw)\ndef _to_float(x: Any) -> Optional[float]:\n    try:",
        "detail": "exchange.market_data",
        "documentation": {}
    },
    {
        "label": "OrderManager",
        "kind": 6,
        "importPath": "exchange.mock_client_paych",
        "description": "exchange.mock_client_paych",
        "peekOfCode": "class OrderManager:\n    \"\"\"\n    Unified order manager with safety checks and retry logic.\n    Features:\n    - Price and quantity rounding\n    - Order validation\n    - Automatic retries\n    - Position-aware order placement\n    - Exit order management (SL/TP)\n    \"\"\"",
        "detail": "exchange.mock_client_paych",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "exchange.mock_client_paych",
        "description": "exchange.mock_client_paych",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass OrderManager:\n    \"\"\"\n    Unified order manager with safety checks and retry logic.\n    Features:\n    - Price and quantity rounding\n    - Order validation\n    - Automatic retries\n    - Position-aware order placement\n    - Exit order management (SL/TP)",
        "detail": "exchange.mock_client_paych",
        "documentation": {}
    },
    {
        "label": "OrderManager",
        "kind": 6,
        "importPath": "exchange.orders",
        "description": "exchange.orders",
        "peekOfCode": "class OrderManager:\n    \"\"\"\n    Unified order manager with safety checks and retry logic.\n    Additions in this revision:\n    - Accepts Enum or str for all categorical args\n    - PERCENT_PRICE clamp for LIMITs\n    - Anti-2021 immediate-trigger protection for SL\n    \"\"\"\n    def __init__(self, client: BinanceClient):\n        self.client = client",
        "detail": "exchange.orders",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "exchange.orders",
        "description": "exchange.orders",
        "peekOfCode": "logger = logging.getLogger(__name__)\nSideLike        = Union[OrderSide, str]\nTypeLike        = Union[OrderType, str]\nTimeInForceLike = Union[TimeInForce, str]\nWorkingTypeLike = Union[WorkingType, str]\n# --------------------- helpers: Enum/str normalization --------------------- #\ndef _as_side(side: SideLike) -> str:\n    if isinstance(side, OrderSide):\n        return side\n    s = str(side).upper()",
        "detail": "exchange.orders",
        "documentation": {}
    },
    {
        "label": "TimeInForceLike",
        "kind": 5,
        "importPath": "exchange.orders",
        "description": "exchange.orders",
        "peekOfCode": "TimeInForceLike = Union[TimeInForce, str]\nWorkingTypeLike = Union[WorkingType, str]\n# --------------------- helpers: Enum/str normalization --------------------- #\ndef _as_side(side: SideLike) -> str:\n    if isinstance(side, OrderSide):\n        return side\n    s = str(side).upper()\n    if s in (\"BUY\", \"SELL\"):\n        return s\n    # tolerant aliases",
        "detail": "exchange.orders",
        "documentation": {}
    },
    {
        "label": "WorkingTypeLike",
        "kind": 5,
        "importPath": "exchange.orders",
        "description": "exchange.orders",
        "peekOfCode": "WorkingTypeLike = Union[WorkingType, str]\n# --------------------- helpers: Enum/str normalization --------------------- #\ndef _as_side(side: SideLike) -> str:\n    if isinstance(side, OrderSide):\n        return side\n    s = str(side).upper()\n    if s in (\"BUY\", \"SELL\"):\n        return s\n    # tolerant aliases\n    if s in (\"LONG\", \"+\", \"B\", \"OPEN_LONG\"):  return \"BUY\"",
        "detail": "exchange.orders",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "exchange.orders_cooldown_addon",
        "description": "exchange.orders_cooldown_addon",
        "peekOfCode": "log = logging.getLogger(\"orders_addon\")\ntry:\n    from exchange.orders import OrderManager\nexcept Exception as e:\n    print(\"orders_addon: cannot import OrderManager:\", e)\n    OrderManager = None\nif OrderManager is not None:\n    # class-level store (simple & cross-instances)\n    if not hasattr(OrderManager, \"_cooldowns\"):\n        OrderManager._cooldowns = {}",
        "detail": "exchange.orders_cooldown_addon",
        "documentation": {}
    },
    {
        "label": "_AwaitableResult",
        "kind": 6,
        "importPath": "exchange.positions",
        "description": "exchange.positions",
        "peekOfCode": "class _AwaitableResult:\n    \"\"\"Container that works in both sync and async contexts.\"\"\"\n    def __init__(self, value):\n        self._value = value\n    def __await__(self):\n        yield\n        return self._value\n    def __getattr__(self, item):\n        return getattr(self._value, item)\n    def __iter__(self):  # pragma: no cover - rarely used",
        "detail": "exchange.positions",
        "documentation": {}
    },
    {
        "label": "ManagedPosition",
        "kind": 6,
        "importPath": "exchange.positions",
        "description": "exchange.positions",
        "peekOfCode": "class ManagedPosition:\n    symbol: str\n    side: PositionSide\n    size: Decimal\n    entry_price: Decimal\n    current_price: Decimal\n    realized_pnl: Decimal = Decimal(\"0\")\n    opened_at: datetime = datetime.utcnow()\n    @property\n    def notional(self) -> Decimal:",
        "detail": "exchange.positions",
        "documentation": {}
    },
    {
        "label": "PositionManager",
        "kind": 6,
        "importPath": "exchange.positions",
        "description": "exchange.positions",
        "peekOfCode": "class PositionManager:\n    \"\"\"Stateful manager for paper-trading style position tracking.\"\"\"\n    def __init__(self, source: Optional[object] = None):\n        if isinstance(source, BinanceClient):\n            self.client = source\n            self.config = get_config()\n        else:\n            self.config = source if isinstance(source, Config) else get_config()\n            starting_balance = getattr(self.config, \"starting_balance\", 10000.0)\n            self.client = MockBinanceClient(starting_balance=starting_balance)",
        "detail": "exchange.positions",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "exchange.positions",
        "description": "exchange.positions",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass _AwaitableResult:\n    \"\"\"Container that works in both sync and async contexts.\"\"\"\n    def __init__(self, value):\n        self._value = value\n    def __await__(self):\n        yield\n        return self._value\n    def __getattr__(self, item):\n        return getattr(self._value, item)",
        "detail": "exchange.positions",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "exchange.positions",
        "description": "exchange.positions",
        "peekOfCode": "__all__ = [\"PositionManager\", \"ManagedPosition\"]",
        "detail": "exchange.positions",
        "documentation": {}
    },
    {
        "label": "get_filters",
        "kind": 2,
        "importPath": "exchange.precision",
        "description": "exchange.precision",
        "peekOfCode": "def get_filters(symbol: str) -> Tuple[float,float,float,dict]:\n    f = _fetch_filters(symbol)\n    return f[\"step\"], f[\"tick\"], f[\"minNotional\"], f[\"pp\"]\ndef adjust_price(symbol: str, price: float) -> float:\n    tick = _fetch_filters(symbol)[\"tick\"]\n    if tick <= 0: return float(price)\n    return math.floor(float(price) / tick) * tick\ndef adjust_qty(symbol: str, qty: float) -> float:\n    step = _fetch_filters(symbol)[\"step\"]\n    if step <= 0: return float(qty)",
        "detail": "exchange.precision",
        "documentation": {}
    },
    {
        "label": "adjust_price",
        "kind": 2,
        "importPath": "exchange.precision",
        "description": "exchange.precision",
        "peekOfCode": "def adjust_price(symbol: str, price: float) -> float:\n    tick = _fetch_filters(symbol)[\"tick\"]\n    if tick <= 0: return float(price)\n    return math.floor(float(price) / tick) * tick\ndef adjust_qty(symbol: str, qty: float) -> float:\n    step = _fetch_filters(symbol)[\"step\"]\n    if step <= 0: return float(qty)\n    q = math.floor(float(qty) / step) * step\n    if q <= 0: q = step\n    return q",
        "detail": "exchange.precision",
        "documentation": {}
    },
    {
        "label": "adjust_qty",
        "kind": 2,
        "importPath": "exchange.precision",
        "description": "exchange.precision",
        "peekOfCode": "def adjust_qty(symbol: str, qty: float) -> float:\n    step = _fetch_filters(symbol)[\"step\"]\n    if step <= 0: return float(qty)\n    q = math.floor(float(qty) / step) * step\n    if q <= 0: q = step\n    return q\ndef clamp_percent_price(symbol: str, price: float) -> float:\n    \"\"\"\n    Clamp price into allowed PERCENT_PRICE band around current mark price to avoid -4131.\n    \"\"\"",
        "detail": "exchange.precision",
        "documentation": {}
    },
    {
        "label": "clamp_percent_price",
        "kind": 2,
        "importPath": "exchange.precision",
        "description": "exchange.precision",
        "peekOfCode": "def clamp_percent_price(symbol: str, price: float) -> float:\n    \"\"\"\n    Clamp price into allowed PERCENT_PRICE band around current mark price to avoid -4131.\n    \"\"\"\n    f = _fetch_filters(symbol)\n    try:\n        mp = float(safe_call(get_client().futures_mark_price, symbol=symbol.upper()).get(\"markPrice\", 0.0))\n        if mp <= 0: mp = float(price)\n    except Exception:\n        mp = float(price)",
        "detail": "exchange.precision",
        "documentation": {}
    },
    {
        "label": "fmt_price",
        "kind": 2,
        "importPath": "exchange.precision",
        "description": "exchange.precision",
        "peekOfCode": "def fmt_price(symbol: str, price: float) -> str:\n    p = adjust_price(symbol, price)\n    tick = _fetch_filters(symbol)[\"tick\"]\n    if tick <= 0: return str(p)\n    dec = max(0, int(round(-math.log10(tick))))\n    return f\"{p:.{dec}f}\"\ndef fmt_qty(symbol: str, qty: float) -> str:\n    q = adjust_qty(symbol, qty)\n    step = _fetch_filters(symbol)[\"step\"]\n    if step <= 0: return str(q)",
        "detail": "exchange.precision",
        "documentation": {}
    },
    {
        "label": "fmt_qty",
        "kind": 2,
        "importPath": "exchange.precision",
        "description": "exchange.precision",
        "peekOfCode": "def fmt_qty(symbol: str, qty: float) -> str:\n    q = adjust_qty(symbol, qty)\n    step = _fetch_filters(symbol)[\"step\"]\n    if step <= 0: return str(q)\n    dec = max(0, int(round(-math.log10(step))))\n    return f\"{q:.{dec}f}\"",
        "detail": "exchange.precision",
        "documentation": {}
    },
    {
        "label": "RealBinanceClient",
        "kind": 6,
        "importPath": "exchange.real_client",
        "description": "exchange.real_client",
        "peekOfCode": "class RealBinanceClient:\n    \"\"\"Real Binance API client for testnet demo trading.\"\"\"\n    def __init__(self, config):\n        \"\"\"Initialize with REAL Binance API connection.\"\"\"\n        self.config = config\n        # Get API credentials\n        api_key = os.getenv('BINANCE_API_KEY')\n        secret_key = os.getenv('BINANCE_SECRET_KEY') \n        testnet = os.getenv('BINANCE_TESTNET', 'true').lower() == 'true'\n        if not api_key or not secret_key:",
        "detail": "exchange.real_client",
        "documentation": {}
    },
    {
        "label": "get_real_api_client",
        "kind": 2,
        "importPath": "exchange.real_client",
        "description": "exchange.real_client",
        "peekOfCode": "def get_real_api_client(config):\n    \"\"\"Get configured real API client.\"\"\"\n    use_real_api = os.getenv('ENABLE_REAL_API', 'true').lower() == 'true'\n    if use_real_api:\n        return RealBinanceClient(config)\n    else:\n        # Fallback to mock if requested\n        from exchange.client import MockBinanceClient\n        return MockBinanceClient(config)",
        "detail": "exchange.real_client",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "exchange.real_client",
        "description": "exchange.real_client",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass RealBinanceClient:\n    \"\"\"Real Binance API client for testnet demo trading.\"\"\"\n    def __init__(self, config):\n        \"\"\"Initialize with REAL Binance API connection.\"\"\"\n        self.config = config\n        # Get API credentials\n        api_key = os.getenv('BINANCE_API_KEY')\n        secret_key = os.getenv('BINANCE_SECRET_KEY') \n        testnet = os.getenv('BINANCE_TESTNET', 'true').lower() == 'true'",
        "detail": "exchange.real_client",
        "documentation": {}
    },
    {
        "label": "BinanceWebSocketClient",
        "kind": 6,
        "importPath": "exchange.websockets",
        "description": "exchange.websockets",
        "peekOfCode": "class BinanceWebSocketClient:\n    \"\"\"\n    WebSocket client for Binance UM Futures.\n    Provides real-time data streams for:\n    - Market data (klines, ticker, depth)\n    - Account updates (orders, positions, balance)\n    - User data stream\n    \"\"\"\n    def __init__(self, config: Config):\n        \"\"\"Initialize WebSocket client.\"\"\"",
        "detail": "exchange.websockets",
        "documentation": {}
    },
    {
        "label": "MockWebSocketClient",
        "kind": 6,
        "importPath": "exchange.websockets",
        "description": "exchange.websockets",
        "peekOfCode": "class MockWebSocketClient(BinanceWebSocketClient):\n    \"\"\"\n    Mock WebSocket client for testing and paper trading.\n    Simulates WebSocket functionality without real connections.\n    \"\"\"\n    def __init__(self, config: Config):\n        \"\"\"Initialize mock WebSocket client.\"\"\"\n        super().__init__(config)\n        self.mock_data: dict[str, Any] = {}\n        logger.info(\"Mock WebSocket client initialized\")",
        "detail": "exchange.websockets",
        "documentation": {}
    },
    {
        "label": "WebSocketManager",
        "kind": 6,
        "importPath": "exchange.websockets",
        "description": "exchange.websockets",
        "peekOfCode": "class WebSocketManager:\n    \"\"\"\n    WebSocket manager for backward compatibility.\n    This is a wrapper around the WebSocket clients that provides\n    a unified interface for managing WebSocket connections.\n    \"\"\"\n    def __init__(self, config: Config):\n        \"\"\"Initialize WebSocket manager.\"\"\"\n        self.config = config\n        self.client = create_websocket_client(config)",
        "detail": "exchange.websockets",
        "documentation": {}
    },
    {
        "label": "create_websocket_client",
        "kind": 2,
        "importPath": "exchange.websockets",
        "description": "exchange.websockets",
        "peekOfCode": "def create_websocket_client(config: Config) -> BinanceWebSocketClient:\n    \"\"\"\n    Create appropriate WebSocket client based on configuration.\n    Returns:\n        BinanceWebSocketClient for live trading\n        MockWebSocketClient for paper trading or testing\n    \"\"\"\n    if config.mode == \"paper\" or config.dry_run:\n        return MockWebSocketClient(config)\n    else:",
        "detail": "exchange.websockets",
        "documentation": {}
    },
    {
        "label": "create_websocket_manager",
        "kind": 2,
        "importPath": "exchange.websockets",
        "description": "exchange.websockets",
        "peekOfCode": "def create_websocket_manager(config: Config) -> WebSocketManager:\n    \"\"\"\n    Create WebSocket manager.\n    This is a convenience function that creates a WebSocketManager instance.\n    Use this for backward compatibility with older code.\n    \"\"\"\n    return WebSocketManager(config)\n# Utility functions for WebSocket message parsing\ndef parse_kline_message(message: dict[str, Any]) -> MarketData | None:\n    \"\"\"Parse kline message to MarketData object.\"\"\"",
        "detail": "exchange.websockets",
        "documentation": {}
    },
    {
        "label": "parse_kline_message",
        "kind": 2,
        "importPath": "exchange.websockets",
        "description": "exchange.websockets",
        "peekOfCode": "def parse_kline_message(message: dict[str, Any]) -> MarketData | None:\n    \"\"\"Parse kline message to MarketData object.\"\"\"\n    try:\n        kline = message.get(\"k\", {})\n        return MarketData(\n            symbol=kline[\"s\"],\n            timestamp=datetime.fromtimestamp(kline[\"t\"] / 1000),\n            open=float(kline[\"o\"]),\n            high=float(kline[\"h\"]),\n            low=float(kline[\"l\"]),",
        "detail": "exchange.websockets",
        "documentation": {}
    },
    {
        "label": "parse_order_update",
        "kind": 2,
        "importPath": "exchange.websockets",
        "description": "exchange.websockets",
        "peekOfCode": "def parse_order_update(message: dict[str, Any]) -> OrderUpdate | None:\n    \"\"\"Parse order update message.\"\"\"\n    try:\n        order = message.get(\"o\", {})\n        return OrderUpdate(\n            symbol=order[\"s\"],\n            order_id=int(order[\"i\"]),\n            client_order_id=order[\"c\"],\n            side=order[\"S\"],\n            order_type=order[\"o\"],",
        "detail": "exchange.websockets",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "exchange.websockets",
        "description": "exchange.websockets",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass BinanceWebSocketClient:\n    \"\"\"\n    WebSocket client for Binance UM Futures.\n    Provides real-time data streams for:\n    - Market data (klines, ticker, depth)\n    - Account updates (orders, positions, balance)\n    - User data stream\n    \"\"\"\n    def __init__(self, config: Config):",
        "detail": "exchange.websockets",
        "documentation": {}
    },
    {
        "label": "TradingSignal",
        "kind": 6,
        "importPath": "fix.fix_all_issues",
        "description": "fix.fix_all_issues",
        "peekOfCode": "class TradingSignal:\n    \"\"\"Trading signal data structure.\"\"\"\n    symbol: str\n    signal_type: SignalType\n    strength: float\n    timestamp: datetime\n    metadata: Dict[str, Any] = None\n    def __post_init__(self):\n        if self.metadata is None:\n            self.metadata = {}",
        "detail": "fix.fix_all_issues",
        "documentation": {}
    },
    {
        "label": "SignalGenerator",
        "kind": 6,
        "importPath": "fix.fix_all_issues",
        "description": "fix.fix_all_issues",
        "peekOfCode": "class SignalGenerator:\n    \"\"\"Generates trading signals based on REAL market data.\"\"\"\n    def __init__(self, config: Config):\n        \"\"\"Initialize signal generator with AGGRESSIVE configuration.\"\"\"\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n        # ULTRA AGGRESSIVE Signal parameters - GUARANTEED to generate signals\n        self.fast_ma_period = 5      # Very fast MA\n        self.slow_ma_period = 10     # Very slow MA  \n        self.min_signal_strength = 0.01  # Only 1% strength needed!",
        "detail": "fix.fix_all_issues",
        "documentation": {}
    },
    {
        "label": "SimpleScalper",
        "kind": 6,
        "importPath": "fix.fix_all_issues",
        "description": "fix.fix_all_issues",
        "peekOfCode": "class SimpleScalper:\n    \"\"\"Minimal scalper for compatibility.\"\"\"\n    def __init__(self, config: Config):\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n    async def initialize(self) -> None:\n        \"\"\"Async initialize for compatibility.\"\"\"\n        self.logger.info(\"SimpleScalper initialized\")\n    def generate_signal(self, market_data) -> Optional[TradingSignal]:\n        \"\"\"Simple scalping signal generation.\"\"\"",
        "detail": "fix.fix_all_issues",
        "documentation": {}
    },
    {
        "label": "create_market_data_compatible_signals",
        "kind": 2,
        "importPath": "fix.fix_all_issues",
        "description": "fix.fix_all_issues",
        "peekOfCode": "def create_market_data_compatible_signals():\n    \"\"\"Create signals.py that properly handles market data and doesn't need await.\"\"\"\n    signals_content = '''\"\"\"\nTrading signal generation - Market Data Compatible Version\nThis version properly handles market data from the trading engine\nand generates signals based on REAL prices, not synthetic ones.\n\"\"\"\nimport logging\nfrom typing import Optional, List, Dict, Any\nfrom datetime import datetime, timezone",
        "detail": "fix.fix_all_issues",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "fix.fix_all_issues",
        "description": "fix.fix_all_issues",
        "peekOfCode": "def main():\n    \"\"\"Main function - fix market data and await issues.\"\"\"\n    print(\"🔧 FIXING MARKET DATA AND AWAIT ISSUES\")\n    print(\"=\" * 60)\n    print(\"Problem 1: object TradingSignal can't be used in 'await' expression\")\n    print(\"Problem 2: Using synthetic prices instead of REAL API data\")  \n    print(\"Problem 3: market_data showing as UNKNOWN instead of symbol\")\n    print(\"Solution: Market data compatible signals.py\")\n    print(\"=\" * 60)\n    create_market_data_compatible_signals()",
        "detail": "fix.fix_all_issues",
        "documentation": {}
    },
    {
        "label": "TradingSignal",
        "kind": 6,
        "importPath": "fix.fix_await_and_market_data",
        "description": "fix.fix_await_and_market_data",
        "peekOfCode": "class TradingSignal:\n    \"\"\"Trading signal data structure.\"\"\"\n    symbol: str\n    signal_type: SignalType\n    strength: float\n    timestamp: datetime\n    metadata: Dict[str, Any] = None\n    def __post_init__(self):\n        if self.metadata is None:\n            self.metadata = {}",
        "detail": "fix.fix_await_and_market_data",
        "documentation": {}
    },
    {
        "label": "SignalGenerator",
        "kind": 6,
        "importPath": "fix.fix_await_and_market_data",
        "description": "fix.fix_await_and_market_data",
        "peekOfCode": "class SignalGenerator:\n    \"\"\"Generates trading signals based on REAL market data.\"\"\"\n    def __init__(self, config: Config):\n        \"\"\"Initialize signal generator with AGGRESSIVE configuration.\"\"\"\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n        # ULTRA AGGRESSIVE Signal parameters - GUARANTEED to generate signals\n        self.fast_ma_period = 5      # Very fast MA\n        self.slow_ma_period = 10     # Very slow MA  \n        self.min_signal_strength = 0.01  # Only 1% strength needed!",
        "detail": "fix.fix_await_and_market_data",
        "documentation": {}
    },
    {
        "label": "SimpleScalper",
        "kind": 6,
        "importPath": "fix.fix_await_and_market_data",
        "description": "fix.fix_await_and_market_data",
        "peekOfCode": "class SimpleScalper:\n    \"\"\"Minimal scalper for compatibility.\"\"\"\n    def __init__(self, config: Config):\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n    async def initialize(self) -> None:\n        \"\"\"Async initialize for compatibility.\"\"\"\n        self.logger.info(\"SimpleScalper initialized\")\n    def generate_signal(self, market_data) -> Optional[TradingSignal]:\n        \"\"\"Simple scalping signal generation.\"\"\"",
        "detail": "fix.fix_await_and_market_data",
        "documentation": {}
    },
    {
        "label": "create_market_data_compatible_signals",
        "kind": 2,
        "importPath": "fix.fix_await_and_market_data",
        "description": "fix.fix_await_and_market_data",
        "peekOfCode": "def create_market_data_compatible_signals():\n    \"\"\"Create signals.py that properly handles market data and doesn't need await.\"\"\"\n    signals_content = '''\"\"\"\nTrading signal generation - Market Data Compatible Version\nThis version properly handles market data from the trading engine\nand generates signals based on REAL prices, not synthetic ones.\n\"\"\"\nimport logging\nfrom typing import Optional, List, Dict, Any\nfrom datetime import datetime, timezone",
        "detail": "fix.fix_await_and_market_data",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "fix.fix_await_and_market_data",
        "description": "fix.fix_await_and_market_data",
        "peekOfCode": "def main():\n    \"\"\"Main function - fix market data and await issues.\"\"\"\n    print(\"🔧 FIXING MARKET DATA AND AWAIT ISSUES\")\n    print(\"=\" * 60)\n    print(\"Problem 1: object TradingSignal can't be used in 'await' expression\")\n    print(\"Problem 2: Using synthetic prices instead of REAL API data\")  \n    print(\"Problem 3: market_data showing as UNKNOWN instead of symbol\")\n    print(\"Solution: Market data compatible signals.py\")\n    print(\"=\" * 60)\n    create_market_data_compatible_signals()",
        "detail": "fix.fix_await_and_market_data",
        "documentation": {}
    },
    {
        "label": "fix_cli_config",
        "kind": 2,
        "importPath": "fix.fix_cli_config",
        "description": "fix.fix_cli_config",
        "peekOfCode": "def fix_cli_config():\n    \"\"\"Fix CLI to support config file loading.\"\"\"\n    # Read current CLI file\n    if not os.path.exists('cli_updated.py'):\n        print(\"❌ cli_updated.py not found\")\n        return\n    with open('cli_updated.py', 'r', encoding='utf-8') as f:\n        content = f.read()\n    # Fix the paper command function signature (remove duplicate config parameters)\n    content = content.replace(",
        "detail": "fix.fix_cli_config",
        "documentation": {}
    },
    {
        "label": "test_cli_syntax",
        "kind": 2,
        "importPath": "fix.fix_cli_config",
        "description": "fix.fix_cli_config",
        "peekOfCode": "def test_cli_syntax():\n    \"\"\"Test the fixed CLI syntax.\"\"\"\n    try:\n        import subprocess\n        result = subprocess.run(['python', '-m', 'py_compile', 'cli_updated.py'], \n                              capture_output=True, text=True)\n        if result.returncode == 0:\n            print(\"✅ CLI syntax validation passed\")\n        else:\n            print(\"❌ CLI syntax error:\")",
        "detail": "fix.fix_cli_config",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "fix.fix_cli_config",
        "description": "fix.fix_cli_config",
        "peekOfCode": "def main():\n    \"\"\"Main fix function.\"\"\"\n    print(\"🔧 FIXING CLI CONFIGURATION LOADING\")\n    print(\"=\" * 50)\n    print(\"Problem: Duplicate --config parameters and config_file reference\")\n    print(\"Solution: Fix CLI parameter handling for .env.testnet\")\n    print(\"=\" * 50)\n    fix_cli_config()\n    test_cli_syntax()\n    print(\"\\\\n\" + \"=\" * 50)",
        "detail": "fix.fix_cli_config",
        "documentation": {}
    },
    {
        "label": "fix_cli_completely",
        "kind": 2,
        "importPath": "fix.fix_cli_final",
        "description": "fix.fix_cli_final",
        "peekOfCode": "def fix_cli_completely():\n    \"\"\"Fix CLI completely with proper --config parameter.\"\"\"\n    # Read current CLI\n    with open('cli_updated.py', 'r', encoding='utf-8') as f:\n        content = f.read()\n    # Find and fix the paper function signature\n    paper_start = content.find('@app.command()\\ndef paper(')\n    if paper_start == -1:\n        print(\"❌ Could not find paper function\")\n        return",
        "detail": "fix.fix_cli_final",
        "documentation": {}
    },
    {
        "label": "paper",
        "kind": 2,
        "importPath": "fix.fix_cli_final",
        "description": "fix.fix_cli_final",
        "peekOfCode": "def paper(\n    symbols: list[str] | None = typer.Option(\n        None, \"--symbols\", \"-s\", help=\"Trading symbols\"\n    ),\n    timeframe: str | None = typer.Option(\n        None, \"--timeframe\", \"-t\", help=\"Timeframe\"\n    ),\n    config: str | None = typer.Option(\n        None, \"--config\", \"-c\", help=\"Configuration file path (e.g., .env.testnet)\"\n    ),",
        "detail": "fix.fix_cli_final",
        "documentation": {}
    },
    {
        "label": "test_cli",
        "kind": 2,
        "importPath": "fix.fix_cli_final",
        "description": "fix.fix_cli_final",
        "peekOfCode": "def test_cli():\n    \"\"\"Test CLI functionality.\"\"\"\n    try:\n        # Test syntax\n        import subprocess\n        result = subprocess.run(['python', '-m', 'py_compile', 'cli_updated.py'], \n                              capture_output=True, text=True)\n        if result.returncode == 0:\n            print(\"✅ CLI syntax validation passed\")\n        else:",
        "detail": "fix.fix_cli_final",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "fix.fix_cli_final",
        "description": "fix.fix_cli_final",
        "peekOfCode": "def main():\n    \"\"\"Main fix function.\"\"\"\n    print(\"🔧 FINAL CLI FIX - RESTORE --CONFIG PARAMETER\")\n    print(\"=\" * 60)\n    print(\"Problem: --config parameter was accidentally removed completely\")\n    print(\"Solution: Restore proper function signature with --config\")\n    print(\"=\" * 60)\n    fix_cli_completely()\n    if test_cli():\n        print(\"\\\\n\" + \"=\" * 60)",
        "detail": "fix.fix_cli_final",
        "documentation": {}
    },
    {
        "label": "TradingSignal",
        "kind": 6,
        "importPath": "fix.fix_final_issues",
        "description": "fix.fix_final_issues",
        "peekOfCode": "class TradingSignal:\n    \"\"\"Trading signal data structure.\"\"\"\n    symbol: str\n    signal_type: SignalType\n    strength: float\n    timestamp: datetime\n    metadata: Dict[str, Any] = None\n    def __post_init__(self):\n        if self.metadata is None:\n            self.metadata = {}",
        "detail": "fix.fix_final_issues",
        "documentation": {}
    },
    {
        "label": "SignalGenerator",
        "kind": 6,
        "importPath": "fix.fix_final_issues",
        "description": "fix.fix_final_issues",
        "peekOfCode": "class SignalGenerator:\n    \"\"\"Generates trading signals - Windows compatible version.\"\"\"\n    def __init__(self, config: Config):\n        \"\"\"Initialize signal generator with AGGRESSIVE configuration.\"\"\"\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n        # ULTRA AGGRESSIVE Signal parameters - GUARANTEED to generate signals\n        self.fast_ma_period = 5      # Very fast MA\n        self.slow_ma_period = 10     # Very slow MA  \n        self.min_signal_strength = 0.01  # Only 1% strength needed!",
        "detail": "fix.fix_final_issues",
        "documentation": {}
    },
    {
        "label": "SimpleScalper",
        "kind": 6,
        "importPath": "fix.fix_final_issues",
        "description": "fix.fix_final_issues",
        "peekOfCode": "class SimpleScalper:\n    \"\"\"Minimal scalper for compatibility.\"\"\"\n    def __init__(self, config: Config):\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n    async def initialize(self) -> None:\n        \"\"\"Async initialize for compatibility.\"\"\"\n        pass\n    def generate_signal(self, market_data) -> Optional[TradingSignal]:\n        \"\"\"Simple scalping signal generation.\"\"\"",
        "detail": "fix.fix_final_issues",
        "documentation": {}
    },
    {
        "label": "create_windows_compatible_signals",
        "kind": 2,
        "importPath": "fix.fix_final_issues",
        "description": "fix.fix_final_issues",
        "peekOfCode": "def create_windows_compatible_signals():\n    \"\"\"Create signals.py that works perfectly on Windows.\"\"\"\n    signals_content = '''\"\"\"\nTrading signal generation - Windows Compatible Version\nThis version fixes Unicode issues and async/await problems.\nDesigned for MAXIMUM compatibility with Windows and existing project structure.\n\"\"\"\nimport logging\nfrom typing import Optional, List, Dict, Any\nfrom datetime import datetime, timezone",
        "detail": "fix.fix_final_issues",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "fix.fix_final_issues",
        "description": "fix.fix_final_issues",
        "peekOfCode": "def main():\n    \"\"\"Main function - fix final Windows issues.\"\"\"\n    print(\"🔧 FIXING FINAL WINDOWS COMPATIBILITY ISSUES\")\n    print(\"=\" * 60)\n    print(\"Problem 1: UnicodeEncodeError with emoji on Windows\")\n    print(\"Problem 2: TypeError: object NoneType can't be used in 'await'\")\n    print(\"Solution: Windows-compatible signals.py with async fixes\")\n    print(\"=\" * 60)\n    create_windows_compatible_signals()\n    print(\"\\\\n\" + \"=\" * 60)",
        "detail": "fix.fix_final_issues",
        "documentation": {}
    },
    {
        "label": "TradingSignal",
        "kind": 6,
        "importPath": "fix.fix_import_errors",
        "description": "fix.fix_import_errors",
        "peekOfCode": "class TradingSignal:\n    \"\"\"Trading signal data structure.\"\"\"\n    symbol: str\n    signal_type: SignalType\n    strength: float\n    timestamp: datetime\n    metadata: Dict[str, Any] = None\n    def __post_init__(self):\n        if self.metadata is None:\n            self.metadata = {}",
        "detail": "fix.fix_import_errors",
        "documentation": {}
    },
    {
        "label": "SignalGenerator",
        "kind": 6,
        "importPath": "fix.fix_import_errors",
        "description": "fix.fix_import_errors",
        "peekOfCode": "class SignalGenerator:\n    \"\"\"Generates trading signals with MAXIMUM compatibility and activity.\"\"\"\n    def __init__(self, config: Config):\n        \"\"\"Initialize signal generator with AGGRESSIVE configuration.\"\"\"\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n        # ULTRA AGGRESSIVE Signal parameters - GUARANTEED to generate signals\n        self.fast_ma_period = 5      # Very fast MA\n        self.slow_ma_period = 10     # Very slow MA  \n        self.min_signal_strength = 0.01  # Only 1% strength needed!",
        "detail": "fix.fix_import_errors",
        "documentation": {}
    },
    {
        "label": "SimpleScalper",
        "kind": 6,
        "importPath": "fix.fix_import_errors",
        "description": "fix.fix_import_errors",
        "peekOfCode": "class SimpleScalper:\n    \"\"\"Minimal scalper for compatibility.\"\"\"\n    def __init__(self, config: Config):\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n    def generate_signal(self, market_data) -> Optional[TradingSignal]:\n        \"\"\"Simple scalping signal generation.\"\"\"\n        return None  # Not implemented in compatibility mode\n'''\n    # Create backup of current version",
        "detail": "fix.fix_import_errors",
        "documentation": {}
    },
    {
        "label": "create_compatible_signals_py",
        "kind": 2,
        "importPath": "fix.fix_import_errors",
        "description": "fix.fix_import_errors",
        "peekOfCode": "def create_compatible_signals_py():\n    \"\"\"Create signals.py compatible with user's existing project structure.\"\"\"\n    signals_content = '''\"\"\"\nTrading signal generation compatible with existing project structure.\nThis version creates its own TradingSignal class and works independently\nof core.types imports that may not exist in the user's project.\n\"\"\"\nimport logging\nfrom typing import Optional, List, Dict, Any\nfrom datetime import datetime, timezone",
        "detail": "fix.fix_import_errors",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "fix.fix_import_errors",
        "description": "fix.fix_import_errors",
        "peekOfCode": "def main():\n    \"\"\"Main function - fix import errors.\"\"\"\n    print(\"🔧 FIXING IMPORT ERRORS\")\n    print(\"=\" * 50)\n    print(\"Problem: cannot import 'TradingSignal' from 'core.types'\")\n    print(\"Solution: Create compatible signals.py with its own classes\")\n    print(\"=\" * 50)\n    create_compatible_signals_py()\n    print(\"\\\\n\" + \"=\" * 50)\n    print(\"🎯 IMMEDIATE TESTING:\")",
        "detail": "fix.fix_import_errors",
        "documentation": {}
    },
    {
        "label": "SignalGenerator",
        "kind": 6,
        "importPath": "fix.fix_signal_strength",
        "description": "fix.fix_signal_strength",
        "peekOfCode": "class SignalGenerator:\n    \"\"\"Generates trading signals with ultra-low thresholds for demo trading.\"\"\"\n    def __init__(self, config: Config):\n        \"\"\"Initialize signal generator with AGGRESSIVE configuration.\"\"\"\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n        # ULTRA AGGRESSIVE Signal parameters\n        self.fast_ma_period = 3      # Very fast MA\n        self.slow_ma_period = 9      # Very slow MA  \n        self.min_signal_strength = 0.05  # Only 5% strength needed!",
        "detail": "fix.fix_signal_strength",
        "documentation": {}
    },
    {
        "label": "SimpleScalper",
        "kind": 6,
        "importPath": "fix.fix_signal_strength",
        "description": "fix.fix_signal_strength",
        "peekOfCode": "class SimpleScalper:\n    \"\"\"Ultra aggressive scalping strategy.\"\"\"\n    def __init__(self, config: Config):\n        \"\"\"Initialize scalper with ULTRA aggressive configuration.\"\"\"\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n        # ULTRA AGGRESSIVE Scalping parameters\n        self.momentum_period = 2  # Very short period\n        self.momentum_threshold = 0.0001  # 0.01% threshold\n        self.volume_threshold = 0.5  # 50% of average volume",
        "detail": "fix.fix_signal_strength",
        "documentation": {}
    },
    {
        "label": "backup_and_patch_signals",
        "kind": 2,
        "importPath": "fix.fix_signal_strength",
        "description": "fix.fix_signal_strength",
        "peekOfCode": "def backup_and_patch_signals():\n    \"\"\"Backup and patch the signals.py file.\"\"\"\n    signals_file = \"strategy/signals.py\"\n    backup_file = f\"strategy/signals.py.backup_{datetime.now().strftime('%Y%m%d_%H%M%S')}\"\n    if not os.path.exists(signals_file):\n        print(f\"❌ Could not find {signals_file}\")\n        return False\n    # Create backup\n    shutil.copy2(signals_file, backup_file)\n    print(f\"📋 Backup created: {backup_file}\")",
        "detail": "fix.fix_signal_strength",
        "documentation": {}
    },
    {
        "label": "create_ultra_debug_signals",
        "kind": 2,
        "importPath": "fix.fix_signal_strength",
        "description": "fix.fix_signal_strength",
        "peekOfCode": "def create_ultra_debug_signals():\n    \"\"\"Create a completely new signals.py optimized for maximum trading activity.\"\"\"\n    ultra_signals_code = '''\"\"\"\nTrading signal generation optimized for MAXIMUM demo trading activity.\n\"\"\"\nimport logging\nfrom typing import Optional, List\nfrom decimal import Decimal\nfrom datetime import datetime\nimport numpy as np",
        "detail": "fix.fix_signal_strength",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "fix.fix_signal_strength",
        "description": "fix.fix_signal_strength",
        "peekOfCode": "def main():\n    \"\"\"Main function to fix signal strength issues.\"\"\"\n    print(\"🔧 FIXING SIGNAL STRENGTH ISSUES\")\n    print(\"=\" * 50)\n    print(\"Problem: SignalGenerator min_signal_strength = 0.6 (60%)\")\n    print(\"Solution: Lower to 0.1 (10%) and add debug logging\")\n    print(\"=\" * 50)\n    # Method 1: Patch existing file\n    print(\"\\\\n1. 📊 PATCHING EXISTING signals.py:\")\n    if backup_and_patch_signals():",
        "detail": "fix.fix_signal_strength",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "fix.fix_user_config",
        "description": "fix.fix_user_config",
        "peekOfCode": "class Config(BaseModel):\n    # ... existing fields ...\n    # Feature flags (aliases for compatibility)\n    @property\n    def use_lstm(self) -> bool:\n        return self.lstm_enable\n    # ADD THE NEW PROPERTIES HERE:\n    @property\n    def max_daily_loss(self) -> float:\n        \\\"\\\"\\\"Get max daily loss for compatibility.\\\"\\\"\\\"",
        "detail": "fix.fix_user_config",
        "documentation": {}
    },
    {
        "label": "find_config_file",
        "kind": 2,
        "importPath": "fix.fix_user_config",
        "description": "fix.fix_user_config",
        "peekOfCode": "def find_config_file():\n    \"\"\"Find the user's config.py file.\"\"\"\n    possible_paths = [\n        \"core/config.py\",\n        \"../core/config.py\", \n        \"../../core/config.py\",\n        \"config.py\"\n    ]\n    for path in possible_paths:\n        if os.path.exists(path):",
        "detail": "fix.fix_user_config",
        "documentation": {}
    },
    {
        "label": "check_config_properties",
        "kind": 2,
        "importPath": "fix.fix_user_config",
        "description": "fix.fix_user_config",
        "peekOfCode": "def check_config_properties(config_path):\n    \"\"\"Check which properties are missing from the config.\"\"\"\n    if not os.path.exists(config_path):\n        return None, []\n    with open(config_path, 'r', encoding='utf-8') as f:\n        content = f.read()\n    required_properties = [\n        'max_daily_loss',\n        'close_positions_on_exit'\n    ]",
        "detail": "fix.fix_user_config",
        "documentation": {}
    },
    {
        "label": "generate_fix",
        "kind": 2,
        "importPath": "fix.fix_user_config",
        "description": "fix.fix_user_config",
        "peekOfCode": "def generate_fix():\n    \"\"\"Generate the fix code that needs to be added to Config class.\"\"\"\n    fix_code = '''\n    @property\n    def max_daily_loss(self) -> float:\n        \"\"\"Get max daily loss for compatibility.\"\"\"\n        return self.max_daily_loss_pct\n    @property\n    def close_positions_on_exit(self) -> bool:\n        \"\"\"Whether to close positions on bot exit.\"\"\"",
        "detail": "fix.fix_user_config",
        "documentation": {}
    },
    {
        "label": "show_manual_fix",
        "kind": 2,
        "importPath": "fix.fix_user_config",
        "description": "fix.fix_user_config",
        "peekOfCode": "def show_manual_fix():\n    \"\"\"Show manual instructions for fixing the config.\"\"\"\n    print(\"\"\"\n🔧 MANUAL FIX INSTRUCTIONS\n==========================\nYour Config class is missing required properties. Add this code to your core/config.py:\n1. Find your Config class definition\n2. Add these properties INSIDE the class (before the last line):\n\"\"\")\n    print(generate_fix())",
        "detail": "fix.fix_user_config",
        "documentation": {}
    },
    {
        "label": "automatic_fix",
        "kind": 2,
        "importPath": "fix.fix_user_config",
        "description": "fix.fix_user_config",
        "peekOfCode": "def automatic_fix(config_path, content):\n    \"\"\"Attempt to automatically fix the config file.\"\"\"\n    try:\n        # Find the end of the Config class\n        # Look for the last method or property before class ends\n        # Strategy: Find a good insertion point before class ends\n        # Look for common patterns like \"def parse_\" or \"@classmethod\"\n        fix_code = generate_fix()\n        # Try to find insertion point - look for existing @property methods\n        property_pattern = r'(@property\\s+def\\s+\\w+.*?\\n\\s+return.*?\\n)'",
        "detail": "fix.fix_user_config",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "fix.fix_user_config",
        "description": "fix.fix_user_config",
        "peekOfCode": "def main():\n    \"\"\"Main function.\"\"\"\n    print(\"🔍 Checking Config for Missing Properties...\")\n    print(\"=\" * 50)\n    config_path = find_config_file()\n    if not config_path:\n        print(\"❌ Could not find core/config.py file\")\n        print(\"Make sure you're running this from the project directory\")\n        show_manual_fix()\n        return",
        "detail": "fix.fix_user_config",
        "documentation": {}
    },
    {
        "label": "BinanceMarketDataClient",
        "kind": 6,
        "importPath": "fix.fix_user_imports",
        "description": "fix.fix_user_imports",
        "peekOfCode": "class BinanceMarketDataClient:\n    \\\"\\\"\\\"Market data client compatible with paper trading engine.\\\"\\\"\\\"\n    def __init__(self, config):\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n        # Use IntegratedBinanceClient for market data\n        self.client = IntegratedBinanceClient(config)\n    def initialize(self):\n        \\\"\\\"\\\"Initialize market data client.\\\"\\\"\\\"\n        self.logger.info(\"BinanceMarketDataClient initialized (compatibility wrapper)\")",
        "detail": "fix.fix_user_imports",
        "documentation": {}
    },
    {
        "label": "fix_import_compatibility",
        "kind": 2,
        "importPath": "fix.fix_user_imports",
        "description": "fix.fix_user_imports",
        "peekOfCode": "def fix_import_compatibility():\n    \"\"\"Fix import issues in user's actual system\"\"\"\n    print(\"🔧 Fixing import compatibility for user's real system...\")\n    # 1. Add BinanceMarketDataClient to exchange/client.py\n    client_fix = \"\"\"\n# Additional compatibility classes for paper trading\nclass BinanceMarketDataClient:\n    \\\"\\\"\\\"Market data client compatible with paper trading engine.\\\"\\\"\\\"\n    def __init__(self, config):\n        self.config = config",
        "detail": "fix.fix_user_imports",
        "documentation": {}
    },
    {
        "label": "StructuredLogger",
        "kind": 6,
        "importPath": "infra.logging",
        "description": "infra.logging",
        "peekOfCode": "class StructuredLogger:\n    \"\"\"\n    Structured logging wrapper that provides consistent formatting,\n    contextual information, and multiple output destinations.\n    \"\"\"\n    def __init__(self, config: Config):\n        self.config = config\n        self.log_dir = (\n            Path(config.log_dir) if hasattr(config, \"log_dir\") else Path(\"logs\")\n        )",
        "detail": "infra.logging",
        "documentation": {}
    },
    {
        "label": "TradingLogger",
        "kind": 6,
        "importPath": "infra.logging",
        "description": "infra.logging",
        "peekOfCode": "class TradingLogger:\n    \"\"\"\n    Specialized logger for trading operations with structured trade logging.\n    \"\"\"\n    @staticmethod\n    def log_trade(\n        action: str,\n        symbol: str,\n        side: str,\n        quantity: float,",
        "detail": "infra.logging",
        "documentation": {}
    },
    {
        "label": "PerformanceLogger",
        "kind": 6,
        "importPath": "infra.logging",
        "description": "infra.logging",
        "peekOfCode": "class PerformanceLogger:\n    \"\"\"\n    Logger for performance monitoring and system metrics.\n    \"\"\"\n    @staticmethod\n    def log_execution_time(\n        operation: str, duration_ms: float, success: bool = True, **kwargs\n    ) -> None:\n        \"\"\"Log operation execution time.\"\"\"\n        perf_data = {",
        "detail": "infra.logging",
        "documentation": {}
    },
    {
        "label": "LoggingContext",
        "kind": 6,
        "importPath": "infra.logging",
        "description": "infra.logging",
        "peekOfCode": "class LoggingContext:\n    \"\"\"Context manager for adding temporary logging context.\"\"\"\n    def __init__(self, **context):\n        self.context = context\n        self.token = None\n    def __enter__(self):\n        self.token = logger.contextualize(**self.context)\n        return self\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        if self.token:",
        "detail": "infra.logging",
        "documentation": {}
    },
    {
        "label": "setup_structured_logging",
        "kind": 2,
        "importPath": "infra.logging",
        "description": "infra.logging",
        "peekOfCode": "def setup_structured_logging(config: Config) -> StructuredLogger:\n    \"\"\"\n    Setup structured logging for the application.\n    Args:\n        config: Application configuration\n    Returns:\n        Configured StructuredLogger instance\n    \"\"\"\n    structured_logger = StructuredLogger(config)\n    # Log initialization",
        "detail": "infra.logging",
        "documentation": {}
    },
    {
        "label": "get_logger",
        "kind": 2,
        "importPath": "infra.logging",
        "description": "infra.logging",
        "peekOfCode": "def get_logger(name: str = None) -> Any:\n    \"\"\"\n    Get a logger instance.\n    Args:\n        name: Logger name (optional)\n    Returns:\n        Logger instance\n    \"\"\"\n    if name:\n        return logger.bind(component=name)",
        "detail": "infra.logging",
        "documentation": {}
    },
    {
        "label": "with_logging_context",
        "kind": 2,
        "importPath": "infra.logging",
        "description": "infra.logging",
        "peekOfCode": "def with_logging_context(**context):\n    \"\"\"Decorator to add logging context to a function.\"\"\"\n    def decorator(func):\n        def wrapper(*args, **kwargs):\n            with LoggingContext(**context):\n                return func(*args, **kwargs)\n        return wrapper\n    return decorator\n# Export main interfaces\ntrading_logger = TradingLogger()",
        "detail": "infra.logging",
        "documentation": {}
    },
    {
        "label": "trading_logger",
        "kind": 5,
        "importPath": "infra.logging",
        "description": "infra.logging",
        "peekOfCode": "trading_logger = TradingLogger()\nperformance_logger = PerformanceLogger()\n__all__ = [\n    \"setup_structured_logging\",\n    \"get_logger\",\n    \"StructuredLogger\",\n    \"TradingLogger\",\n    \"PerformanceLogger\",\n    \"LoggingContext\",\n    \"with_logging_context\",",
        "detail": "infra.logging",
        "documentation": {}
    },
    {
        "label": "performance_logger",
        "kind": 5,
        "importPath": "infra.logging",
        "description": "infra.logging",
        "peekOfCode": "performance_logger = PerformanceLogger()\n__all__ = [\n    \"setup_structured_logging\",\n    \"get_logger\",\n    \"StructuredLogger\",\n    \"TradingLogger\",\n    \"PerformanceLogger\",\n    \"LoggingContext\",\n    \"with_logging_context\",\n    \"trading_logger\",",
        "detail": "infra.logging",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "infra.logging",
        "description": "infra.logging",
        "peekOfCode": "__all__ = [\n    \"setup_structured_logging\",\n    \"get_logger\",\n    \"StructuredLogger\",\n    \"TradingLogger\",\n    \"PerformanceLogger\",\n    \"LoggingContext\",\n    \"with_logging_context\",\n    \"trading_logger\",\n    \"performance_logger\",",
        "detail": "infra.logging",
        "documentation": {}
    },
    {
        "label": "PerformanceMetric",
        "kind": 6,
        "importPath": "infra.metrics",
        "description": "infra.metrics",
        "peekOfCode": "class PerformanceMetric:\n    \"\"\"Individual performance metric data.\"\"\"\n    name: str\n    value: float\n    timestamp: datetime\n    metadata: dict[str, Any] = field(default_factory=dict)\n@dataclass\nclass SystemMetrics:\n    \"\"\"System resource utilization metrics.\"\"\"\n    timestamp: datetime",
        "detail": "infra.metrics",
        "documentation": {}
    },
    {
        "label": "SystemMetrics",
        "kind": 6,
        "importPath": "infra.metrics",
        "description": "infra.metrics",
        "peekOfCode": "class SystemMetrics:\n    \"\"\"System resource utilization metrics.\"\"\"\n    timestamp: datetime\n    cpu_percent: float\n    memory_usage_mb: float\n    memory_percent: float\n    disk_usage_gb: float\n    disk_percent: float\n    network_sent_mb: float = 0.0\n    network_recv_mb: float = 0.0",
        "detail": "infra.metrics",
        "documentation": {}
    },
    {
        "label": "MetricsCollector",
        "kind": 6,
        "importPath": "infra.metrics",
        "description": "infra.metrics",
        "peekOfCode": "class MetricsCollector:\n    \"\"\"\n    Centralized metrics collection and performance monitoring.\n    Features:\n    - System resource monitoring\n    - Trading performance metrics\n    - API call latency tracking\n    - Custom metric collection\n    - Real-time alerting\n    \"\"\"",
        "detail": "infra.metrics",
        "documentation": {}
    },
    {
        "label": "PerformanceTracker",
        "kind": 6,
        "importPath": "infra.metrics",
        "description": "infra.metrics",
        "peekOfCode": "class PerformanceTracker:\n    \"\"\"\n    Performance tracking utility for individual operations.\n    \"\"\"\n    def __init__(self, metrics_collector: MetricsCollector):\n        self.metrics = metrics_collector\n    def time_operation(self, operation_name: str):\n        \"\"\"Context manager to time an operation.\"\"\"\n        return TimedOperation(operation_name, self.metrics)\n    async def track_async_operation(",
        "detail": "infra.metrics",
        "documentation": {}
    },
    {
        "label": "TimedOperation",
        "kind": 6,
        "importPath": "infra.metrics",
        "description": "infra.metrics",
        "peekOfCode": "class TimedOperation:\n    \"\"\"Context manager for timing operations.\"\"\"\n    def __init__(self, operation_name: str, metrics_collector: MetricsCollector):\n        self.operation_name = operation_name\n        self.metrics = metrics_collector\n        self.start_time = None\n    def __enter__(self):\n        self.start_time = time.time()\n        return self\n    def __exit__(self, exc_type, exc_val, exc_tb):",
        "detail": "infra.metrics",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "infra.metrics",
        "description": "infra.metrics",
        "peekOfCode": "__all__ = [\n    \"MetricsCollector\",\n    \"PerformanceTracker\",\n    \"PerformanceMetric\",\n    \"SystemMetrics\",\n    \"TimedOperation\",\n]",
        "detail": "infra.metrics",
        "documentation": {}
    },
    {
        "label": "StateManager",
        "kind": 6,
        "importPath": "infra.persistence",
        "description": "infra.persistence",
        "peekOfCode": "class StateManager:\n    \"\"\"\n    Manages bot state persistence to survive restarts and failures.\n    Stores active positions, pending orders, and runtime state.\n    \"\"\"\n    def __init__(self, config: Config):\n        self.config = config\n        self.data_dir = (\n            Path(config.data_dir) if hasattr(config, \"data_dir\") else Path(\"data\")\n        )",
        "detail": "infra.persistence",
        "documentation": {}
    },
    {
        "label": "DataPersistence",
        "kind": 6,
        "importPath": "infra.persistence",
        "description": "infra.persistence",
        "peekOfCode": "class DataPersistence:\n    \"\"\"\n    Persistent storage for trading data using SQLite.\n    Stores trades, orders, positions, signals, and performance metrics.\n    \"\"\"\n    def __init__(self, config: Config):\n        self.config = config\n        self.data_dir = (\n            Path(config.data_dir) if hasattr(config, \"data_dir\") else Path(\"data\")\n        )",
        "detail": "infra.persistence",
        "documentation": {}
    },
    {
        "label": "CacheManager",
        "kind": 6,
        "importPath": "infra.persistence",
        "description": "infra.persistence",
        "peekOfCode": "class CacheManager:\n    \"\"\"\n    In-memory cache with TTL support for frequently accessed data.\n    \"\"\"\n    def __init__(self, max_size: int = 1000, ttl_seconds: int = 3600):\n        self.max_size = max_size\n        self.ttl_seconds = ttl_seconds\n        self._cache: dict[str, dict[str, Any]] = {}\n        self._access_times: dict[str, datetime] = {}\n    async def get(self, key: str) -> Any | None:",
        "detail": "infra.persistence",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "infra.persistence",
        "description": "infra.persistence",
        "peekOfCode": "__all__ = [\"StateManager\", \"DataPersistence\", \"CacheManager\"]",
        "detail": "infra.persistence",
        "documentation": {}
    },
    {
        "label": "RuntimeOverridesWatcher",
        "kind": 6,
        "importPath": "infra.settings",
        "description": "infra.settings",
        "peekOfCode": "class RuntimeOverridesWatcher:\n    \"\"\"Следит за файлом overrides и возвращает изменения при обновлении.\"\"\"\n    def __init__(self, path: str):\n        self.path = path\n        self._last_mtime = 0.0\n    def poll(self) -> Dict[str, Any]:\n        try:\n            st = os.stat(self.path)\n        except FileNotFoundError:\n            return {}",
        "detail": "infra.settings",
        "documentation": {}
    },
    {
        "label": "parse_kv_dict",
        "kind": 2,
        "importPath": "infra.settings",
        "description": "infra.settings",
        "peekOfCode": "def parse_kv_dict(raw_dict: Dict[str,str]) -> Dict[str, Any]:\n    out: Dict[str, Any] = {}\n    for k, v in raw_dict.items():\n        if v is None:\n            continue\n        out[_kmap(k)] = _coerce(k, str(v))\n    return out\n# ---------- Профили в INI ----------\ndef load_profile(profile_name: str, ini_path: str = \"config/profiles.ini\") -> Dict[str, Any]:\n    if not os.path.exists(ini_path):",
        "detail": "infra.settings",
        "documentation": {}
    },
    {
        "label": "load_profile",
        "kind": 2,
        "importPath": "infra.settings",
        "description": "infra.settings",
        "peekOfCode": "def load_profile(profile_name: str, ini_path: str = \"config/profiles.ini\") -> Dict[str, Any]:\n    if not os.path.exists(ini_path):\n        return {}\n    cfg = configparser.ConfigParser()\n    cfg.optionxform = str  # сохранить регистр ключей\n    cfg.read(ini_path, encoding=\"utf-8\")\n    if profile_name not in cfg.sections():\n        return {}\n    section = cfg[profile_name]\n    raw = {k: section.get(k) for k in section}",
        "detail": "infra.settings",
        "documentation": {}
    },
    {
        "label": "load_overrides",
        "kind": 2,
        "importPath": "infra.settings",
        "description": "infra.settings",
        "peekOfCode": "def load_overrides(path: str) -> Dict[str, Any]:\n    if not os.path.exists(path):\n        return {}\n    changes: Dict[str, Any] = {}\n    with open(path, \"r\", encoding=\"utf-8\") as f:\n        for line in f:\n            s = line.strip()\n            if not s or s.startswith(\"#\"):\n                continue\n            if s.startswith(\":set\"):",
        "detail": "infra.settings",
        "documentation": {}
    },
    {
        "label": "apply_settings_to_config",
        "kind": 2,
        "importPath": "infra.settings",
        "description": "infra.settings",
        "peekOfCode": "def apply_settings_to_config(config: Any, settings: Dict[str, Any]) -> None:\n    for attr, val in settings.items():\n        try:\n            setattr(config, attr, val)\n        except Exception:\n            pass\nclass RuntimeOverridesWatcher:\n    \"\"\"Следит за файлом overrides и возвращает изменения при обновлении.\"\"\"\n    def __init__(self, path: str):\n        self.path = path",
        "detail": "infra.settings",
        "documentation": {}
    },
    {
        "label": "KEY_MAP",
        "kind": 5,
        "importPath": "infra.settings",
        "description": "infra.settings",
        "peekOfCode": "KEY_MAP = {\n    # Trading Parameters\n    \"SYMBOL\": \"symbol\",\n    \"SYMBOLS\": \"symbols\",\n    \"TIMEFRAME\": \"timeframe\",\n    \"BACKTEST_DAYS\": \"backtest_days\",\n    # Risk\n    \"LEVERAGE\": \"leverage\",\n    \"RISK_PER_TRADE_PCT\": \"risk_per_trade\",      # в долях (0.005 для 0.5%)\n    \"MAX_DAILY_LOSS_PCT\": \"max_daily_loss\",      # в долях (0.05 для 5%)",
        "detail": "infra.settings",
        "documentation": {}
    },
    {
        "label": "PCT_ALREADY_FRACTION",
        "kind": 5,
        "importPath": "infra.settings",
        "description": "infra.settings",
        "peekOfCode": "PCT_ALREADY_FRACTION = {\"VWAP_BAND_PCT\"}\n# какие *_PCT точно нужно делить (даже если значение <= 1.0)\nPCT_FORCE_DIV100 = {\"RISK_PER_TRADE_PCT\", \"MAX_DAILY_LOSS_PCT\", \"SL_FIXED_PCT\", \"MAX_DRAWDOWN_PCT\"}\ndef _parse_bool(v: str) -> bool:\n    return str(v).strip().lower() in {\"1\",\"true\",\"yes\",\"on\",\"y\",\"t\"}\ndef _parse_list(v: str) -> List[str]:\n    return [s.strip() for s in str(v).split(\",\") if s.strip()]\ndef _parse_float(v: str) -> float:\n    return float(str(v).strip())\ndef _parse_tp_list(v: str) -> List[float]:",
        "detail": "infra.settings",
        "documentation": {}
    },
    {
        "label": "PCT_FORCE_DIV100",
        "kind": 5,
        "importPath": "infra.settings",
        "description": "infra.settings",
        "peekOfCode": "PCT_FORCE_DIV100 = {\"RISK_PER_TRADE_PCT\", \"MAX_DAILY_LOSS_PCT\", \"SL_FIXED_PCT\", \"MAX_DRAWDOWN_PCT\"}\ndef _parse_bool(v: str) -> bool:\n    return str(v).strip().lower() in {\"1\",\"true\",\"yes\",\"on\",\"y\",\"t\"}\ndef _parse_list(v: str) -> List[str]:\n    return [s.strip() for s in str(v).split(\",\") if s.strip()]\ndef _parse_float(v: str) -> float:\n    return float(str(v).strip())\ndef _parse_tp_list(v: str) -> List[float]:\n    return [float(x.strip()) for x in str(v).split(\",\") if x.strip()]\ndef _parse_dca_ladder(v: str) -> List[Tuple[float,float]]:",
        "detail": "infra.settings",
        "documentation": {}
    },
    {
        "label": "LSTMPredictor",
        "kind": 6,
        "importPath": "models.lstm",
        "description": "models.lstm",
        "peekOfCode": "class LSTMPredictor:\n    \"\"\"\n    LSTM Neural Network for cryptocurrency price prediction.\n    Features:\n    - Multi-layer LSTM architecture\n    - Dropout for regularization\n    - Early stopping and model checkpointing\n    - Prediction confidence estimation\n    - Model persistence and loading\n    \"\"\"",
        "detail": "models.lstm",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "models.lstm",
        "description": "models.lstm",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass LSTMPredictor:\n    \"\"\"\n    LSTM Neural Network for cryptocurrency price prediction.\n    Features:\n    - Multi-layer LSTM architecture\n    - Dropout for regularization\n    - Early stopping and model checkpointing\n    - Prediction confidence estimation\n    - Model persistence and loading",
        "detail": "models.lstm",
        "documentation": {}
    },
    {
        "label": "BacktestConfig",
        "kind": 6,
        "importPath": "runner.backtest",
        "description": "runner.backtest",
        "peekOfCode": "class BacktestConfig:\n    \"\"\"Configuration for backtesting runs.\"\"\"\n    start_date: datetime\n    end_date: datetime\n    initial_balance: float\n    commission: float = 0.001  # 0.1% commission\n    slippage: float = 0.0005  # 0.05% slippage\n    symbol: str = \"BTCUSDT\"\n    timeframe: Timeframe = Timeframe.M5\n    # Strategy parameters",
        "detail": "runner.backtest",
        "documentation": {}
    },
    {
        "label": "BacktestEngine",
        "kind": 6,
        "importPath": "runner.backtest",
        "description": "runner.backtest",
        "peekOfCode": "class BacktestEngine:\n    \"\"\"\n    Comprehensive backtesting engine for strategy validation.\n    Features:\n    - Historical data replay\n    - Realistic order execution simulation\n    - Commission and slippage modeling\n    - Detailed performance analysis\n    - Risk metrics calculation\n    - Strategy optimization support",
        "detail": "runner.backtest",
        "documentation": {}
    },
    {
        "label": "TradeExecutor",
        "kind": 6,
        "importPath": "runner.execution",
        "description": "runner.execution",
        "peekOfCode": "class TradeExecutor:\n    def __init__(self, client: Optional[BinanceClient] = None):\n        self.cfg = get_config()\n        self.client = client or BinanceClient()\n    def _position_side_from_signal(self, signal_type: str) -> str:\n        s = str(signal_type or \"\").upper()\n        return \"LONG\" if s == \"BUY\" else \"SHORT\"\n    def _entry_side_from_signal(self, signal_type: str) -> str:\n        s = str(signal_type or \"\").upper()\n        return \"BUY\" if s == \"BUY\" else \"SELL\"",
        "detail": "runner.execution",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "runner.execution",
        "description": "runner.execution",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass TradeExecutor:\n    def __init__(self, client: Optional[BinanceClient] = None):\n        self.cfg = get_config()\n        self.client = client or BinanceClient()\n    def _position_side_from_signal(self, signal_type: str) -> str:\n        s = str(signal_type or \"\").upper()\n        return \"LONG\" if s == \"BUY\" else \"SHORT\"\n    def _entry_side_from_signal(self, signal_type: str) -> str:\n        s = str(signal_type or \"\").upper()",
        "detail": "runner.execution",
        "documentation": {}
    },
    {
        "label": "LiveTradingEngine",
        "kind": 6,
        "importPath": "runner.live.bak_guardrails_v6",
        "description": "runner.live.bak_guardrails_v6",
        "peekOfCode": "class LiveTradingEngine:\n    \"\"\"\n    Live trading execution engine with comprehensive safety measures.\n    Features:\n    - Real-time signal processing\n    - Position and risk management\n    - Emergency stop mechanisms\n    - Performance monitoring\n    - State persistence\n    \"\"\"",
        "detail": "runner.live.bak_guardrails_v6",
        "documentation": {}
    },
    {
        "label": "LiveTradingEngine",
        "kind": 6,
        "importPath": "runner.live.bak_guardrails_v7",
        "description": "runner.live.bak_guardrails_v7",
        "peekOfCode": "class LiveTradingEngine:\n    \"\"\"\n    Live trading execution engine with comprehensive safety measures.\n    Features:\n    - Real-time signal processing\n    - Position and risk management\n    - Emergency stop mechanisms\n    - Performance monitoring\n    - State persistence\n    \"\"\"",
        "detail": "runner.live.bak_guardrails_v7",
        "documentation": {}
    },
    {
        "label": "LiveTradingEngine",
        "kind": 6,
        "importPath": "runner.live.bak_guardrails_v8",
        "description": "runner.live.bak_guardrails_v8",
        "peekOfCode": "class LiveTradingEngine:\n    \"\"\"\n    Live trading execution engine with guardrails.\n    Safe points:\n    - DRY_RUN skips exchange init/sync\n    - Runtime overrides watcher is optional (safe stubs)\n    - Risk sizing accepts both number and (qty, stop) tuple\n    - Cooldown fallback if OrderManager has no is_in_cooldown\n    - Emergency checks are tolerant to missing fields\n    \"\"\"",
        "detail": "runner.live.bak_guardrails_v8",
        "documentation": {}
    },
    {
        "label": "LiveTradingEngine",
        "kind": 6,
        "importPath": "runner.live.bak_v8_guardrails",
        "description": "runner.live.bak_v8_guardrails",
        "peekOfCode": "class LiveTradingEngine:\n    \"\"\"\n    Live trading execution engine with comprehensive safety measures.\n    \"\"\"\n    def __init__(self, config: Config):\n        self.config = config\n        # Runtime overrides (optional file watcher)\n        self._overrides_watcher = None\n        path = _get(self.config, \"overrides_path\", \"\") or \"config/overrides.txt\"\n        if RuntimeOverridesWatcher and os.path.exists(path):",
        "detail": "runner.live.bak_v8_guardrails",
        "documentation": {}
    },
    {
        "label": "NormalizedSignal",
        "kind": 6,
        "importPath": "runner.live",
        "description": "runner.live",
        "peekOfCode": "class NormalizedSignal:\n    symbol: str\n    side: str              # \"BUY\" or \"SELL\"\n    strength: float = 0.0  # 0..1\n    entry_price: Optional[float] = None\n    timestamp: datetime = datetime.now(timezone.utc)\n    meta: Dict[str, Any] = None\ndef _to_float(x: Any) -> Optional[float]:\n    try:\n        if x is None:",
        "detail": "runner.live",
        "documentation": {}
    },
    {
        "label": "LiveTradingEngine",
        "kind": 6,
        "importPath": "runner.live",
        "description": "runner.live",
        "peekOfCode": "class LiveTradingEngine:\n    def __init__(self, config: Config):\n        self.config = config\n        self.logger = logging.getLogger(\"runner.live\")\n        self.running = False\n        self.iteration = 0\n        # Symbols\n        symbols = getattr(config, \"symbols\", None)\n        if not symbols:\n            sym = getattr(config, \"symbol\", None)",
        "detail": "runner.live",
        "documentation": {}
    },
    {
        "label": "normalize_signal_obj",
        "kind": 2,
        "importPath": "runner.live",
        "description": "runner.live",
        "peekOfCode": "def normalize_signal_obj(raw: Any, symbol_default: Optional[str] = None) -> Optional[NormalizedSignal]:\n    \"\"\"\n    Accept signal in many shapes (dataclass, pydantic model, dict, plain strings).\n    Returns a NormalizedSignal or None if cannot be understood.\n    \"\"\"\n    if raw is None:\n        return None\n    # If signal is a plain string like \"BUY\"/\"SELL\", treat as no-trade fallback (skip).\n    if isinstance(raw, str):\n        s = raw.strip().upper()",
        "detail": "runner.live",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "runner.live",
        "description": "runner.live",
        "peekOfCode": "logger = logging.getLogger(__name__)\n# --- Internal helper structures -------------------------------------------------------\n@dataclass\nclass NormalizedSignal:\n    symbol: str\n    side: str              # \"BUY\" or \"SELL\"\n    strength: float = 0.0  # 0..1\n    entry_price: Optional[float] = None\n    timestamp: datetime = datetime.now(timezone.utc)\n    meta: Dict[str, Any] = None",
        "detail": "runner.live",
        "documentation": {}
    },
    {
        "label": "PaperTradingEngine",
        "kind": 6,
        "importPath": "runner.paper",
        "description": "runner.paper",
        "peekOfCode": "class PaperTradingEngine:\n    \"\"\"Paper trading engine for simulated trading.\"\"\"\n    def __init__(self, config: Config):\n        \"\"\"Initialize paper trading engine.\"\"\"\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n        # Components\n        self.trading_client = None\n        self.market_data_client: BinanceMarketDataClient = None\n        self.position_manager: PositionManager = None",
        "detail": "runner.paper",
        "documentation": {}
    },
    {
        "label": "DCALevel",
        "kind": 6,
        "importPath": "strategy.dca",
        "description": "strategy.dca",
        "peekOfCode": "class DCALevel:\n    \"\"\"Single level in a DCA strategy.\"\"\"\n    price_deviation_pct: float  # % deviation from entry price\n    quantity_multiplier: float  # Size multiplier vs base quantity\n    order_id: str | None = None\n    filled: bool = False\n    fill_price: float | None = None\n    fill_time: datetime | None = None\n@dataclass\nclass DCAConfig:",
        "detail": "strategy.dca",
        "documentation": {}
    },
    {
        "label": "DCAConfig",
        "kind": 6,
        "importPath": "strategy.dca",
        "description": "strategy.dca",
        "peekOfCode": "class DCAConfig:\n    \"\"\"Configuration for DCA strategy.\"\"\"\n    # Level configuration\n    max_levels: int = 5\n    level_spacing_pct: float = 2.0  # % spacing between levels\n    level_multipliers: list[float] = None  # Quantity multipliers per level\n    base_quantity_usd: float = 100.0\n    # Risk management\n    max_total_investment: float = 500.0  # Max total investment per position\n    max_drawdown_pct: float = 15.0  # Max unrealized loss %",
        "detail": "strategy.dca",
        "documentation": {}
    },
    {
        "label": "DCAManager",
        "kind": 6,
        "importPath": "strategy.dca",
        "description": "strategy.dca",
        "peekOfCode": "class DCAManager:\n    \"\"\"\n    Dollar Cost Averaging strategy manager.\n    Features:\n    - Multi-level DCA grid\n    - Position averaging with increasing sizes\n    - Intelligent take profit levels\n    - Risk management and stop conditions\n    - Both long and short DCA support\n    \"\"\"",
        "detail": "strategy.dca",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "strategy.dca",
        "description": "strategy.dca",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass DCALevel:\n    \"\"\"Single level in a DCA strategy.\"\"\"\n    price_deviation_pct: float  # % deviation from entry price\n    quantity_multiplier: float  # Size multiplier vs base quantity\n    order_id: str | None = None\n    filled: bool = False\n    fill_price: float | None = None\n    fill_time: datetime | None = None",
        "detail": "strategy.dca",
        "documentation": {}
    },
    {
        "label": "ExitType",
        "kind": 6,
        "importPath": "strategy.exits",
        "description": "strategy.exits",
        "peekOfCode": "class ExitType(Enum):\n    \"\"\"Exit order types.\"\"\"\n    STOP_LOSS = \"stop_loss\"\n    TAKE_PROFIT = \"take_profit\"\n    TRAILING_STOP = \"trailing_stop\"\n    TIME_BASED = \"time_based\"\n    EMERGENCY = \"emergency\"\nclass ExitStatus(Enum):\n    \"\"\"Exit status types.\"\"\"\n    PENDING = \"pending\"",
        "detail": "strategy.exits",
        "documentation": {}
    },
    {
        "label": "ExitStatus",
        "kind": 6,
        "importPath": "strategy.exits",
        "description": "strategy.exits",
        "peekOfCode": "class ExitStatus(Enum):\n    \"\"\"Exit status types.\"\"\"\n    PENDING = \"pending\"\n    ACTIVE = \"active\"\n    TRIGGERED = \"triggered\"\n    CANCELLED = \"cancelled\"\n    EXPIRED = \"expired\"\n@dataclass\nclass ExitOrder:\n    \"\"\"Exit order configuration.\"\"\"",
        "detail": "strategy.exits",
        "documentation": {}
    },
    {
        "label": "ExitOrder",
        "kind": 6,
        "importPath": "strategy.exits",
        "description": "strategy.exits",
        "peekOfCode": "class ExitOrder:\n    \"\"\"Exit order configuration.\"\"\"\n    exit_type: ExitType\n    price: float\n    quantity: float = 0.0  # 0 means full position\n    order_id: str | None = None\n    status: ExitStatus = ExitStatus.PENDING\n    created_at: float = 0.0\n    triggered_at: float | None = None\n    metadata: dict[str, Any] | None = None",
        "detail": "strategy.exits",
        "documentation": {}
    },
    {
        "label": "TrailingStopConfig",
        "kind": 6,
        "importPath": "strategy.exits",
        "description": "strategy.exits",
        "peekOfCode": "class TrailingStopConfig:\n    \"\"\"Trailing stop configuration.\"\"\"\n    activation_distance: float  # Distance to activate trailing\n    trail_distance: float       # Trailing distance\n    max_loss: float            # Maximum loss limit\n    update_frequency: int = 5   # Update frequency in seconds\nclass ExitManager:\n    \"\"\"\n    Comprehensive exit management system.\n    Handles multiple exit strategies including:",
        "detail": "strategy.exits",
        "documentation": {}
    },
    {
        "label": "ExitManager",
        "kind": 6,
        "importPath": "strategy.exits",
        "description": "strategy.exits",
        "peekOfCode": "class ExitManager:\n    \"\"\"\n    Comprehensive exit management system.\n    Handles multiple exit strategies including:\n    - Fixed stop loss and take profit levels\n    - Trailing stops with activation thresholds\n    - Time-based exits\n    - Emergency exits\n    - Dynamic exit adjustment\n    \"\"\"",
        "detail": "strategy.exits",
        "documentation": {}
    },
    {
        "label": "create_trailing_config",
        "kind": 2,
        "importPath": "strategy.exits",
        "description": "strategy.exits",
        "peekOfCode": "def create_trailing_config(\n    activation_distance: float,\n    trail_distance: float,\n    max_loss: float,\n    update_frequency: int = 5\n) -> TrailingStopConfig:\n    \"\"\"\n    Create trailing stop configuration.\n    Args:\n        activation_distance: Distance to activate trailing",
        "detail": "strategy.exits",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "strategy.exits",
        "description": "strategy.exits",
        "peekOfCode": "__all__ = [\n    \"ExitManager\",\n    \"ExitType\", \n    \"ExitStatus\",\n    \"ExitOrder\",\n    \"TrailingStopConfig\",\n    \"create_trailing_config\"\n]",
        "detail": "strategy.exits",
        "documentation": {}
    },
    {
        "label": "RiskLimits",
        "kind": 6,
        "importPath": "strategy.risk",
        "description": "strategy.risk",
        "peekOfCode": "class RiskLimits:\n    \"\"\"Risk management limits configuration.\"\"\"\n    # Position sizing\n    max_position_size_usd: float = 1000.0\n    max_position_pct_of_account: float = 10.0  # % of account balance\n    risk_per_trade_pct: float = 1.0  # Risk per individual trade\n    # Portfolio limits\n    max_total_exposure_pct: float = 50.0  # Max % of account exposed\n    max_positions_per_symbol: int = 1\n    max_total_positions: int = 10",
        "detail": "strategy.risk",
        "documentation": {}
    },
    {
        "label": "RiskMetrics",
        "kind": 6,
        "importPath": "strategy.risk",
        "description": "strategy.risk",
        "peekOfCode": "class RiskMetrics:\n    \"\"\"Current risk metrics state.\"\"\"\n    # Account metrics\n    account_balance: float = 0.0\n    total_exposure: float = 0.0\n    available_margin: float = 0.0\n    # Position metrics\n    active_positions: int = 0\n    total_unrealized_pnl: float = 0.0\n    largest_position_size: float = 0.0",
        "detail": "strategy.risk",
        "documentation": {}
    },
    {
        "label": "RiskManager",
        "kind": 6,
        "importPath": "strategy.risk",
        "description": "strategy.risk",
        "peekOfCode": "class RiskManager:\n    \"\"\"\n    Comprehensive risk management system.\n    Features:\n    - Dynamic position sizing based on account balance and volatility\n    - Portfolio-level risk limits and exposure management\n    - Drawdown protection and loss limits\n    - Correlation-based exposure limits\n    - Volatility-adjusted position sizing\n    - Risk metrics monitoring and alerts",
        "detail": "strategy.risk",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "strategy.risk",
        "description": "strategy.risk",
        "peekOfCode": "logger = logging.getLogger(__name__)\n@dataclass\nclass RiskLimits:\n    \"\"\"Risk management limits configuration.\"\"\"\n    # Position sizing\n    max_position_size_usd: float = 1000.0\n    max_position_pct_of_account: float = 10.0  # % of account balance\n    risk_per_trade_pct: float = 1.0  # Risk per individual trade\n    # Portfolio limits\n    max_total_exposure_pct: float = 50.0  # Max % of account exposed",
        "detail": "strategy.risk",
        "documentation": {}
    },
    {
        "label": "TradingSignal",
        "kind": 6,
        "importPath": "strategy.signals",
        "description": "strategy.signals",
        "peekOfCode": "class TradingSignal:\n    \"\"\"Trading signal data structure.\"\"\"\n    symbol: str\n    signal_type: SignalType\n    strength: float\n    timestamp: datetime\n    metadata: Dict[str, Any] = None\n    def __post_init__(self):\n        if self.metadata is None:\n            self.metadata = {}",
        "detail": "strategy.signals",
        "documentation": {}
    },
    {
        "label": "SignalGenerator",
        "kind": 6,
        "importPath": "strategy.signals",
        "description": "strategy.signals",
        "peekOfCode": "class SignalGenerator:\n    \"\"\"Generates trading signals based on REAL market data.\"\"\"\n    def __init__(self, config: Config):\n        \"\"\"Initialize signal generator with AGGRESSIVE configuration.\"\"\"\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n        # ULTRA AGGRESSIVE Signal parameters - GUARANTEED to generate signals\n        self.fast_ma_period = 5      # Very fast MA\n        self.slow_ma_period = 10     # Very slow MA  \n        self.min_signal_strength = 0.01  # Only 1% strength needed!",
        "detail": "strategy.signals",
        "documentation": {}
    },
    {
        "label": "SimpleScalper",
        "kind": 6,
        "importPath": "strategy.signals",
        "description": "strategy.signals",
        "peekOfCode": "class SimpleScalper:\n    \"\"\"Minimal scalper for compatibility.\"\"\"\n    def __init__(self, config: Config):\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n    async def initialize(self) -> None:\n        \"\"\"Async initialize for compatibility.\"\"\"\n        self.logger.info(\"SimpleScalper initialized\")\n    def generate_signal(self, market_data) -> Optional[TradingSignal]:\n        \"\"\"Simple scalping signal generation.\"\"\"",
        "detail": "strategy.signals",
        "documentation": {}
    },
    {
        "label": "SignalGenerator",
        "kind": 6,
        "importPath": "strategy.signals_ultra",
        "description": "strategy.signals_ultra",
        "peekOfCode": "class SignalGenerator:\n    \"\"\"Generates trading signals with ultra-low thresholds for demo trading.\"\"\"\n    def __init__(self, config: Config):\n        \"\"\"Initialize signal generator with AGGRESSIVE configuration.\"\"\"\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n        # ULTRA AGGRESSIVE Signal parameters\n        self.fast_ma_period = 3      # Very fast MA\n        self.slow_ma_period = 9      # Very slow MA  \n        self.min_signal_strength = 0.05  # Only 5% strength needed!",
        "detail": "strategy.signals_ultra",
        "documentation": {}
    },
    {
        "label": "SimpleScalper",
        "kind": 6,
        "importPath": "strategy.signals_ultra",
        "description": "strategy.signals_ultra",
        "peekOfCode": "class SimpleScalper:\n    \"\"\"Ultra aggressive scalping strategy.\"\"\"\n    def __init__(self, config: Config):\n        \"\"\"Initialize scalper with ULTRA aggressive configuration.\"\"\"\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n        # ULTRA AGGRESSIVE Scalping parameters\n        self.momentum_period = 2  # Very short period\n        self.momentum_threshold = 0.0001  # 0.01% threshold\n        self.volume_threshold = 0.5  # 50% of average volume",
        "detail": "strategy.signals_ultra",
        "documentation": {}
    },
    {
        "label": "TestConfigValidation",
        "kind": 6,
        "importPath": "tests.test_config",
        "description": "tests.test_config",
        "peekOfCode": "class TestConfigValidation:\n    \"\"\"Test configuration validation.\"\"\"\n    def test_config_defaults(self):\n        \"\"\"Test default configuration values.\"\"\"\n        with patch.dict(os.environ, {}, clear=True):\n            # Set minimum required env vars\n            with patch.dict(\n                os.environ,\n                {\"BINANCE_API_KEY\": \"test_key\", \"BINANCE_API_SECRET\": \"test_secret\"},\n            ):",
        "detail": "tests.test_config",
        "documentation": {}
    },
    {
        "label": "TestSampleDataLoader",
        "kind": 6,
        "importPath": "tests.test_core_utils",
        "description": "tests.test_core_utils",
        "peekOfCode": "class TestSampleDataLoader:\n    \"\"\"Test sample data loading functionality.\"\"\"\n    def test_get_available_symbols(self):\n        \"\"\"Test getting list of available symbols.\"\"\"\n        symbols = get_available_symbols()\n        assert isinstance(symbols, list)\n        assert len(symbols) >= 2\n        assert \"BTCUSDT\" in symbols\n        assert \"ETHUSDT\" in symbols\n    def test_load_sample_data_btc(self):",
        "detail": "tests.test_core_utils",
        "documentation": {}
    },
    {
        "label": "TestDemoTrading",
        "kind": 6,
        "importPath": "tests.test_demo_traiding",
        "description": "tests.test_demo_traiding",
        "peekOfCode": "class TestDemoTrading(unittest.TestCase):\n    \"\"\"Test demo trading functionality.\"\"\"\n    def setUp(self):\n        \"\"\"Set up test fixtures.\"\"\"\n        self.config = load_config()\n    def test_market_simulator(self):\n        \"\"\"Test market simulator functionality.\"\"\"\n        simulator = MarketSimulator(self.config)\n        simulator.initialize()\n        # Test price generation",
        "detail": "tests.test_demo_traiding",
        "documentation": {}
    },
    {
        "label": "TestSampleDataLoader",
        "kind": 6,
        "importPath": "tests.test_sample_data",
        "description": "tests.test_sample_data",
        "peekOfCode": "class TestSampleDataLoader:\n    \"\"\"Test sample data loading functionality.\"\"\"\n    def test_get_available_symbols(self):\n        \"\"\"Test getting list of available symbols.\"\"\"\n        symbols = get_available_symbols()\n        assert isinstance(symbols, list)\n        assert len(symbols) >= 2\n        assert \"BTCUSDT\" in symbols\n        assert \"ETHUSDT\" in symbols\n    def test_load_sample_data_btc(self):",
        "detail": "tests.test_sample_data",
        "documentation": {}
    },
    {
        "label": "WSManager",
        "kind": 6,
        "importPath": "ws.manager",
        "description": "ws.manager",
        "peekOfCode": "class WSManager:\n    def __init__(self, symbol: str):\n        self.symbol = symbol.upper()\n        self.ws = None\n        self.thread = None\n        self._stop = threading.Event()\n        self._using_ws = False\n        self._last_try = 0.0\n    def _on_message(self, _, msg):\n        try:",
        "detail": "ws.manager",
        "documentation": {}
    },
    {
        "label": "set_last_px",
        "kind": 2,
        "importPath": "ws.manager",
        "description": "ws.manager",
        "peekOfCode": "def set_last_px(symbol: str, px: float) -> None:\n    st = _ms(symbol); st[\"last_px\"] = float(px); st[\"ts\"] = time.time()\ndef get_last_px(symbol: str) -> float:\n    return float(_ms(symbol).get(\"last_px\") or 0.0)\nclass WSManager:\n    def __init__(self, symbol: str):\n        self.symbol = symbol.upper()\n        self.ws = None\n        self.thread = None\n        self._stop = threading.Event()",
        "detail": "ws.manager",
        "documentation": {}
    },
    {
        "label": "get_last_px",
        "kind": 2,
        "importPath": "ws.manager",
        "description": "ws.manager",
        "peekOfCode": "def get_last_px(symbol: str) -> float:\n    return float(_ms(symbol).get(\"last_px\") or 0.0)\nclass WSManager:\n    def __init__(self, symbol: str):\n        self.symbol = symbol.upper()\n        self.ws = None\n        self.thread = None\n        self._stop = threading.Event()\n        self._using_ws = False\n        self._last_try = 0.0",
        "detail": "ws.manager",
        "documentation": {}
    },
    {
        "label": "MARKET_STATE[symbol]",
        "kind": 5,
        "importPath": "ws.manager",
        "description": "ws.manager",
        "peekOfCode": "MARKET_STATE[symbol] = {\n    \"last_px\": float,\n    \"obi\": float,  # smoothed order-book imbalance\n    \"obi_raw\": float,\n    \"ts\": float,\n}\n\"\"\"\nfrom __future__ import annotations\nimport threading, time, json, inspect\nfrom typing import Optional, Dict, Any, List",
        "detail": "ws.manager",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "class Config(BaseModel):\n    \"\"\"Main configuration class with validation and type safety.\"\"\"\n    # Trading Mode\n    mode: TradingMode = Field(default=TradingMode.PAPER)\n    dry_run: bool = Field(default=True)\n    testnet: bool = Field(default=True)\n    save_reports: bool = Field(default=True)\n    # API Credentials\n    binance_api_key: str = Field(default=\"\")\n    binance_api_secret: str = Field(default=\"\")",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "load_config",
        "kind": 2,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "def load_config(env_file: str | None = None) -> Config:\n    \"\"\"Load configuration from environment variables.\"\"\"\n    global _config\n    if env_file is None:\n        env_file = Path(__file__).parent.parent / \".env\"\n    if Path(env_file).exists():\n        load_dotenv(env_file, override=True)\n    # Create config from environment\n    _config = Config()\n    return _config",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "get_config",
        "kind": 2,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "def get_config() -> Config:\n    \"\"\"Get the global configuration instance.\"\"\"\n    global _config\n    if _config is None:\n        _config = load_config()\n    return _config\n'''\nprint(\"# ==================== core/config.py ====================\")\nprint(CORE_CONFIG_PY)\nprint(\"\")",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "live_trading",
        "kind": 2,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "def live_trading(\n    symbol: str = typer.Option(\"BTCUSDT\", help=\"Trading symbol\"),\n    verbose: bool = typer.Option(False, \"--verbose\", \"-v\", help=\"Verbose output\"),\n):\n    \"\"\"Start live trading with real money.\"\"\"\n    from runner.live import LiveTradingRunner\n    config = get_config()\n    config.mode = TradingMode.LIVE\n    config.symbol = symbol\n    console.print(f\"[bold green]Starting LIVE trading for {symbol}[/bold green]\")",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "paper_trading",
        "kind": 2,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "def paper_trading(\n    symbol: str = typer.Option(\"BTCUSDT\", help=\"Trading symbol\"),\n    verbose: bool = typer.Option(False, \"--verbose\", \"-v\", help=\"Verbose output\"),\n):\n    \"\"\"Start paper trading simulation.\"\"\"\n    from runner.paper import PaperTradingRunner\n    config = get_config()\n    config.mode = TradingMode.PAPER\n    config.symbol = symbol\n    console.print(f\"[bold blue]Starting PAPER trading for {symbol}[/bold blue]\")",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "backtest",
        "kind": 2,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "def backtest(\n    symbol: str = typer.Option(\"BTCUSDT\", help=\"Trading symbol\"),\n    days: int = typer.Option(30, help=\"Days to backtest\"),\n    verbose: bool = typer.Option(False, \"--verbose\", \"-v\", help=\"Verbose output\"),\n):\n    \"\"\"Run historical backtest.\"\"\"\n    from runner.backtest import BacktestRunner\n    config = get_config()\n    config.mode = TradingMode.BACKTEST\n    config.symbol = symbol",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "PYPROJECT_TOML",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "PYPROJECT_TOML = '''[build-system]\nrequires = [\"setuptools>=61.0\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n[project]\nname = \"ai-trading-bot\"\nversion = \"2.0.0\"\ndescription = \"Optimized crypto trading bot with LSTM prediction and advanced risk management\"\nauthors = [{name = \"Factory AI\", email = \"droid@factory.ai\"}]\nlicense = {text = \"MIT\"}\nreadme = \"README.md\"",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "requires",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "requires = [\"setuptools>=61.0\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n[project]\nname = \"ai-trading-bot\"\nversion = \"2.0.0\"\ndescription = \"Optimized crypto trading bot with LSTM prediction and advanced risk management\"\nauthors = [{name = \"Factory AI\", email = \"droid@factory.ai\"}]\nlicense = {text = \"MIT\"}\nreadme = \"README.md\"\nrequires-python = \">=3.10\"",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "build-backend",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "build-backend = \"setuptools.build_meta\"\n[project]\nname = \"ai-trading-bot\"\nversion = \"2.0.0\"\ndescription = \"Optimized crypto trading bot with LSTM prediction and advanced risk management\"\nauthors = [{name = \"Factory AI\", email = \"droid@factory.ai\"}]\nlicense = {text = \"MIT\"}\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\ndependencies = [",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "name",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "name = \"ai-trading-bot\"\nversion = \"2.0.0\"\ndescription = \"Optimized crypto trading bot with LSTM prediction and advanced risk management\"\nauthors = [{name = \"Factory AI\", email = \"droid@factory.ai\"}]\nlicense = {text = \"MIT\"}\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\ndependencies = [\n    \"pandas>=2.0.0\",\n    \"numpy>=1.24.0\",",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "version",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "version = \"2.0.0\"\ndescription = \"Optimized crypto trading bot with LSTM prediction and advanced risk management\"\nauthors = [{name = \"Factory AI\", email = \"droid@factory.ai\"}]\nlicense = {text = \"MIT\"}\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\ndependencies = [\n    \"pandas>=2.0.0\",\n    \"numpy>=1.24.0\",\n    \"python-binance>=1.0.19\",",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "description",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "description = \"Optimized crypto trading bot with LSTM prediction and advanced risk management\"\nauthors = [{name = \"Factory AI\", email = \"droid@factory.ai\"}]\nlicense = {text = \"MIT\"}\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\ndependencies = [\n    \"pandas>=2.0.0\",\n    \"numpy>=1.24.0\",\n    \"python-binance>=1.0.19\",\n    \"python-dotenv>=1.0.0\",",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "authors",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "authors = [{name = \"Factory AI\", email = \"droid@factory.ai\"}]\nlicense = {text = \"MIT\"}\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\ndependencies = [\n    \"pandas>=2.0.0\",\n    \"numpy>=1.24.0\",\n    \"python-binance>=1.0.19\",\n    \"python-dotenv>=1.0.0\",\n    \"websockets>=12.0\",",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "license",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "license = {text = \"MIT\"}\nreadme = \"README.md\"\nrequires-python = \">=3.10\"\ndependencies = [\n    \"pandas>=2.0.0\",\n    \"numpy>=1.24.0\",\n    \"python-binance>=1.0.19\",\n    \"python-dotenv>=1.0.0\",\n    \"websockets>=12.0\",\n    \"requests>=2.31.0\",",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "readme",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "readme = \"README.md\"\nrequires-python = \">=3.10\"\ndependencies = [\n    \"pandas>=2.0.0\",\n    \"numpy>=1.24.0\",\n    \"python-binance>=1.0.19\",\n    \"python-dotenv>=1.0.0\",\n    \"websockets>=12.0\",\n    \"requests>=2.31.0\",\n    \"aiohttp>=3.8.0\",",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "requires-python",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "requires-python = \">=3.10\"\ndependencies = [\n    \"pandas>=2.0.0\",\n    \"numpy>=1.24.0\",\n    \"python-binance>=1.0.19\",\n    \"python-dotenv>=1.0.0\",\n    \"websockets>=12.0\",\n    \"requests>=2.31.0\",\n    \"aiohttp>=3.8.0\",\n    \"pydantic>=2.0.0\",",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "dependencies",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "dependencies = [\n    \"pandas>=2.0.0\",\n    \"numpy>=1.24.0\",\n    \"python-binance>=1.0.19\",\n    \"python-dotenv>=1.0.0\",\n    \"websockets>=12.0\",\n    \"requests>=2.31.0\",\n    \"aiohttp>=3.8.0\",\n    \"pydantic>=2.0.0\",\n    \"loguru>=0.7.0\",",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "ml",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "ml = [\n    \"torch>=2.0.0\",\n    \"scikit-learn>=1.3.0\",\n    \"openai>=1.0.0\",\n]\ndev = [\n    \"pytest>=7.4.0\",\n    \"pytest-asyncio>=0.21.0\",\n    \"black>=23.0.0\",\n    \"ruff>=0.1.0\",",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "dev",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "dev = [\n    \"pytest>=7.4.0\",\n    \"pytest-asyncio>=0.21.0\",\n    \"black>=23.0.0\",\n    \"ruff>=0.1.0\",\n    \"mypy>=1.5.0\",\n    \"pre-commit>=3.4.0\",\n]\n[project.scripts]\ntrading-bot = \"runner.cli:app\"",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "trading-bot",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "trading-bot = \"runner.cli:app\"\n[tool.setuptools.packages.find]\nwhere = [\".\"]\nexclude = [\"tests*\"]\n[tool.ruff]\ntarget-version = \"py310\"\nline-length = 88\n[tool.ruff.lint]\nselect = [\n    \"E\",  # pycodestyle errors",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "where",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "where = [\".\"]\nexclude = [\"tests*\"]\n[tool.ruff]\ntarget-version = \"py310\"\nline-length = 88\n[tool.ruff.lint]\nselect = [\n    \"E\",  # pycodestyle errors\n    \"W\",  # pycodestyle warnings\n    \"F\",  # pyflakes",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "exclude",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "exclude = [\"tests*\"]\n[tool.ruff]\ntarget-version = \"py310\"\nline-length = 88\n[tool.ruff.lint]\nselect = [\n    \"E\",  # pycodestyle errors\n    \"W\",  # pycodestyle warnings\n    \"F\",  # pyflakes\n    \"I\",  # isort",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "target-version",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "target-version = \"py310\"\nline-length = 88\n[tool.ruff.lint]\nselect = [\n    \"E\",  # pycodestyle errors\n    \"W\",  # pycodestyle warnings\n    \"F\",  # pyflakes\n    \"I\",  # isort\n    \"B\",  # flake8-bugbear\n    \"C4\", # flake8-comprehensions",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "line-length",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "line-length = 88\n[tool.ruff.lint]\nselect = [\n    \"E\",  # pycodestyle errors\n    \"W\",  # pycodestyle warnings\n    \"F\",  # pyflakes\n    \"I\",  # isort\n    \"B\",  # flake8-bugbear\n    \"C4\", # flake8-comprehensions\n    \"UP\", # pyupgrade",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "select",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "select = [\n    \"E\",  # pycodestyle errors\n    \"W\",  # pycodestyle warnings\n    \"F\",  # pyflakes\n    \"I\",  # isort\n    \"B\",  # flake8-bugbear\n    \"C4\", # flake8-comprehensions\n    \"UP\", # pyupgrade\n]\nignore = [",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "ignore",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "ignore = [\n    \"E501\",  # line too long, handled by black\n    \"B008\",  # do not perform function calls in argument defaults\n    \"C901\",  # too complex\n    \"B904\",  # raise without from inside except\n]\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\npython_files = [\"test_*.py\", \"*_test.py\"]\npython_classes = [\"Test*\"]",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "testpaths",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "testpaths = [\"tests\"]\npython_files = [\"test_*.py\", \"*_test.py\"]\npython_classes = [\"Test*\"]\npython_functions = [\"test_*\"]\naddopts = [\n    \"-ra\",\n    \"--strict-markers\",\n    \"--strict-config\",\n]\nfilterwarnings = [",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "python_files",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "python_files = [\"test_*.py\", \"*_test.py\"]\npython_classes = [\"Test*\"]\npython_functions = [\"test_*\"]\naddopts = [\n    \"-ra\",\n    \"--strict-markers\",\n    \"--strict-config\",\n]\nfilterwarnings = [\n    \"ignore::UserWarning\",",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "python_classes",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "python_classes = [\"Test*\"]\npython_functions = [\"test_*\"]\naddopts = [\n    \"-ra\",\n    \"--strict-markers\",\n    \"--strict-config\",\n]\nfilterwarnings = [\n    \"ignore::UserWarning\",\n    \"ignore::DeprecationWarning\",",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "python_functions",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "python_functions = [\"test_*\"]\naddopts = [\n    \"-ra\",\n    \"--strict-markers\",\n    \"--strict-config\",\n]\nfilterwarnings = [\n    \"ignore::UserWarning\",\n    \"ignore::DeprecationWarning\",\n]'''",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "addopts",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "addopts = [\n    \"-ra\",\n    \"--strict-markers\",\n    \"--strict-config\",\n]\nfilterwarnings = [\n    \"ignore::UserWarning\",\n    \"ignore::DeprecationWarning\",\n]'''\nprint(\"# ==================== pyproject.toml ====================\")",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "filterwarnings",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "filterwarnings = [\n    \"ignore::UserWarning\",\n    \"ignore::DeprecationWarning\",\n]'''\nprint(\"# ==================== pyproject.toml ====================\")\nprint(PYPROJECT_TOML)\nprint(\"\")\n# ==================== .env.example ====================\nENV_EXAMPLE = '''# Binance API Configuration\nBINANCE_API_KEY=your_binance_api_key_here",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "ENV_EXAMPLE",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "ENV_EXAMPLE = '''# Binance API Configuration\nBINANCE_API_KEY=your_binance_api_key_here\nBINANCE_API_SECRET=your_binance_secret_here\n# Trading Mode: paper, live, backtest  \nMODE=paper\n# Basic Settings\nTESTNET=false\nDRY_RUN=false\nSAVE_REPORTS=true\n# Trading Parameters",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "CORE_CONFIG_PY",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "CORE_CONFIG_PY = '''\"\"\"\nConfiguration management for AI Trading Bot.\nHandles environment variables, validation, and provides type-safe configuration access.\n\"\"\"\nimport os\nfrom pathlib import Path\nfrom dotenv import load_dotenv\nfrom pydantic import BaseModel, Field, field_validator\nfrom .constants import TradingMode\nclass Config(BaseModel):",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "CLI_PY",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "CLI_PY = '''#!/usr/bin/env python3\n\"\"\"\nAI Trading Bot CLI Interface\nUnified command line interface for live trading, paper trading, and backtesting.\n\"\"\"\nimport asyncio\nimport sys\nfrom pathlib import Path\nimport typer\nfrom rich.console import Console",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "console = Console()\napp = typer.Typer(name=\"trading-bot\", help=\"AI Trading Bot\")\n@app.command(\"live\")\ndef live_trading(\n    symbol: str = typer.Option(\"BTCUSDT\", help=\"Trading symbol\"),\n    verbose: bool = typer.Option(False, \"--verbose\", \"-v\", help=\"Verbose output\"),\n):\n    \"\"\"Start live trading with real money.\"\"\"\n    from runner.live import LiveTradingRunner\n    config = get_config()",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "app = typer.Typer(name=\"trading-bot\", help=\"AI Trading Bot\")\n@app.command(\"live\")\ndef live_trading(\n    symbol: str = typer.Option(\"BTCUSDT\", help=\"Trading symbol\"),\n    verbose: bool = typer.Option(False, \"--verbose\", \"-v\", help=\"Verbose output\"),\n):\n    \"\"\"Start live trading with real money.\"\"\"\n    from runner.live import LiveTradingRunner\n    config = get_config()\n    config.mode = TradingMode.LIVE",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "CORE_INIT_PY",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "CORE_INIT_PY = '''\"\"\"Core module for AI Trading Bot.\"\"\"\nfrom .config import Config, get_config, load_config\nfrom .constants import OrderSide, OrderType, TradingMode\nfrom .types import BacktestResult, MarketData, Position, Trade\nfrom .utils import calculate_position_size, format_currency, round_to_precision\n__all__ = [\n    \"Config\",\n    \"get_config\", \n    \"load_config\",\n    \"OrderSide\",",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "ALL_IN_CODE",
        "description": "ALL_IN_CODE",
        "peekOfCode": "__all__ = [\n    \"Config\",\n    \"get_config\", \n    \"load_config\",\n    \"OrderSide\",\n    \"OrderType\", \n    \"TradingMode\",\n    \"BacktestResult\",\n    \"MarketData\",\n    \"Position\",",
        "detail": "ALL_IN_CODE",
        "documentation": {}
    },
    {
        "label": "backup",
        "kind": 2,
        "importPath": "apply_bridge_call_patch",
        "description": "apply_bridge_call_patch",
        "peekOfCode": "def backup(path: Path):\n    if path.exists():\n        shutil.copy2(path, path.with_suffix(path.suffix + \".bak\"))\ndef ensure_top_imports(text: str) -> tuple[str, bool]:\n    \"\"\"Гарантируем наличие import os, import asyncio, from runner.execution import TradeExecutor.\"\"\"\n    changed = False\n    lines = text.splitlines()\n    # найдём блок импортов (первые 80 строк)\n    insert_idx = 0\n    for i, l in enumerate(lines[:80]):",
        "detail": "apply_bridge_call_patch",
        "documentation": {}
    },
    {
        "label": "ensure_top_imports",
        "kind": 2,
        "importPath": "apply_bridge_call_patch",
        "description": "apply_bridge_call_patch",
        "peekOfCode": "def ensure_top_imports(text: str) -> tuple[str, bool]:\n    \"\"\"Гарантируем наличие import os, import asyncio, from runner.execution import TradeExecutor.\"\"\"\n    changed = False\n    lines = text.splitlines()\n    # найдём блок импортов (первые 80 строк)\n    insert_idx = 0\n    for i, l in enumerate(lines[:80]):\n        if l.strip().startswith((\"import \", \"from \")):\n            insert_idx = i + 1\n        elif l.strip() in (\"\",) or l.lstrip().startswith((\"#\", '\"\"\"', \"'''\")):",
        "detail": "apply_bridge_call_patch",
        "documentation": {}
    },
    {
        "label": "inject_bridge_after_generate",
        "kind": 2,
        "importPath": "apply_bridge_call_patch",
        "description": "apply_bridge_call_patch",
        "peekOfCode": "def inject_bridge_after_generate(text: str) -> tuple[str, bool]:\n    \"\"\"\n    Ищем присваивание вида:    <sigvar> = ...generate_signal(...)\n    и вставляем мост сразу после этой строки (с корректным отступом).\n    \"\"\"\n    if \"ORDER BRIDGE: executor path\" in text:\n        return text, False  # уже вставлено\n    lines = text.splitlines()\n    pattern = re.compile(r\"^(\\s*)(\\w+)\\s*=\\s*.*generate_signal\\s*\\(\", re.IGNORECASE)\n    for idx, line in enumerate(lines):",
        "detail": "apply_bridge_call_patch",
        "documentation": {}
    },
    {
        "label": "ensure_executor_init_and_bind",
        "kind": 2,
        "importPath": "apply_bridge_call_patch",
        "description": "apply_bridge_call_patch",
        "peekOfCode": "def ensure_executor_init_and_bind(text: str) -> tuple[str, bool]:\n    \"\"\"\n    На случай, если previous patch не применился:\n    - создаём self.trade_executor = TradeExecutor() в __init__ (если нет)\n    - после присвоения self.client = ... добавляем привязку к исполнителю\n    \"\"\"\n    changed = False\n    t = text\n    # 1) ensure executor init\n    if \"self.trade_executor = TradeExecutor()\" not in t:",
        "detail": "apply_bridge_call_patch",
        "documentation": {}
    },
    {
        "label": "patch_runner",
        "kind": 2,
        "importPath": "apply_bridge_call_patch",
        "description": "apply_bridge_call_patch",
        "peekOfCode": "def patch_runner(p: Path) -> bool:\n    if not p.exists():\n        print(f\"{WARN} {p} not found, skip\")\n        return False\n    backup(p)\n    txt = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    any_change = False\n    txt1, ch1 = ensure_top_imports(txt); any_change |= ch1\n    txt2, ch2 = inject_bridge_after_generate(txt1); any_change |= ch2\n    txt3, ch3 = ensure_executor_init_and_bind(txt2); any_change |= ch3",
        "detail": "apply_bridge_call_patch",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_bridge_call_patch",
        "description": "apply_bridge_call_patch",
        "peekOfCode": "def main():\n    changed = 0\n    for rel in (\"runner/paper.py\", \"runner/live.py\"):\n        p = BASE / rel\n        if patch_runner(p):\n            changed += 1\n    print(\"\\nSummary:\")\n    print(f\"  Patched files: {changed}\")\n    print(\"\\nDone.\")\nif __name__ == \"__main__\":",
        "detail": "apply_bridge_call_patch",
        "documentation": {}
    },
    {
        "label": "OK",
        "kind": 5,
        "importPath": "apply_bridge_call_patch",
        "description": "apply_bridge_call_patch",
        "peekOfCode": "OK = \"\\u2705\"\nWARN = \"\\u26A0\\uFE0F\"\nBASE = Path(__file__).resolve().parent  # предполагаем запуск из crypto_trading_bot/work\nBRIDGE_SNIPPET_TEMPLATE = \"\"\"{indent}# ORDER BRIDGE: executor path (idempotent)\n{indent}try:\n{indent}    _bridge_enabled = (getattr(self.config, \"order_bridge_enable\", False) or os.getenv(\"ORDER_BRIDGE_ENABLE\",\"false\").lower()==\"true\")\n{indent}    if _bridge_enabled and {sigvar} and isinstance({sigvar}, dict) and {sigvar}.get(\"signal_type\") in (\"BUY\",\"SELL\"):\n{indent}        # лениво привязываем клиента к исполнителю, если ещё не привязан\n{indent}        if getattr(self, \"trade_executor\", None) and getattr(self.trade_executor, \"client\", None) is None and getattr(self, \"client\", None):\n{indent}            self.trade_executor.client = self.client",
        "detail": "apply_bridge_call_patch",
        "documentation": {}
    },
    {
        "label": "WARN",
        "kind": 5,
        "importPath": "apply_bridge_call_patch",
        "description": "apply_bridge_call_patch",
        "peekOfCode": "WARN = \"\\u26A0\\uFE0F\"\nBASE = Path(__file__).resolve().parent  # предполагаем запуск из crypto_trading_bot/work\nBRIDGE_SNIPPET_TEMPLATE = \"\"\"{indent}# ORDER BRIDGE: executor path (idempotent)\n{indent}try:\n{indent}    _bridge_enabled = (getattr(self.config, \"order_bridge_enable\", False) or os.getenv(\"ORDER_BRIDGE_ENABLE\",\"false\").lower()==\"true\")\n{indent}    if _bridge_enabled and {sigvar} and isinstance({sigvar}, dict) and {sigvar}.get(\"signal_type\") in (\"BUY\",\"SELL\"):\n{indent}        # лениво привязываем клиента к исполнителю, если ещё не привязан\n{indent}        if getattr(self, \"trade_executor\", None) and getattr(self.trade_executor, \"client\", None) is None and getattr(self, \"client\", None):\n{indent}            self.trade_executor.client = self.client\n{indent}        res = await asyncio.to_thread(",
        "detail": "apply_bridge_call_patch",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "apply_bridge_call_patch",
        "description": "apply_bridge_call_patch",
        "peekOfCode": "BASE = Path(__file__).resolve().parent  # предполагаем запуск из crypto_trading_bot/work\nBRIDGE_SNIPPET_TEMPLATE = \"\"\"{indent}# ORDER BRIDGE: executor path (idempotent)\n{indent}try:\n{indent}    _bridge_enabled = (getattr(self.config, \"order_bridge_enable\", False) or os.getenv(\"ORDER_BRIDGE_ENABLE\",\"false\").lower()==\"true\")\n{indent}    if _bridge_enabled and {sigvar} and isinstance({sigvar}, dict) and {sigvar}.get(\"signal_type\") in (\"BUY\",\"SELL\"):\n{indent}        # лениво привязываем клиента к исполнителю, если ещё не привязан\n{indent}        if getattr(self, \"trade_executor\", None) and getattr(self.trade_executor, \"client\", None) is None and getattr(self, \"client\", None):\n{indent}            self.trade_executor.client = self.client\n{indent}        res = await asyncio.to_thread(\n{indent}            self.trade_executor.handle_signal,",
        "detail": "apply_bridge_call_patch",
        "documentation": {}
    },
    {
        "label": "BRIDGE_SNIPPET_TEMPLATE",
        "kind": 5,
        "importPath": "apply_bridge_call_patch",
        "description": "apply_bridge_call_patch",
        "peekOfCode": "BRIDGE_SNIPPET_TEMPLATE = \"\"\"{indent}# ORDER BRIDGE: executor path (idempotent)\n{indent}try:\n{indent}    _bridge_enabled = (getattr(self.config, \"order_bridge_enable\", False) or os.getenv(\"ORDER_BRIDGE_ENABLE\",\"false\").lower()==\"true\")\n{indent}    if _bridge_enabled and {sigvar} and isinstance({sigvar}, dict) and {sigvar}.get(\"signal_type\") in (\"BUY\",\"SELL\"):\n{indent}        # лениво привязываем клиента к исполнителю, если ещё не привязан\n{indent}        if getattr(self, \"trade_executor\", None) and getattr(self.trade_executor, \"client\", None) is None and getattr(self, \"client\", None):\n{indent}            self.trade_executor.client = self.client\n{indent}        res = await asyncio.to_thread(\n{indent}            self.trade_executor.handle_signal,\n{indent}            symbol,",
        "detail": "apply_bridge_call_patch",
        "documentation": {}
    },
    {
        "label": "backup",
        "kind": 2,
        "importPath": "apply_cli_and_live_hotfix_all_in_one",
        "description": "apply_cli_and_live_hotfix_all_in_one",
        "peekOfCode": "def backup(path: Path):\n    if path.exists():\n        bk = path.with_suffix(path.suffix + \".bak_unified\")\n        try:\n            bk.write_bytes(path.read_bytes())\n            print(f\"📦 Backup: {path.relative_to(ROOT)} -> {bk.name}\")\n        except Exception as e:\n            print(f\"⚠️  Backup failed for {path}: {e}\")\ndef write_cli_integrated():\n    \"\"\"Полная замена cli_integrated.py корректной реализацией.\"\"\"",
        "detail": "apply_cli_and_live_hotfix_all_in_one",
        "documentation": {}
    },
    {
        "label": "write_cli_integrated",
        "kind": 2,
        "importPath": "apply_cli_and_live_hotfix_all_in_one",
        "description": "apply_cli_and_live_hotfix_all_in_one",
        "peekOfCode": "def write_cli_integrated():\n    \"\"\"Полная замена cli_integrated.py корректной реализацией.\"\"\"\n    target = ROOT / \"cli_integrated.py\"\n    backup(target)\n    code = dedent(r\"\"\"\n    # -*- coding: utf-8 -*-\n    from __future__ import annotations\n    import os\n    import sys\n    import asyncio",
        "detail": "apply_cli_and_live_hotfix_all_in_one",
        "documentation": {}
    },
    {
        "label": "patch_runner_live",
        "kind": 2,
        "importPath": "apply_cli_and_live_hotfix_all_in_one",
        "description": "apply_cli_and_live_hotfix_all_in_one",
        "peekOfCode": "def patch_runner_live():\n    \"\"\"Фиксы для runner/live.py: getattr и безопасный min_account_balance.\"\"\"\n    target = ROOT / \"runner\" / \"live.py\"\n    if not target.exists():\n        print(\"ℹ️  runner/live.py not found — skip\")\n        return\n    backup(target)\n    txt = target.read_text(encoding=\"utf-8\")\n    # 1) Грубая правка ошибочного вызова self.getattr(...)\n    txt = txt.replace(\"self.getattr(\", \"getattr(\")",
        "detail": "apply_cli_and_live_hotfix_all_in_one",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_cli_and_live_hotfix_all_in_one",
        "description": "apply_cli_and_live_hotfix_all_in_one",
        "peekOfCode": "def main():\n    write_cli_integrated()\n    patch_runner_live()\n    print(\"\\nDone. Now try:\")\n    print(\"  python cli_integrated.py paper --config .env.testnet --symbols BTCUSDT --verbose\")\n    print(\"  python cli_integrated.py live --config .env.testnet --symbols BTCUSDT,ETHUSDT --dry-run --testnet --verbose\")\nif __name__ == \"__main__\":\n    main()",
        "detail": "apply_cli_and_live_hotfix_all_in_one",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "kind": 5,
        "importPath": "apply_cli_and_live_hotfix_all_in_one",
        "description": "apply_cli_and_live_hotfix_all_in_one",
        "peekOfCode": "ROOT = Path(__file__).resolve().parent\ndef backup(path: Path):\n    if path.exists():\n        bk = path.with_suffix(path.suffix + \".bak_unified\")\n        try:\n            bk.write_bytes(path.read_bytes())\n            print(f\"📦 Backup: {path.relative_to(ROOT)} -> {bk.name}\")\n        except Exception as e:\n            print(f\"⚠️  Backup failed for {path}: {e}\")\ndef write_cli_integrated():",
        "detail": "apply_cli_and_live_hotfix_all_in_one",
        "documentation": {}
    },
    {
        "label": "backup",
        "kind": 2,
        "importPath": "apply_cli_live_rescue_v5",
        "description": "apply_cli_live_rescue_v5",
        "peekOfCode": "def backup(path: Path):\n    if path.exists():\n        ts = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        b = path.with_suffix(path.suffix + f\".bak_rescue_{ts}\")\n        b.write_bytes(path.read_bytes())\n        return b\n    return None\ndef write_file(path: Path, text: str):\n    path.parent.mkdir(parents=True, exist_ok=True)\n    backup(path)",
        "detail": "apply_cli_live_rescue_v5",
        "documentation": {}
    },
    {
        "label": "write_file",
        "kind": 2,
        "importPath": "apply_cli_live_rescue_v5",
        "description": "apply_cli_live_rescue_v5",
        "peekOfCode": "def write_file(path: Path, text: str):\n    path.parent.mkdir(parents=True, exist_ok=True)\n    backup(path)\n    path.write_text(text, encoding=\"utf-8\")\ndef patch_live_py(path: Path):\n    if not path.exists():\n        print(f\"⚠ runner/live.py not found: {path}\")\n        return False\n    src = path.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    orig = src",
        "detail": "apply_cli_live_rescue_v5",
        "documentation": {}
    },
    {
        "label": "patch_live_py",
        "kind": 2,
        "importPath": "apply_cli_live_rescue_v5",
        "description": "apply_cli_live_rescue_v5",
        "peekOfCode": "def patch_live_py(path: Path):\n    if not path.exists():\n        print(f\"⚠ runner/live.py not found: {path}\")\n        return False\n    src = path.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    orig = src\n    # 1) лечим self.getattr(...) -> getattr(self.config, ...)\n    # самые частые варианты:\n    src = src.replace(\"self.getattr(config, 'min_account_balance', 0.0)\",\n                      \"getattr(self.config, 'min_account_balance', 0.0)\")",
        "detail": "apply_cli_live_rescue_v5",
        "documentation": {}
    },
    {
        "label": "patch_utils_py",
        "kind": 2,
        "importPath": "apply_cli_live_rescue_v5",
        "description": "apply_cli_live_rescue_v5",
        "peekOfCode": "def patch_utils_py(path: Path):\n    path.parent.mkdir(parents=True, exist_ok=True)\n    if not path.exists():\n        # создадим минимальный utils с нужными функциями\n        content = dedent(\"\"\"\\\n        # core/utils.py (rescued minimal helpers)\n        # ASCII only helpers to avoid encoding issues.\n        def validate_symbol(symbol: str) -> str:\n            if symbol is None:\n                return \"\"",
        "detail": "apply_cli_live_rescue_v5",
        "documentation": {}
    },
    {
        "label": "write_cli_integrated",
        "kind": 2,
        "importPath": "apply_cli_live_rescue_v5",
        "description": "apply_cli_live_rescue_v5",
        "peekOfCode": "def write_cli_integrated(path: Path):\n    content = dedent(\"\"\"\\\n    #!/usr/bin/env python3\n    # -*- coding: utf-8 -*-\n    \\\"\\\"\\\"\n    Stable CLI (rescue) for paper/live modes.\n    - Supports: --config, --symbols, --dry-run, --testnet, --timeframe, --verbose\n    - No fancy unicode, only ASCII to avoid SyntaxErrors.\n    \\\"\\\"\\\"\n    import os",
        "detail": "apply_cli_live_rescue_v5",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_cli_live_rescue_v5",
        "description": "apply_cli_live_rescue_v5",
        "peekOfCode": "def main():\n    print(\"Applying CLI + live fixes...\")\n    changed_any = False\n    # 1) CLI: перезаписываем полностью стабильной версией\n    cli_path = BASE / \"cli_integrated.py\"\n    write_cli_integrated(cli_path)\n    print(f\"✅ Patched {cli_path.name}\")\n    changed_any = True\n    # 2) runner/live.py: точечная правка getattr\n    live_path = BASE / \"runner\" / \"live.py\"",
        "detail": "apply_cli_live_rescue_v5",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "apply_cli_live_rescue_v5",
        "description": "apply_cli_live_rescue_v5",
        "peekOfCode": "BASE = Path(__file__).resolve().parent\ndef backup(path: Path):\n    if path.exists():\n        ts = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        b = path.with_suffix(path.suffix + f\".bak_rescue_{ts}\")\n        b.write_bytes(path.read_bytes())\n        return b\n    return None\ndef write_file(path: Path, text: str):\n    path.parent.mkdir(parents=True, exist_ok=True)",
        "detail": "apply_cli_live_rescue_v5",
        "documentation": {}
    },
    {
        "label": "backup",
        "kind": 2,
        "importPath": "apply_cli_updated_rescue_patch",
        "description": "apply_cli_updated_rescue_patch",
        "peekOfCode": "def backup(p: Path, suf: str):\n    if p.exists():\n        bk = p.with_suffix(p.suffix + suf)\n        shutil.copy2(p, bk)\n        return bk.name\n    return None\ndef insert_helper(txt: str) -> str:\n    if \"_imba_apply_env_overrides(\" in txt:\n        return txt\n    lines = txt.splitlines(True)",
        "detail": "apply_cli_updated_rescue_patch",
        "documentation": {}
    },
    {
        "label": "insert_helper",
        "kind": 2,
        "importPath": "apply_cli_updated_rescue_patch",
        "description": "apply_cli_updated_rescue_patch",
        "peekOfCode": "def insert_helper(txt: str) -> str:\n    if \"_imba_apply_env_overrides(\" in txt:\n        return txt\n    lines = txt.splitlines(True)\n    # вставим после импортов\n    ins = 0\n    for i,l in enumerate(lines[:300]):\n        if l.strip().startswith((\"import \",\"from \")):\n            ins = i+1\n        elif l.strip()==\"\" or l.strip().startswith((\"#\",\"'''\",'\"\"\"')):",
        "detail": "apply_cli_updated_rescue_patch",
        "documentation": {}
    },
    {
        "label": "inject_call_before_asyncio",
        "kind": 2,
        "importPath": "apply_cli_updated_rescue_patch",
        "description": "apply_cli_updated_rescue_patch",
        "peekOfCode": "def inject_call_before_asyncio(txt: str, func_name: str, runner_call: str) -> str:\n    # Ищем def ...:  и строку asyncio.run(run_...(config))\n    # Вставим _imba_apply_env_overrides(config) за пару строк до asyncio.run(...)\n    pat_func = re.compile(rf\"(^\\s*def\\s+{func_name}\\s*\\(.*?\\):\\s*$)\", re.M)\n    m = pat_func.search(txt)\n    if not m:\n        return txt\n    start = m.end()\n    # ограничим область поиска телом функции до следующей \"def \" на той же колонке или EOF\n    next_def = re.search(r\"^\\s*def\\s+\\w+\\s*\\(\", txt[start:], re.M)",
        "detail": "apply_cli_updated_rescue_patch",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_cli_updated_rescue_patch",
        "description": "apply_cli_updated_rescue_patch",
        "peekOfCode": "def main():\n    if not TARGET.exists():\n        print(f\"{WARN} {TARGET.name} not found — nothing to patch\"); return\n    src = TARGET.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    out = insert_helper(src)\n    out2 = inject_call_before_asyncio(out, \"paper\", \"run_paper_trading(config)\")\n    out3 = inject_call_before_asyncio(out2, \"live\",  \"run_live_trading(config)\")\n    if out3 != src:\n        bk = backup(TARGET, \".bak_cliupd_rescue\")\n        TARGET.write_text(out3, encoding=\"utf-8\")",
        "detail": "apply_cli_updated_rescue_patch",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "apply_cli_updated_rescue_patch",
        "description": "apply_cli_updated_rescue_patch",
        "peekOfCode": "BASE = Path(__file__).resolve().parent\nTARGET = BASE/\"cli_updated.py\"\nHELPER = r'''\n# --- IMBA: apply env overrides for TESTNET/DRY_RUN (rescue, idempotent) ---\nimport os as _imba_os\ndef _imba_env_bool(name: str):\n    v = _imba_os.getenv(name, None)\n    if v is None: return None\n    return str(v).strip().lower() in {\"1\",\"true\",\"t\",\"yes\",\"y\",\"on\"}\ndef _imba_apply_env_overrides(cfg):",
        "detail": "apply_cli_updated_rescue_patch",
        "documentation": {}
    },
    {
        "label": "TARGET",
        "kind": 5,
        "importPath": "apply_cli_updated_rescue_patch",
        "description": "apply_cli_updated_rescue_patch",
        "peekOfCode": "TARGET = BASE/\"cli_updated.py\"\nHELPER = r'''\n# --- IMBA: apply env overrides for TESTNET/DRY_RUN (rescue, idempotent) ---\nimport os as _imba_os\ndef _imba_env_bool(name: str):\n    v = _imba_os.getenv(name, None)\n    if v is None: return None\n    return str(v).strip().lower() in {\"1\",\"true\",\"t\",\"yes\",\"y\",\"on\"}\ndef _imba_apply_env_overrides(cfg):\n    try:",
        "detail": "apply_cli_updated_rescue_patch",
        "documentation": {}
    },
    {
        "label": "HELPER",
        "kind": 5,
        "importPath": "apply_cli_updated_rescue_patch",
        "description": "apply_cli_updated_rescue_patch",
        "peekOfCode": "HELPER = r'''\n# --- IMBA: apply env overrides for TESTNET/DRY_RUN (rescue, idempotent) ---\nimport os as _imba_os\ndef _imba_env_bool(name: str):\n    v = _imba_os.getenv(name, None)\n    if v is None: return None\n    return str(v).strip().lower() in {\"1\",\"true\",\"t\",\"yes\",\"y\",\"on\"}\ndef _imba_apply_env_overrides(cfg):\n    try:\n        et = _imba_env_bool(\"TESTNET\")",
        "detail": "apply_cli_updated_rescue_patch",
        "documentation": {}
    },
    {
        "label": "integrate_block",
        "kind": 2,
        "importPath": "apply_compat_signal_side_map_patch",
        "description": "apply_compat_signal_side_map_patch",
        "peekOfCode": "def integrate_block(txt: str) -> str:\n    if PATCH_TAG in txt:\n        return txt\n    # вставим блок после импортов\n    lines = txt.splitlines(True)\n    ins = 0\n    for i,l in enumerate(lines[:200]):\n        if l.strip().startswith((\"import \",\"from \")):\n            ins = i+1\n        elif l.strip()==\"\" or l.lstrip().startswith((\"#\",'\"\"\"',\"'''\")):",
        "detail": "apply_compat_signal_side_map_patch",
        "documentation": {}
    },
    {
        "label": "integrate_usage",
        "kind": 2,
        "importPath": "apply_compat_signal_side_map_patch",
        "description": "apply_compat_signal_side_map_patch",
        "peekOfCode": "def integrate_usage(txt: str) -> str:\n    # заменим места, где строится normalized signal_type, на вызов _compat_map_side(...)\n    # самые частые варианты:\n    txt2 = re.sub(r\"(signal_type\\s*=\\s*)str\\(\\s*sig(?:nal)?\\s*\\)\\.upper\\(\\)\", r\"\\1_compat_map_side(sig)\", txt)\n    txt2 = re.sub(r\"(signal_type\\s*=\\s*)str\\(\\s*side\\s*\\)\\.upper\\(\\)\", r\"\\1_compat_map_side(side)\", txt2)\n    # если логи формируются напрямую — поправим сообщение «BUY»/«SELL» -> маппинга\n    txt2 = re.sub(r'(\"signal_type\"\\s*:\\s*)str\\(\\s*sig(?:nal)?\\s*\\)\\.upper\\(\\)', r'\\1_compat_map_side(sig)', txt2)\n    return txt2\ndef patch_one(p: Path):\n    if not p.exists():",
        "detail": "apply_compat_signal_side_map_patch",
        "documentation": {}
    },
    {
        "label": "patch_one",
        "kind": 2,
        "importPath": "apply_compat_signal_side_map_patch",
        "description": "apply_compat_signal_side_map_patch",
        "peekOfCode": "def patch_one(p: Path):\n    if not p.exists():\n        print(f\"{WARN} {p} not found\"); return\n    src = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    new = integrate_usage(integrate_block(src))\n    if new != src:\n        backup = p.with_suffix(p.suffix + \".bak_sidemap\")\n        shutil.copy2(p, backup)\n        p.write_text(new, encoding=\"utf-8\")\n        print(f\"{OK} Patched {p.name} ({PATCH_TAG}), backup: {backup.name}\")",
        "detail": "apply_compat_signal_side_map_patch",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_compat_signal_side_map_patch",
        "description": "apply_compat_signal_side_map_patch",
        "peekOfCode": "def main():\n    any_ = False\n    for c in CAND:\n        if c.exists():\n            any_ = True; patch_one(c)\n    if not any_:\n        print(f\"{WARN} compat file not found\")\n    else:\n        print(\"\\nDone.\")\nif __name__ == \"__main__\":",
        "detail": "apply_compat_signal_side_map_patch",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "apply_compat_signal_side_map_patch",
        "description": "apply_compat_signal_side_map_patch",
        "peekOfCode": "BASE = Path(__file__).resolve().parent\nCAND = [BASE/\"compat_complete.py\", BASE/\"compat.py\"]\nPATCH_TAG = \"COMPAT SIGNAL SIDE MAP PATCH\"\nBLOCK = r'''\n# --- {tag} ---\ndef _compat_map_side(side: str) -> str:\n    s = str(side or \"\").strip().upper()\n    if s in (\"BUY\", \"LONG\", \"L\"):   return \"LONG\"\n    if s in (\"SELL\",\"SHORT\",\"S\"):   return \"SHORT\"\n    return \"NONE\"",
        "detail": "apply_compat_signal_side_map_patch",
        "documentation": {}
    },
    {
        "label": "CAND",
        "kind": 5,
        "importPath": "apply_compat_signal_side_map_patch",
        "description": "apply_compat_signal_side_map_patch",
        "peekOfCode": "CAND = [BASE/\"compat_complete.py\", BASE/\"compat.py\"]\nPATCH_TAG = \"COMPAT SIGNAL SIDE MAP PATCH\"\nBLOCK = r'''\n# --- {tag} ---\ndef _compat_map_side(side: str) -> str:\n    s = str(side or \"\").strip().upper()\n    if s in (\"BUY\", \"LONG\", \"L\"):   return \"LONG\"\n    if s in (\"SELL\",\"SHORT\",\"S\"):   return \"SHORT\"\n    return \"NONE\"\n# (интегрировать этот маппер в месте, где формируется normalized signal)",
        "detail": "apply_compat_signal_side_map_patch",
        "documentation": {}
    },
    {
        "label": "PATCH_TAG",
        "kind": 5,
        "importPath": "apply_compat_signal_side_map_patch",
        "description": "apply_compat_signal_side_map_patch",
        "peekOfCode": "PATCH_TAG = \"COMPAT SIGNAL SIDE MAP PATCH\"\nBLOCK = r'''\n# --- {tag} ---\ndef _compat_map_side(side: str) -> str:\n    s = str(side or \"\").strip().upper()\n    if s in (\"BUY\", \"LONG\", \"L\"):   return \"LONG\"\n    if s in (\"SELL\",\"SHORT\",\"S\"):   return \"SHORT\"\n    return \"NONE\"\n# (интегрировать этот маппер в месте, где формируется normalized signal)\n'''.format(tag=PATCH_TAG)",
        "detail": "apply_compat_signal_side_map_patch",
        "documentation": {}
    },
    {
        "label": "BLOCK",
        "kind": 5,
        "importPath": "apply_compat_signal_side_map_patch",
        "description": "apply_compat_signal_side_map_patch",
        "peekOfCode": "BLOCK = r'''\n# --- {tag} ---\ndef _compat_map_side(side: str) -> str:\n    s = str(side or \"\").strip().upper()\n    if s in (\"BUY\", \"LONG\", \"L\"):   return \"LONG\"\n    if s in (\"SELL\",\"SHORT\",\"S\"):   return \"SHORT\"\n    return \"NONE\"\n# (интегрировать этот маппер в месте, где формируется normalized signal)\n'''.format(tag=PATCH_TAG)\ndef integrate_block(txt: str) -> str:",
        "detail": "apply_compat_signal_side_map_patch",
        "documentation": {}
    },
    {
        "label": "backup",
        "kind": 2,
        "importPath": "apply_compat_sig_global_patch",
        "description": "apply_compat_sig_global_patch",
        "peekOfCode": "def backup(p: Path, suf=\".bak_sigbuiltins\"):\n    if p.exists(): shutil.copy2(p, p.with_suffix(p.suffix + suf))\ndef insert_guard(txt: str) -> tuple[str,bool]:\n    if \"GLOBAL SIG GUARD (builtins\" in txt:\n        return txt, False\n    lines = txt.splitlines()\n    ins_idx = 0\n    # shebang/encoding\n    if ins_idx < len(lines) and lines[ins_idx].startswith(\"#!\"):\n        ins_idx += 1",
        "detail": "apply_compat_sig_global_patch",
        "documentation": {}
    },
    {
        "label": "insert_guard",
        "kind": 2,
        "importPath": "apply_compat_sig_global_patch",
        "description": "apply_compat_sig_global_patch",
        "peekOfCode": "def insert_guard(txt: str) -> tuple[str,bool]:\n    if \"GLOBAL SIG GUARD (builtins\" in txt:\n        return txt, False\n    lines = txt.splitlines()\n    ins_idx = 0\n    # shebang/encoding\n    if ins_idx < len(lines) and lines[ins_idx].startswith(\"#!\"):\n        ins_idx += 1\n    if ins_idx < len(lines) and \"coding\" in lines[ins_idx]:\n        ins_idx += 1",
        "detail": "apply_compat_sig_global_patch",
        "documentation": {}
    },
    {
        "label": "patch_one",
        "kind": 2,
        "importPath": "apply_compat_sig_global_patch",
        "description": "apply_compat_sig_global_patch",
        "peekOfCode": "def patch_one(p: Path):\n    if not p.exists(): \n        print(f\"{WARN} {p.name} not found, skip\"); \n        return\n    src = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    new, changed = insert_guard(src)\n    if changed:\n        backup(p)\n        p.write_text(new, encoding=\"utf-8\")\n        print(f\"{OK} Patched {p.name} (global sig guard)\")",
        "detail": "apply_compat_sig_global_patch",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_compat_sig_global_patch",
        "description": "apply_compat_sig_global_patch",
        "peekOfCode": "def main():\n    any_found = False\n    for f in CANDIDATES:\n        if f.exists():\n            any_found = True\n            patch_one(f)\n    if not any_found:\n        print(f\"{WARN} compat file not found (looked for: {', '.join(x.name for x in CANDIDATES)})\")\n    else:\n        print(\"\\nDone.\")",
        "detail": "apply_compat_sig_global_patch",
        "documentation": {}
    },
    {
        "label": "WARN",
        "kind": 5,
        "importPath": "apply_compat_sig_global_patch",
        "description": "apply_compat_sig_global_patch",
        "peekOfCode": "WARN = \"\\u26A0\\uFE0F\"\nBASE = Path(__file__).resolve().parent\nCANDIDATES = [BASE/\"compat_complete.py\", BASE/\"compat.py\"]\nBLOCK = \"\"\"# --- GLOBAL SIG GUARD (builtins, idempotent) ---\nimport builtins as _blt\nif not hasattr(_blt, \"sig\"):\n    _blt.sig = None\nif not hasattr(_blt, \"signal\"):\n    _blt.signal = None\nif not hasattr(_blt, \"trade_signal\"):",
        "detail": "apply_compat_sig_global_patch",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "apply_compat_sig_global_patch",
        "description": "apply_compat_sig_global_patch",
        "peekOfCode": "BASE = Path(__file__).resolve().parent\nCANDIDATES = [BASE/\"compat_complete.py\", BASE/\"compat.py\"]\nBLOCK = \"\"\"# --- GLOBAL SIG GUARD (builtins, idempotent) ---\nimport builtins as _blt\nif not hasattr(_blt, \"sig\"):\n    _blt.sig = None\nif not hasattr(_blt, \"signal\"):\n    _blt.signal = None\nif not hasattr(_blt, \"trade_signal\"):\n    _blt.trade_signal = None",
        "detail": "apply_compat_sig_global_patch",
        "documentation": {}
    },
    {
        "label": "CANDIDATES",
        "kind": 5,
        "importPath": "apply_compat_sig_global_patch",
        "description": "apply_compat_sig_global_patch",
        "peekOfCode": "CANDIDATES = [BASE/\"compat_complete.py\", BASE/\"compat.py\"]\nBLOCK = \"\"\"# --- GLOBAL SIG GUARD (builtins, idempotent) ---\nimport builtins as _blt\nif not hasattr(_blt, \"sig\"):\n    _blt.sig = None\nif not hasattr(_blt, \"signal\"):\n    _blt.signal = None\nif not hasattr(_blt, \"trade_signal\"):\n    _blt.trade_signal = None\n\"\"\"",
        "detail": "apply_compat_sig_global_patch",
        "documentation": {}
    },
    {
        "label": "BLOCK",
        "kind": 5,
        "importPath": "apply_compat_sig_global_patch",
        "description": "apply_compat_sig_global_patch",
        "peekOfCode": "BLOCK = \"\"\"# --- GLOBAL SIG GUARD (builtins, idempotent) ---\nimport builtins as _blt\nif not hasattr(_blt, \"sig\"):\n    _blt.sig = None\nif not hasattr(_blt, \"signal\"):\n    _blt.signal = None\nif not hasattr(_blt, \"trade_signal\"):\n    _blt.trade_signal = None\n\"\"\"\ndef backup(p: Path, suf=\".bak_sigbuiltins\"):",
        "detail": "apply_compat_sig_global_patch",
        "documentation": {}
    },
    {
        "label": "backup",
        "kind": 2,
        "importPath": "apply_compat_timesync_balance_patch",
        "description": "apply_compat_timesync_balance_patch",
        "peekOfCode": "def backup(p: Path, suf=\".bak_timesync\"):\n    if p.exists():\n        shutil.copy2(p, p.with_suffix(p.suffix + suf))\ndef patch_one(path: Path):\n    if not path.exists():\n        print(f\"{WARN} {path.name} not found, skip\")\n        return\n    src = path.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    if \"COMPAT PATCH: BinanceClient.get_account_balance with time-sync\" in src:\n        print(f\"{OK} {path.name} — patch already present\")",
        "detail": "apply_compat_timesync_balance_patch",
        "documentation": {}
    },
    {
        "label": "patch_one",
        "kind": 2,
        "importPath": "apply_compat_timesync_balance_patch",
        "description": "apply_compat_timesync_balance_patch",
        "peekOfCode": "def patch_one(path: Path):\n    if not path.exists():\n        print(f\"{WARN} {path.name} not found, skip\")\n        return\n    src = path.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    if \"COMPAT PATCH: BinanceClient.get_account_balance with time-sync\" in src:\n        print(f\"{OK} {path.name} — patch already present\")\n        return\n    # Вставим в конец файла (безопасно для compat-модуля)\n    backup(path)",
        "detail": "apply_compat_timesync_balance_patch",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_compat_timesync_balance_patch",
        "description": "apply_compat_timesync_balance_patch",
        "peekOfCode": "def main():\n    any_found = False\n    for p in TARGETS:\n        if p.exists():\n            any_found = True\n            patch_one(p)\n    if not any_found:\n        print(f\"{WARN} compat file not found (looked for: {[t.name for t in TARGETS]})\")\n    else:\n        print(\"\\nDone.\")",
        "detail": "apply_compat_timesync_balance_patch",
        "documentation": {}
    },
    {
        "label": "WARN",
        "kind": 5,
        "importPath": "apply_compat_timesync_balance_patch",
        "description": "apply_compat_timesync_balance_patch",
        "peekOfCode": "WARN = \"\\u26A0\\uFE0F\"\nBASE = Path(__file__).resolve().parent\nTARGETS = [BASE/\"compat_complete.py\", BASE/\"compat.py\"]\nBLOCK = r'''\n# === COMPAT PATCH: BinanceClient.get_account_balance with time-sync & DRY_RUN stub (idempotent) ===\ntry:\n    import os, time, hmac, hashlib, logging, requests, urllib.parse\n    from core.config import get_config\n    from exchange.client import BinanceClient\n    _clog = logging.getLogger(\"compat\")",
        "detail": "apply_compat_timesync_balance_patch",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "apply_compat_timesync_balance_patch",
        "description": "apply_compat_timesync_balance_patch",
        "peekOfCode": "BASE = Path(__file__).resolve().parent\nTARGETS = [BASE/\"compat_complete.py\", BASE/\"compat.py\"]\nBLOCK = r'''\n# === COMPAT PATCH: BinanceClient.get_account_balance with time-sync & DRY_RUN stub (idempotent) ===\ntry:\n    import os, time, hmac, hashlib, logging, requests, urllib.parse\n    from core.config import get_config\n    from exchange.client import BinanceClient\n    _clog = logging.getLogger(\"compat\")\n    def _compat__ensure_time_offset_ms(base_url: str):",
        "detail": "apply_compat_timesync_balance_patch",
        "documentation": {}
    },
    {
        "label": "TARGETS",
        "kind": 5,
        "importPath": "apply_compat_timesync_balance_patch",
        "description": "apply_compat_timesync_balance_patch",
        "peekOfCode": "TARGETS = [BASE/\"compat_complete.py\", BASE/\"compat.py\"]\nBLOCK = r'''\n# === COMPAT PATCH: BinanceClient.get_account_balance with time-sync & DRY_RUN stub (idempotent) ===\ntry:\n    import os, time, hmac, hashlib, logging, requests, urllib.parse\n    from core.config import get_config\n    from exchange.client import BinanceClient\n    _clog = logging.getLogger(\"compat\")\n    def _compat__ensure_time_offset_ms(base_url: str):\n        try:",
        "detail": "apply_compat_timesync_balance_patch",
        "documentation": {}
    },
    {
        "label": "BLOCK",
        "kind": 5,
        "importPath": "apply_compat_timesync_balance_patch",
        "description": "apply_compat_timesync_balance_patch",
        "peekOfCode": "BLOCK = r'''\n# === COMPAT PATCH: BinanceClient.get_account_balance with time-sync & DRY_RUN stub (idempotent) ===\ntry:\n    import os, time, hmac, hashlib, logging, requests, urllib.parse\n    from core.config import get_config\n    from exchange.client import BinanceClient\n    _clog = logging.getLogger(\"compat\")\n    def _compat__ensure_time_offset_ms(base_url: str):\n        try:\n            r = requests.get(base_url + \"/fapi/v1/time\", timeout=5)",
        "detail": "apply_compat_timesync_balance_patch",
        "documentation": {}
    },
    {
        "label": "validate_symbol",
        "kind": 2,
        "importPath": "apply_core_utils_validate_symbol_stub",
        "description": "apply_core_utils_validate_symbol_stub",
        "peekOfCode": "def validate_symbol(sym: str) -> str:\n    try:\n        s = str(sym).strip().upper()\n    except Exception:\n        return \"\"\n    # мягкая валидация: просто нормализуем регистр/пробелы\n    return s\ndef normalize_symbol(sym: str) -> str:\n    return validate_symbol(sym)\n\"\"\"",
        "detail": "apply_core_utils_validate_symbol_stub",
        "documentation": {}
    },
    {
        "label": "normalize_symbol",
        "kind": 2,
        "importPath": "apply_core_utils_validate_symbol_stub",
        "description": "apply_core_utils_validate_symbol_stub",
        "peekOfCode": "def normalize_symbol(sym: str) -> str:\n    return validate_symbol(sym)\n\"\"\"\ndef main():\n    if not TARGET.exists():\n        print(f\"{WARN} {TARGET} not found\"); return\n    txt = TARGET.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    if \"def validate_symbol\" in txt:\n        print(f\"{OK} core/utils.py already provides validate_symbol()\"); return\n    # вставим после импортов",
        "detail": "apply_core_utils_validate_symbol_stub",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_core_utils_validate_symbol_stub",
        "description": "apply_core_utils_validate_symbol_stub",
        "peekOfCode": "def main():\n    if not TARGET.exists():\n        print(f\"{WARN} {TARGET} not found\"); return\n    txt = TARGET.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    if \"def validate_symbol\" in txt:\n        print(f\"{OK} core/utils.py already provides validate_symbol()\"); return\n    # вставим после импортов\n    lines = txt.splitlines(True)\n    ins = 0\n    for i, l in enumerate(lines[:150]):",
        "detail": "apply_core_utils_validate_symbol_stub",
        "documentation": {}
    },
    {
        "label": "OK",
        "kind": 5,
        "importPath": "apply_core_utils_validate_symbol_stub",
        "description": "apply_core_utils_validate_symbol_stub",
        "peekOfCode": "OK = \"✅\"; WARN = \"⚠️\"\nBASE = Path(__file__).resolve().parent\nTARGET = BASE / \"core\" / \"utils.py\"\nSTUB = \"\"\"\n# --- compat stub: validate_symbol / normalize_symbol (idempotent) ---\ndef validate_symbol(sym: str) -> str:\n    try:\n        s = str(sym).strip().upper()\n    except Exception:\n        return \"\"",
        "detail": "apply_core_utils_validate_symbol_stub",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "apply_core_utils_validate_symbol_stub",
        "description": "apply_core_utils_validate_symbol_stub",
        "peekOfCode": "BASE = Path(__file__).resolve().parent\nTARGET = BASE / \"core\" / \"utils.py\"\nSTUB = \"\"\"\n# --- compat stub: validate_symbol / normalize_symbol (idempotent) ---\ndef validate_symbol(sym: str) -> str:\n    try:\n        s = str(sym).strip().upper()\n    except Exception:\n        return \"\"\n    # мягкая валидация: просто нормализуем регистр/пробелы",
        "detail": "apply_core_utils_validate_symbol_stub",
        "documentation": {}
    },
    {
        "label": "TARGET",
        "kind": 5,
        "importPath": "apply_core_utils_validate_symbol_stub",
        "description": "apply_core_utils_validate_symbol_stub",
        "peekOfCode": "TARGET = BASE / \"core\" / \"utils.py\"\nSTUB = \"\"\"\n# --- compat stub: validate_symbol / normalize_symbol (idempotent) ---\ndef validate_symbol(sym: str) -> str:\n    try:\n        s = str(sym).strip().upper()\n    except Exception:\n        return \"\"\n    # мягкая валидация: просто нормализуем регистр/пробелы\n    return s",
        "detail": "apply_core_utils_validate_symbol_stub",
        "documentation": {}
    },
    {
        "label": "STUB",
        "kind": 5,
        "importPath": "apply_core_utils_validate_symbol_stub",
        "description": "apply_core_utils_validate_symbol_stub",
        "peekOfCode": "STUB = \"\"\"\n# --- compat stub: validate_symbol / normalize_symbol (idempotent) ---\ndef validate_symbol(sym: str) -> str:\n    try:\n        s = str(sym).strip().upper()\n    except Exception:\n        return \"\"\n    # мягкая валидация: просто нормализуем регистр/пробелы\n    return s\ndef normalize_symbol(sym: str) -> str:",
        "detail": "apply_core_utils_validate_symbol_stub",
        "documentation": {}
    },
    {
        "label": "backup",
        "kind": 2,
        "importPath": "apply_final_unified_patch_v3",
        "description": "apply_final_unified_patch_v3",
        "peekOfCode": "def backup(p: Path, suf: str):\n    if p.exists():\n        bk = p.with_suffix(p.suffix + suf)\n        shutil.copy2(p, bk)\n        return bk.name\n    return \"\"\ndef write_file(path: Path, content: str, bak_suffix: str):\n    path.parent.mkdir(parents=True, exist_ok=True)\n    bk = backup(path, bak_suffix)\n    path.write_text(content.rstrip()+\"\\n\", encoding=\"utf-8\")",
        "detail": "apply_final_unified_patch_v3",
        "documentation": {}
    },
    {
        "label": "write_file",
        "kind": 2,
        "importPath": "apply_final_unified_patch_v3",
        "description": "apply_final_unified_patch_v3",
        "peekOfCode": "def write_file(path: Path, content: str, bak_suffix: str):\n    path.parent.mkdir(parents=True, exist_ok=True)\n    bk = backup(path, bak_suffix)\n    path.write_text(content.rstrip()+\"\\n\", encoding=\"utf-8\")\n    if bk:\n        print(f\"{OK} Updated {path.relative_to(BASE)} (backup: {bk})\")\n    else:\n        print(f\"{OK} Created {path.relative_to(BASE)}\")\ndef patch_text(path: Path, mutate, bak_suffix: str):\n    if not path.exists():",
        "detail": "apply_final_unified_patch_v3",
        "documentation": {}
    },
    {
        "label": "patch_text",
        "kind": 2,
        "importPath": "apply_final_unified_patch_v3",
        "description": "apply_final_unified_patch_v3",
        "peekOfCode": "def patch_text(path: Path, mutate, bak_suffix: str):\n    if not path.exists():\n        print(f\"{WARN} {path.relative_to(BASE)} not found — skip\")\n        return False\n    src = path.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    out, changed = mutate(src)\n    if changed:\n        bk = backup(path, bak_suffix)\n        path.write_text(out, encoding=\"utf-8\")\n        print(f\"{OK} Patched {path.relative_to(BASE)}{f' (backup: {bk})' if bk else ''}\")",
        "detail": "apply_final_unified_patch_v3",
        "documentation": {}
    },
    {
        "label": "apply",
        "kind": 2,
        "importPath": "apply_final_unified_patch_v3",
        "description": "apply_final_unified_patch_v3",
        "peekOfCode": "def apply(config):\n    # .env overrides\n    et = _truthy(os.getenv(\"TESTNET\"))\n    ed = _truthy(os.getenv(\"DRY_RUN\"))\n    if et is not None:\n        try: config.testnet = bool(et)\n        except Exception: pass\n    if ed is not None:\n        try: config.dry_run = bool(ed)\n        except Exception: pass",
        "detail": "apply_final_unified_patch_v3",
        "documentation": {}
    },
    {
        "label": "mutate_utils",
        "kind": 2,
        "importPath": "apply_final_unified_patch_v3",
        "description": "apply_final_unified_patch_v3",
        "peekOfCode": "def mutate_utils(src: str):\n    changed = False\n    if \"def validate_symbol(\" not in src:\n        src += \"\\n\\ndef validate_symbol(sym: str) -> str:\\n\"\n        src += \"    try:\\n        return str(sym).strip().upper()\\n\"\n        src += \"    except Exception:\\n        return \\\"\\\"\\n\"\n        changed = True\n    if \"def normalize_symbol(\" not in src:\n        src += \"\\n\\ndef normalize_symbol(sym: str) -> str:\\n\"\n        src += \"    return validate_symbol(sym)\\n\"",
        "detail": "apply_final_unified_patch_v3",
        "documentation": {}
    },
    {
        "label": "mutate_compat_complete",
        "kind": 2,
        "importPath": "apply_final_unified_patch_v3",
        "description": "apply_final_unified_patch_v3",
        "peekOfCode": "def mutate_compat_complete(src: str):\n    changed = False\n    if \"from core.utils import validate_symbol\" in src and \"IMBA_SAFE_VALIDATE_IMPORT\" not in src:\n        src = src.replace(\n            \"from core.utils import validate_symbol\",\n            \"# IMBA_SAFE_VALIDATE_IMPORT\\ntry:\\n    from core.utils import validate_symbol\\nexcept Exception:\\n    def validate_symbol(s: str) -> str:\\n        try: return str(s).strip().upper()\\n        except Exception: return \\\"\\\"\\n\"\n        )\n        changed = True\n    return src, changed\n# 4) runner/live.py — ранний apply(env overrides) + guard min_account_balance",
        "detail": "apply_final_unified_patch_v3",
        "documentation": {}
    },
    {
        "label": "mutate_runner_live",
        "kind": 2,
        "importPath": "apply_final_unified_patch_v3",
        "description": "apply_final_unified_patch_v3",
        "peekOfCode": "def mutate_runner_live(src: str):\n    changed = False\n    # импорт helper\n    if \"from core.env_overrides import apply as _imba_apply_env_overrides\" not in src:\n        # вставим после верхних импортов\n        lines = src.splitlines(True)\n        ins = 0\n        for i,l in enumerate(lines[:300]):\n            if l.strip().startswith((\"import \",\"from \")):\n                ins = i+1",
        "detail": "apply_final_unified_patch_v3",
        "documentation": {}
    },
    {
        "label": "mutate_cli_integrated",
        "kind": 2,
        "importPath": "apply_final_unified_patch_v3",
        "description": "apply_final_unified_patch_v3",
        "peekOfCode": "def mutate_cli_integrated(src: str):\n    changed = False\n    if \"from core.env_overrides import apply as _imba_apply_env_overrides\" not in src:\n        # вставим после импортов\n        lines = src.splitlines(True)\n        ins = 0\n        for i,l in enumerate(lines[:300]):\n            if l.strip().startswith((\"import \",\"from \")):\n                ins = i+1\n            elif l.strip()==\"\" or l.strip().startswith((\"#\",\"'''\",'\\\"\\\"\\\"')):",
        "detail": "apply_final_unified_patch_v3",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_final_unified_patch_v3",
        "description": "apply_final_unified_patch_v3",
        "peekOfCode": "def main():\n    # 1) core/env_overrides.py\n    write_file(BASE/\"core\"/\"env_overrides.py\", ENV_OVR, \".bak_envovr\")\n    # 2) core/utils.py\n    patch_text(BASE/\"core\"/\"utils.py\", mutate_utils, \".bak_utils_v3\")\n    # 3) compat_complete.py (если есть)\n    if (BASE/\"compat_complete.py\").exists():\n        patch_text(BASE/\"compat_complete.py\", mutate_compat_complete, \".bak_cc_v3\")\n    else:\n        print(f\"{WARN} compat_complete.py not found — skip import guard\")",
        "detail": "apply_final_unified_patch_v3",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "apply_final_unified_patch_v3",
        "description": "apply_final_unified_patch_v3",
        "peekOfCode": "BASE = Path(__file__).resolve().parent\nOK=\"✅\"; WARN=\"⚠️\"; INFO=\"ℹ️\"\ndef backup(p: Path, suf: str):\n    if p.exists():\n        bk = p.with_suffix(p.suffix + suf)\n        shutil.copy2(p, bk)\n        return bk.name\n    return \"\"\ndef write_file(path: Path, content: str, bak_suffix: str):\n    path.parent.mkdir(parents=True, exist_ok=True)",
        "detail": "apply_final_unified_patch_v3",
        "documentation": {}
    },
    {
        "label": "ENV_OVR",
        "kind": 5,
        "importPath": "apply_final_unified_patch_v3",
        "description": "apply_final_unified_patch_v3",
        "peekOfCode": "ENV_OVR = r'''\n# core/env_overrides.py — centralized TESTNET/DRY_RUN overrides\nfrom __future__ import annotations\nimport os\ndef _truthy(v):\n    if v is None: return None\n    return str(v).strip().lower() in {\"1\",\"true\",\"t\",\"yes\",\"y\",\"on\"}\ndef apply(config):\n    # .env overrides\n    et = _truthy(os.getenv(\"TESTNET\"))",
        "detail": "apply_final_unified_patch_v3",
        "documentation": {}
    },
    {
        "label": "patch_live",
        "kind": 2,
        "importPath": "apply_live_cli_rescue_v5",
        "description": "apply_live_cli_rescue_v5",
        "peekOfCode": "def patch_live():\n    p = os.path.join(BASE, \"runner\", \"live.py\")\n    if not os.path.exists(p):\n        print(\"SKIP - runner/live.py not found\")\n        return\n    txt = open(p, \"r\", encoding=\"utf-8\").read()\n    orig = txt\n    # 1) Нормализуем табы -> пробелы (защита от unexpected indent)\n    txt = txt.replace(\"\\t\", \"    \")\n    # 2) Чиним опечатку self.getattr(...) -> getattr(self.config, ...)",
        "detail": "apply_live_cli_rescue_v5",
        "documentation": {}
    },
    {
        "label": "patch_cli",
        "kind": 2,
        "importPath": "apply_live_cli_rescue_v5",
        "description": "apply_live_cli_rescue_v5",
        "peekOfCode": "def patch_cli():\n    p = os.path.join(BASE, \"cli_integrated.py\")\n    if not os.path.exists(p):\n        print(\"SKIP- cli_integrated.py not found\")\n        return\n    txt = open(p, \"r\", encoding=\"utf-8\").read()\n    orig = txt\n    # Pydantic v2: заменяем доступ к __fields__ на кросс-версионный\n    txt = txt.replace(\n        \"Config.__fields__\",",
        "detail": "apply_live_cli_rescue_v5",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "apply_live_cli_rescue_v5",
        "description": "apply_live_cli_rescue_v5",
        "peekOfCode": "BASE = os.path.dirname(__file__)\ndef patch_live():\n    p = os.path.join(BASE, \"runner\", \"live.py\")\n    if not os.path.exists(p):\n        print(\"SKIP - runner/live.py not found\")\n        return\n    txt = open(p, \"r\", encoding=\"utf-8\").read()\n    orig = txt\n    # 1) Нормализуем табы -> пробелы (защита от unexpected indent)\n    txt = txt.replace(\"\\t\", \"    \")",
        "detail": "apply_live_cli_rescue_v5",
        "documentation": {}
    },
    {
        "label": "LiveTradingEngine",
        "kind": 6,
        "importPath": "apply_live_engine_fix_patch",
        "description": "apply_live_engine_fix_patch",
        "peekOfCode": "class LiveTradingEngine:\n    \"\"\"\n    Live trading execution engine with comprehensive safety measures.\n    \"\"\"\n    def __init__(self, config: Config):\n        self.config = config\n        self._overrides_watcher = None\n        # Runtime overrides (опционально)\n        path = getattr(self.config, \"overrides_path\", \"\") or \"config/overrides.txt\"\n        if RuntimeOverridesWatcher and os.path.exists(path):",
        "detail": "apply_live_engine_fix_patch",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_live_engine_fix_patch",
        "description": "apply_live_engine_fix_patch",
        "peekOfCode": "def main():\n    # backup\n    LIVE_PATH.parent.mkdir(parents=True, exist_ok=True)\n    if LIVE_PATH.exists():\n        shutil.copyfile(LIVE_PATH, BACKUP_PATH)\n    # write\n    with io.open(LIVE_PATH, \"w\", encoding=\"utf-8\", newline=\"\\n\") as f:\n        f.write(NEW_LIVE)\n    print(f\"✅ Patched {LIVE_PATH}\")\n    if BACKUP_PATH.exists():",
        "detail": "apply_live_engine_fix_patch",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "apply_live_engine_fix_patch",
        "description": "apply_live_engine_fix_patch",
        "peekOfCode": "BASE = Path(__file__).resolve().parent\nLIVE_PATH = BASE / \"runner\" / \"live.py\"\nBACKUP_PATH = BASE / \"runner\" / \"live.py.bak_autofix\"\nNEW_LIVE = r'''#!/usr/bin/env python3\n\"\"\"\nLive Trading Engine (fixed)\n- Исправлен неожиданный отступ (tabs/spaces) вокруг _setup_signal_handlers\n- Заменено self.logger -> logger\n- Защитные дефолты для отсутствующих полей конфига\n- Безопасные обработчики сигналов под Windows",
        "detail": "apply_live_engine_fix_patch",
        "documentation": {}
    },
    {
        "label": "LIVE_PATH",
        "kind": 5,
        "importPath": "apply_live_engine_fix_patch",
        "description": "apply_live_engine_fix_patch",
        "peekOfCode": "LIVE_PATH = BASE / \"runner\" / \"live.py\"\nBACKUP_PATH = BASE / \"runner\" / \"live.py.bak_autofix\"\nNEW_LIVE = r'''#!/usr/bin/env python3\n\"\"\"\nLive Trading Engine (fixed)\n- Исправлен неожиданный отступ (tabs/spaces) вокруг _setup_signal_handlers\n- Заменено self.logger -> logger\n- Защитные дефолты для отсутствующих полей конфига\n- Безопасные обработчики сигналов под Windows\n\"\"\"",
        "detail": "apply_live_engine_fix_patch",
        "documentation": {}
    },
    {
        "label": "BACKUP_PATH",
        "kind": 5,
        "importPath": "apply_live_engine_fix_patch",
        "description": "apply_live_engine_fix_patch",
        "peekOfCode": "BACKUP_PATH = BASE / \"runner\" / \"live.py.bak_autofix\"\nNEW_LIVE = r'''#!/usr/bin/env python3\n\"\"\"\nLive Trading Engine (fixed)\n- Исправлен неожиданный отступ (tabs/spaces) вокруг _setup_signal_handlers\n- Заменено self.logger -> logger\n- Защитные дефолты для отсутствующих полей конфига\n- Безопасные обработчики сигналов под Windows\n\"\"\"\nimport asyncio",
        "detail": "apply_live_engine_fix_patch",
        "documentation": {}
    },
    {
        "label": "NEW_LIVE",
        "kind": 5,
        "importPath": "apply_live_engine_fix_patch",
        "description": "apply_live_engine_fix_patch",
        "peekOfCode": "NEW_LIVE = r'''#!/usr/bin/env python3\n\"\"\"\nLive Trading Engine (fixed)\n- Исправлен неожиданный отступ (tabs/spaces) вокруг _setup_signal_handlers\n- Заменено self.logger -> logger\n- Защитные дефолты для отсутствующих полей конфига\n- Безопасные обработчики сигналов под Windows\n\"\"\"\nimport asyncio\nimport signal",
        "detail": "apply_live_engine_fix_patch",
        "documentation": {}
    },
    {
        "label": "replace_method",
        "kind": 2,
        "importPath": "apply_live_engine_guardrails_v6",
        "description": "apply_live_engine_guardrails_v6",
        "peekOfCode": "def replace_method(body_name, new_body):\n    # заменяет тело метода класса LiveTradingEngine с заданным именем\n    pattern = rf\"(def {body_name}\\(self[^\\)]*\\):\\n)(?:\\s+.*\\n)+?\"\n    # найти старт\n    m = re.search(rf\"\\n\\s+def {body_name}\\(\", txt)\n    if not m:\n        return False\n    start = m.start()\n    # найти конец методом поиска следующего def/async def на том же уровне отступов\n    tail = txt[start+1:]",
        "detail": "apply_live_engine_guardrails_v6",
        "documentation": {}
    },
    {
        "label": "LIVE",
        "kind": 5,
        "importPath": "apply_live_engine_guardrails_v6",
        "description": "apply_live_engine_guardrails_v6",
        "peekOfCode": "LIVE = Path(\"runner/live.py\")\nif not LIVE.exists():\n    print(\"runner/live.py not found\")\n    sys.exit(1)\nsrc = LIVE.read_text(encoding=\"utf-8\")\nbak = LIVE.with_suffix(\".bak_guardrails_v6.py\")\nshutil.copyfile(LIVE, bak)\ntxt = src\n# 1) import inspect (для awaitable checks, если вдруг пригодится)\nif \"import inspect\" not in txt:",
        "detail": "apply_live_engine_guardrails_v6",
        "documentation": {}
    },
    {
        "label": "src",
        "kind": 5,
        "importPath": "apply_live_engine_guardrails_v6",
        "description": "apply_live_engine_guardrails_v6",
        "peekOfCode": "src = LIVE.read_text(encoding=\"utf-8\")\nbak = LIVE.with_suffix(\".bak_guardrails_v6.py\")\nshutil.copyfile(LIVE, bak)\ntxt = src\n# 1) import inspect (для awaitable checks, если вдруг пригодится)\nif \"import inspect\" not in txt:\n    txt = txt.replace(\"import asyncio\\nimport signal\", \"import asyncio\\nimport signal\\nimport inspect\")\n# 2) после self.processed_signals добавить локальные кулдауны\ntxt = re.sub(\n    r\"(self\\.processed_signals:[^\\n]+\\n)\",",
        "detail": "apply_live_engine_guardrails_v6",
        "documentation": {}
    },
    {
        "label": "bak",
        "kind": 5,
        "importPath": "apply_live_engine_guardrails_v6",
        "description": "apply_live_engine_guardrails_v6",
        "peekOfCode": "bak = LIVE.with_suffix(\".bak_guardrails_v6.py\")\nshutil.copyfile(LIVE, bak)\ntxt = src\n# 1) import inspect (для awaitable checks, если вдруг пригодится)\nif \"import inspect\" not in txt:\n    txt = txt.replace(\"import asyncio\\nimport signal\", \"import asyncio\\nimport signal\\nimport inspect\")\n# 2) после self.processed_signals добавить локальные кулдауны\ntxt = re.sub(\n    r\"(self\\.processed_signals:[^\\n]+\\n)\",\n    r\"\\1        # Local per-symbol cooldowns (engine-level)\\n        self._cooldown_until: dict[str, datetime] = {}\\n\",",
        "detail": "apply_live_engine_guardrails_v6",
        "documentation": {}
    },
    {
        "label": "txt",
        "kind": 5,
        "importPath": "apply_live_engine_guardrails_v6",
        "description": "apply_live_engine_guardrails_v6",
        "peekOfCode": "txt = src\n# 1) import inspect (для awaitable checks, если вдруг пригодится)\nif \"import inspect\" not in txt:\n    txt = txt.replace(\"import asyncio\\nimport signal\", \"import asyncio\\nimport signal\\nimport inspect\")\n# 2) после self.processed_signals добавить локальные кулдауны\ntxt = re.sub(\n    r\"(self\\.processed_signals:[^\\n]+\\n)\",\n    r\"\\1        # Local per-symbol cooldowns (engine-level)\\n        self._cooldown_until: dict[str, datetime] = {}\\n\",\n    txt,\n    count=1,",
        "detail": "apply_live_engine_guardrails_v6",
        "documentation": {}
    },
    {
        "label": "txt",
        "kind": 5,
        "importPath": "apply_live_engine_guardrails_v6",
        "description": "apply_live_engine_guardrails_v6",
        "peekOfCode": "txt = re.sub(\n    r\"(self\\.processed_signals:[^\\n]+\\n)\",\n    r\"\\1        # Local per-symbol cooldowns (engine-level)\\n        self._cooldown_until: dict[str, datetime] = {}\\n\",\n    txt,\n    count=1,\n)\n# 3) заменить await self.order_manager.is_in_cooldown(...) на локальную проверку\ntxt = txt.replace(\n    \"if await self.order_manager.is_in_cooldown(signal.symbol):\",\n    \"if self._is_in_cooldown(signal.symbol):\"",
        "detail": "apply_live_engine_guardrails_v6",
        "documentation": {}
    },
    {
        "label": "txt",
        "kind": 5,
        "importPath": "apply_live_engine_guardrails_v6",
        "description": "apply_live_engine_guardrails_v6",
        "peekOfCode": "txt = txt.replace(\n    \"if await self.order_manager.is_in_cooldown(signal.symbol):\",\n    \"if self._is_in_cooldown(signal.symbol):\"\n)\n# 4) заменить прямой вызов risk_manager.calculate_position_size(...) на безопасный wrapper\ntxt = txt.replace(\n    \"position_size = self.risk_manager.calculate_position_size(\",\n    \"position_size = self._safe_calc_position_size(\",\n)\n# 5) заменить случайные self.logger.info(...) -> logger.info(...)",
        "detail": "apply_live_engine_guardrails_v6",
        "documentation": {}
    },
    {
        "label": "txt",
        "kind": 5,
        "importPath": "apply_live_engine_guardrails_v6",
        "description": "apply_live_engine_guardrails_v6",
        "peekOfCode": "txt = txt.replace(\n    \"position_size = self.risk_manager.calculate_position_size(\",\n    \"position_size = self._safe_calc_position_size(\",\n)\n# 5) заменить случайные self.logger.info(...) -> logger.info(...)\ntxt = txt.replace(\"self.logger.info(\", \"logger.info(\")\n# 6) безопасная версия _is_trading_hours\ndef replace_method(body_name, new_body):\n    # заменяет тело метода класса LiveTradingEngine с заданным именем\n    pattern = rf\"(def {body_name}\\(self[^\\)]*\\):\\n)(?:\\s+.*\\n)+?\"",
        "detail": "apply_live_engine_guardrails_v6",
        "documentation": {}
    },
    {
        "label": "txt",
        "kind": 5,
        "importPath": "apply_live_engine_guardrails_v6",
        "description": "apply_live_engine_guardrails_v6",
        "peekOfCode": "txt = txt.replace(\"self.logger.info(\", \"logger.info(\")\n# 6) безопасная версия _is_trading_hours\ndef replace_method(body_name, new_body):\n    # заменяет тело метода класса LiveTradingEngine с заданным именем\n    pattern = rf\"(def {body_name}\\(self[^\\)]*\\):\\n)(?:\\s+.*\\n)+?\"\n    # найти старт\n    m = re.search(rf\"\\n\\s+def {body_name}\\(\", txt)\n    if not m:\n        return False\n    start = m.start()",
        "detail": "apply_live_engine_guardrails_v6",
        "documentation": {}
    },
    {
        "label": "is_tr_hours_body",
        "kind": 5,
        "importPath": "apply_live_engine_guardrails_v6",
        "description": "apply_live_engine_guardrails_v6",
        "peekOfCode": "is_tr_hours_body = \"\"\"\\\n        \\\"\\\"\\\"Check if we're in allowed trading hours.\\\"\\\"\\\"\n        enabled = getattr(self.config, \\\"trading_hours_enabled\\\", False)\n        if not enabled:\n            return True\n        now_h = datetime.utcnow().hour\n        start = int(getattr(self.config, \\\"trading_start_hour\\\", 0))\n        end   = int(getattr(self.config, \\\"trading_end_hour\\\", 23))\n        if start <= end:\n            return start <= now_h <= end",
        "detail": "apply_live_engine_guardrails_v6",
        "documentation": {}
    },
    {
        "label": "check_body",
        "kind": 5,
        "importPath": "apply_live_engine_guardrails_v6",
        "description": "apply_live_engine_guardrails_v6",
        "peekOfCode": "check_body = \"\"\"\\\n        \\\"\\\"\\\"Check for emergency stop conditions.\\\"\\\"\\\"\n        # Daily loss limit (в абсолюте, если указано)\n        daily_pnl = await self.metrics.get_daily_pnl()\n        max_daily_loss = float(getattr(self.config, \\\"max_daily_loss\\\", 0.0))\n        if max_daily_loss and daily_pnl < -abs(max_daily_loss):\n            logger.critical(f\\\"Daily loss limit exceeded: {format_currency(daily_pnl)}\\\")\n            return True\n        # Account balance (дефолт 0.0 — не стопаем, если параметр не задан)\n        balance = 0.0",
        "detail": "apply_live_engine_guardrails_v6",
        "documentation": {}
    },
    {
        "label": "insert_after",
        "kind": 5,
        "importPath": "apply_live_engine_guardrails_v6",
        "description": "apply_live_engine_guardrails_v6",
        "peekOfCode": "insert_after = re.search(r\"\\n\\s+def _setup_signal_handlers\\(self\\)[\\s\\S]*?\\n\\s+async def _run_trading_loop\", txt)\nif insert_after:\n    p1, p2 = insert_after.span()\n    before = txt[:p2 - len(\"async def _run_trading_loop\")]\n    after  = txt[p2 - len(\"async def _run_trading_loop\"):]\n    helpers = \"\"\"\n    def _is_in_cooldown(self, symbol: str) -> bool:\n        \\\"\\\"\\\"Engine-level cooldown, не зависит от OrderManager.\\\"\\\"\\\"\n        now = datetime.utcnow()\n        until = self._cooldown_until.get(symbol)",
        "detail": "apply_live_engine_guardrails_v6",
        "documentation": {}
    },
    {
        "label": "txt",
        "kind": 5,
        "importPath": "apply_live_engine_guardrails_v6",
        "description": "apply_live_engine_guardrails_v6",
        "peekOfCode": "txt = txt.replace(\n    \"if order:\\n                self.pending_orders[order.id] = order\\n                logger.info(f\\\"Order placed: {order.side} {order.quantity} {symbol}\\\")\",\n    \"if order:\\n                self.pending_orders[order.id] = order\\n                logger.info(f\\\"Order placed: {order.side} {order.quantity} {symbol}\\\")\\n                self._bump_cooldown(symbol)\"\n)\nLIVE.write_text(txt, encoding=\"utf-8\")\nprint(f\"Patched {LIVE} -> backup: {bak.name}\")",
        "detail": "apply_live_engine_guardrails_v6",
        "documentation": {}
    },
    {
        "label": "LiveTradingEngine",
        "kind": 6,
        "importPath": "apply_live_engine_guardrails_v7",
        "description": "apply_live_engine_guardrails_v7",
        "peekOfCode": "class LiveTradingEngine:\n    \"\"\"\n    Live trading execution engine with guardrails.\n    Safe points:\n    - DRY_RUN skips exchange init/sync\n    - Runtime overrides watcher is optional (safe stubs)\n    - Risk sizing accepts both number and (qty, stop) tuple\n    - Cooldown fallback if OrderManager has no is_in_cooldown\n    - Emergency checks are tolerant to missing fields\n    \"\"\"",
        "detail": "apply_live_engine_guardrails_v7",
        "documentation": {}
    },
    {
        "label": "patch_overrides_import",
        "kind": 2,
        "importPath": "apply_live_engine_guardrails_v7",
        "description": "apply_live_engine_guardrails_v7",
        "peekOfCode": "def patch_overrides_import(src: str) -> str:\n    # replace \"from infra.settings import ...\" with safe stub\n    pat = re.compile(r\"^from\\s+infra\\.settings\\s+import[^\\n]*$\", re.M)\n    if pat.search(src):\n        return pat.sub(SAFE_OVERRIDES_IMPORT.rstrip(\"\\n\"), src)\n    # if not present, try to insert after other imports\n    insert_after = re.search(r\"^(import .+|from .+ import .+)\\s*$\", src, re.M)\n    if insert_after:\n        i = insert_after.end()\n        return src[:i] + \"\\n\\n\" + SAFE_OVERRIDES_IMPORT + src[i:]",
        "detail": "apply_live_engine_guardrails_v7",
        "documentation": {}
    },
    {
        "label": "patch_live_class",
        "kind": 2,
        "importPath": "apply_live_engine_guardrails_v7",
        "description": "apply_live_engine_guardrails_v7",
        "peekOfCode": "def patch_live_class(src: str) -> str:\n    # Replace the entire LiveTradingEngine class block, keep @asynccontextmanager and below\n    pat = re.compile(r\"^class\\s+LiveTradingEngine\\b.*?^@asynccontextmanager\", re.M | re.S)\n    m = pat.search(src)\n    if not m:\n        raise RuntimeError(\"LiveTradingEngine block not found\")\n    before = src[:m.start()]\n    after = src[m.end():]  # starts with '@asynccontextmanager'\n    return before + NEW_CLASS + \"\\n\\n@asynccontextmanager\" + after\ndef main():",
        "detail": "apply_live_engine_guardrails_v7",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_live_engine_guardrails_v7",
        "description": "apply_live_engine_guardrails_v7",
        "peekOfCode": "def main():\n    if not os.path.exists(LIVE_PATH):\n        print(\"runner/live.py not found\")\n        sys.exit(1)\n    with io.open(LIVE_PATH, \"r\", encoding=\"utf-8\") as f:\n        src = f.read()\n    # backup\n    shutil.copy2(LIVE_PATH, BACKUP_PATH)\n    # patch overrides import\n    src = patch_overrides_import(src)",
        "detail": "apply_live_engine_guardrails_v7",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "apply_live_engine_guardrails_v7",
        "description": "apply_live_engine_guardrails_v7",
        "peekOfCode": "BASE = os.path.dirname(os.path.abspath(__file__))\nLIVE_PATH = os.path.join(BASE, \"runner\", \"live.py\")\nBACKUP_PATH = os.path.join(BASE, \"runner\", \"live.bak_guardrails_v7.py\")\nSAFE_OVERRIDES_IMPORT = (\n    \"try:\\n\"\n    \"    from infra.settings import RuntimeOverridesWatcher, apply_settings_to_config\\n\"\n    \"except Exception:\\n\"\n    \"    class RuntimeOverridesWatcher:\\n\"\n    \"        def __init__(self, path: str):\\n\"\n    \"            self.path = path\\n\"",
        "detail": "apply_live_engine_guardrails_v7",
        "documentation": {}
    },
    {
        "label": "LIVE_PATH",
        "kind": 5,
        "importPath": "apply_live_engine_guardrails_v7",
        "description": "apply_live_engine_guardrails_v7",
        "peekOfCode": "LIVE_PATH = os.path.join(BASE, \"runner\", \"live.py\")\nBACKUP_PATH = os.path.join(BASE, \"runner\", \"live.bak_guardrails_v7.py\")\nSAFE_OVERRIDES_IMPORT = (\n    \"try:\\n\"\n    \"    from infra.settings import RuntimeOverridesWatcher, apply_settings_to_config\\n\"\n    \"except Exception:\\n\"\n    \"    class RuntimeOverridesWatcher:\\n\"\n    \"        def __init__(self, path: str):\\n\"\n    \"            self.path = path\\n\"\n    \"        def poll(self):\\n\"",
        "detail": "apply_live_engine_guardrails_v7",
        "documentation": {}
    },
    {
        "label": "BACKUP_PATH",
        "kind": 5,
        "importPath": "apply_live_engine_guardrails_v7",
        "description": "apply_live_engine_guardrails_v7",
        "peekOfCode": "BACKUP_PATH = os.path.join(BASE, \"runner\", \"live.bak_guardrails_v7.py\")\nSAFE_OVERRIDES_IMPORT = (\n    \"try:\\n\"\n    \"    from infra.settings import RuntimeOverridesWatcher, apply_settings_to_config\\n\"\n    \"except Exception:\\n\"\n    \"    class RuntimeOverridesWatcher:\\n\"\n    \"        def __init__(self, path: str):\\n\"\n    \"            self.path = path\\n\"\n    \"        def poll(self):\\n\"\n    \"            return {}\\n\"",
        "detail": "apply_live_engine_guardrails_v7",
        "documentation": {}
    },
    {
        "label": "SAFE_OVERRIDES_IMPORT",
        "kind": 5,
        "importPath": "apply_live_engine_guardrails_v7",
        "description": "apply_live_engine_guardrails_v7",
        "peekOfCode": "SAFE_OVERRIDES_IMPORT = (\n    \"try:\\n\"\n    \"    from infra.settings import RuntimeOverridesWatcher, apply_settings_to_config\\n\"\n    \"except Exception:\\n\"\n    \"    class RuntimeOverridesWatcher:\\n\"\n    \"        def __init__(self, path: str):\\n\"\n    \"            self.path = path\\n\"\n    \"        def poll(self):\\n\"\n    \"            return {}\\n\"\n    \"    def apply_settings_to_config(config, changes):\\n\"",
        "detail": "apply_live_engine_guardrails_v7",
        "documentation": {}
    },
    {
        "label": "NEW_CLASS",
        "kind": 5,
        "importPath": "apply_live_engine_guardrails_v7",
        "description": "apply_live_engine_guardrails_v7",
        "peekOfCode": "NEW_CLASS = r'''\nclass LiveTradingEngine:\n    \"\"\"\n    Live trading execution engine with guardrails.\n    Safe points:\n    - DRY_RUN skips exchange init/sync\n    - Runtime overrides watcher is optional (safe stubs)\n    - Risk sizing accepts both number and (qty, stop) tuple\n    - Cooldown fallback if OrderManager has no is_in_cooldown\n    - Emergency checks are tolerant to missing fields",
        "detail": "apply_live_engine_guardrails_v7",
        "documentation": {}
    },
    {
        "label": "LiveTradingEngine",
        "kind": 6,
        "importPath": "apply_live_engine_guardrails_v8",
        "description": "apply_live_engine_guardrails_v8",
        "peekOfCode": "class LiveTradingEngine:\n    \"\"\"\n    Live trading execution engine with comprehensive safety measures.\n    \"\"\"\n    def __init__(self, config: Config):\n        self.config = config\n        # Runtime overrides (optional file watcher)\n        self._overrides_watcher = None\n        path = _get(self.config, \"overrides_path\", \"\") or \"config/overrides.txt\"\n        if RuntimeOverridesWatcher and os.path.exists(path):",
        "detail": "apply_live_engine_guardrails_v8",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_live_engine_guardrails_v8",
        "description": "apply_live_engine_guardrails_v8",
        "peekOfCode": "def main():\n    if not LIVE_PATH.exists():\n        raise SystemExit(f\"File not found: {LIVE_PATH}\")\n    # Backup\n    BACKUP_PATH.write_text(LIVE_PATH.read_text(encoding=\"utf-8\"), encoding=\"utf-8\")\n    # Write new file\n    LIVE_PATH.write_text(NEW_LIVE, encoding=\"utf-8\")\n    print(f\"Patched {LIVE_PATH} -> backup: {BACKUP_PATH.name}\")\nif __name__ == \"__main__\":\n    main()",
        "detail": "apply_live_engine_guardrails_v8",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "apply_live_engine_guardrails_v8",
        "description": "apply_live_engine_guardrails_v8",
        "peekOfCode": "BASE = Path(__file__).resolve().parent\nLIVE_PATH = BASE / \"runner\" / \"live.py\"\nBACKUP_PATH = BASE / \"runner\" / \"live.bak_guardrails_v8.py\"\nNEW_LIVE = r'''#!/usr/bin/env python3\n\"\"\"\nLive Trading Engine (guardrails v8)\n- Robust to missing / optional fields in Config.\n- Works in DRY_RUN without hitting the exchange.\n- Normalizes signals of different shapes (str/tuple/dict/Signal).\n- Accepts RiskManager.calculate_position_size returning float or (float, reason).",
        "detail": "apply_live_engine_guardrails_v8",
        "documentation": {}
    },
    {
        "label": "LIVE_PATH",
        "kind": 5,
        "importPath": "apply_live_engine_guardrails_v8",
        "description": "apply_live_engine_guardrails_v8",
        "peekOfCode": "LIVE_PATH = BASE / \"runner\" / \"live.py\"\nBACKUP_PATH = BASE / \"runner\" / \"live.bak_guardrails_v8.py\"\nNEW_LIVE = r'''#!/usr/bin/env python3\n\"\"\"\nLive Trading Engine (guardrails v8)\n- Robust to missing / optional fields in Config.\n- Works in DRY_RUN without hitting the exchange.\n- Normalizes signals of different shapes (str/tuple/dict/Signal).\n- Accepts RiskManager.calculate_position_size returning float or (float, reason).\n- Guards ZeroDivisionError from RiskManager.",
        "detail": "apply_live_engine_guardrails_v8",
        "documentation": {}
    },
    {
        "label": "BACKUP_PATH",
        "kind": 5,
        "importPath": "apply_live_engine_guardrails_v8",
        "description": "apply_live_engine_guardrails_v8",
        "peekOfCode": "BACKUP_PATH = BASE / \"runner\" / \"live.bak_guardrails_v8.py\"\nNEW_LIVE = r'''#!/usr/bin/env python3\n\"\"\"\nLive Trading Engine (guardrails v8)\n- Robust to missing / optional fields in Config.\n- Works in DRY_RUN without hitting the exchange.\n- Normalizes signals of different shapes (str/tuple/dict/Signal).\n- Accepts RiskManager.calculate_position_size returning float or (float, reason).\n- Guards ZeroDivisionError from RiskManager.\n- Cooldown check works even if OrderManager.is_in_cooldown is missing.",
        "detail": "apply_live_engine_guardrails_v8",
        "documentation": {}
    },
    {
        "label": "NEW_LIVE",
        "kind": 5,
        "importPath": "apply_live_engine_guardrails_v8",
        "description": "apply_live_engine_guardrails_v8",
        "peekOfCode": "NEW_LIVE = r'''#!/usr/bin/env python3\n\"\"\"\nLive Trading Engine (guardrails v8)\n- Robust to missing / optional fields in Config.\n- Works in DRY_RUN without hitting the exchange.\n- Normalizes signals of different shapes (str/tuple/dict/Signal).\n- Accepts RiskManager.calculate_position_size returning float or (float, reason).\n- Guards ZeroDivisionError from RiskManager.\n- Cooldown check works even if OrderManager.is_in_cooldown is missing.\n- Optional runtime overrides watcher is supported.",
        "detail": "apply_live_engine_guardrails_v8",
        "documentation": {}
    },
    {
        "label": "replace_block",
        "kind": 2,
        "importPath": "apply_live_engine_hotfix_v5",
        "description": "apply_live_engine_hotfix_v5",
        "peekOfCode": "def replace_block(txt, start_pat, end_pat, new_block):\n    m = re.search(start_pat, txt, flags=re.S)\n    if not m:\n        return txt, False\n    start = m.start()\n    m2 = re.search(end_pat, txt[m.end():], flags=re.S|re.M)\n    if not m2:\n        return txt, False\n    end = m.end() + m2.start()\n    return txt[:start] + new_block + txt[end:], True",
        "detail": "apply_live_engine_hotfix_v5",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_live_engine_hotfix_v5",
        "description": "apply_live_engine_hotfix_v5",
        "peekOfCode": "def main():\n    if not LIVE_PATH.exists():\n        raise SystemExit(\"runner/live.py not found\")\n    src = LIVE_PATH.read_text(encoding=\"utf-8\")\n    bak = LIVE_PATH.with_suffix(\".bak_hotfix_v5\")\n    bak.write_text(src, encoding=\"utf-8\")\n    changed = 0\n    # 1) Починить пропущенный \":\" в for symbol, position in list(self.active_positions.items())\n    src2 = re.sub(\n        r\"(for\\s+symbol\\s*,\\s*position\\s+in\\s+list\\(\\s*self\\.active_positions\\.items\\(\\)\\s*\\))\\s*(\\r?\\n)\",",
        "detail": "apply_live_engine_hotfix_v5",
        "documentation": {}
    },
    {
        "label": "LIVE_PATH",
        "kind": 5,
        "importPath": "apply_live_engine_hotfix_v5",
        "description": "apply_live_engine_hotfix_v5",
        "peekOfCode": "LIVE_PATH = Path(\"runner/live.py\")\ndef replace_block(txt, start_pat, end_pat, new_block):\n    m = re.search(start_pat, txt, flags=re.S)\n    if not m:\n        return txt, False\n    start = m.start()\n    m2 = re.search(end_pat, txt[m.end():], flags=re.S|re.M)\n    if not m2:\n        return txt, False\n    end = m.end() + m2.start()",
        "detail": "apply_live_engine_hotfix_v5",
        "documentation": {}
    },
    {
        "label": "read",
        "kind": 2,
        "importPath": "apply_live_orders_cooldown_patch",
        "description": "apply_live_orders_cooldown_patch",
        "peekOfCode": "def read(p: Path) -> str:\n    return p.read_text(encoding=\"utf-8\")\ndef write(p: Path, txt: str):\n    p.parent.mkdir(parents=True, exist_ok=True)\n    p.write_text(txt, encoding=\"utf-8\")\ndef backup(p: Path, suffix: str):\n    b = p.with_name(p.name + suffix)\n    try:\n        if p.exists():\n            b.write_text(p.read_text(encoding=\"utf-8\"), encoding=\"utf-8\")",
        "detail": "apply_live_orders_cooldown_patch",
        "documentation": {}
    },
    {
        "label": "write",
        "kind": 2,
        "importPath": "apply_live_orders_cooldown_patch",
        "description": "apply_live_orders_cooldown_patch",
        "peekOfCode": "def write(p: Path, txt: str):\n    p.parent.mkdir(parents=True, exist_ok=True)\n    p.write_text(txt, encoding=\"utf-8\")\ndef backup(p: Path, suffix: str):\n    b = p.with_name(p.name + suffix)\n    try:\n        if p.exists():\n            b.write_text(p.read_text(encoding=\"utf-8\"), encoding=\"utf-8\")\n    except Exception:\n        pass",
        "detail": "apply_live_orders_cooldown_patch",
        "documentation": {}
    },
    {
        "label": "backup",
        "kind": 2,
        "importPath": "apply_live_orders_cooldown_patch",
        "description": "apply_live_orders_cooldown_patch",
        "peekOfCode": "def backup(p: Path, suffix: str):\n    b = p.with_name(p.name + suffix)\n    try:\n        if p.exists():\n            b.write_text(p.read_text(encoding=\"utf-8\"), encoding=\"utf-8\")\n    except Exception:\n        pass\ndef patch_live_py():\n    if not LIVE.exists():\n        print(f\"❌ {LIVE} not found\")",
        "detail": "apply_live_orders_cooldown_patch",
        "documentation": {}
    },
    {
        "label": "patch_live_py",
        "kind": 2,
        "importPath": "apply_live_orders_cooldown_patch",
        "description": "apply_live_orders_cooldown_patch",
        "peekOfCode": "def patch_live_py():\n    if not LIVE.exists():\n        print(f\"❌ {LIVE} not found\")\n        return False\n    src = read(LIVE)\n    original = src\n    # 1) self.logger.info -> logger.info\n    src = src.replace(\"self.logger.info(\", \"logger.info(\")\n    # 2) Безопасный min_account_balance\n    src = re.sub(",
        "detail": "apply_live_orders_cooldown_patch",
        "documentation": {}
    },
    {
        "label": "write_orders_addon",
        "kind": 2,
        "importPath": "apply_live_orders_cooldown_patch",
        "description": "apply_live_orders_cooldown_patch",
        "peekOfCode": "def write_orders_addon():\n    code = r'''# -*- coding: utf-8 -*-\n\"\"\"\norders_cooldown_addon: adds soft cooldown helpers into exchange.orders.OrderManager\n- is_in_cooldown(symbol) -> bool\n- note_cooldown(symbol) -> None\n- wraps place_order() to record cooldown timestamp automatically\n\"\"\"\nimport time, asyncio, inspect, logging\nlog = logging.getLogger(\"orders_addon\")",
        "detail": "apply_live_orders_cooldown_patch",
        "documentation": {}
    },
    {
        "label": "patch_sitecustomize",
        "kind": 2,
        "importPath": "apply_live_orders_cooldown_patch",
        "description": "apply_live_orders_cooldown_patch",
        "peekOfCode": "def patch_sitecustomize():\n    line = \"import exchange.orders_cooldown_addon  # cooldown addon\"\n    if not SITE.exists():\n        write(SITE, f\"# auto-created by patcher\\ntry:\\n    {line}\\nexcept Exception as e:\\n    print('sitecustomize: orders_addon failed:', e)\\n\")\n        print(f\"✅ Created {SITE.name} with orders cooldown import\")\n        return True\n    txt = read(SITE)\n    if \"orders_cooldown_addon\" in txt:\n        print(\"ℹ️ sitecustomize.py already imports orders_cooldown_addon\")\n        return True",
        "detail": "apply_live_orders_cooldown_patch",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_live_orders_cooldown_patch",
        "description": "apply_live_orders_cooldown_patch",
        "peekOfCode": "def main():\n    ok1 = patch_live_py()\n    ok2 = write_orders_addon()\n    ok3 = patch_sitecustomize()\n    print(\"\\nSummary:\")\n    print(f\"  live.py patched:        {ok1}\")\n    print(f\"  orders_cooldown_addon:  {ok2}\")\n    print(f\"  sitecustomize.py:       {ok3}\")\n    print(\"\\nDone.\")\nif __name__ == \"__main__\":",
        "detail": "apply_live_orders_cooldown_patch",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "apply_live_orders_cooldown_patch",
        "description": "apply_live_orders_cooldown_patch",
        "peekOfCode": "BASE = Path(__file__).resolve().parent\nLIVE = BASE / \"runner\" / \"live.py\"\nSITE = BASE / \"sitecustomize.py\"\nORDERS_ADDON = BASE / \"exchange\" / \"orders_cooldown_addon.py\"\ndef read(p: Path) -> str:\n    return p.read_text(encoding=\"utf-8\")\ndef write(p: Path, txt: str):\n    p.parent.mkdir(parents=True, exist_ok=True)\n    p.write_text(txt, encoding=\"utf-8\")\ndef backup(p: Path, suffix: str):",
        "detail": "apply_live_orders_cooldown_patch",
        "documentation": {}
    },
    {
        "label": "LIVE",
        "kind": 5,
        "importPath": "apply_live_orders_cooldown_patch",
        "description": "apply_live_orders_cooldown_patch",
        "peekOfCode": "LIVE = BASE / \"runner\" / \"live.py\"\nSITE = BASE / \"sitecustomize.py\"\nORDERS_ADDON = BASE / \"exchange\" / \"orders_cooldown_addon.py\"\ndef read(p: Path) -> str:\n    return p.read_text(encoding=\"utf-8\")\ndef write(p: Path, txt: str):\n    p.parent.mkdir(parents=True, exist_ok=True)\n    p.write_text(txt, encoding=\"utf-8\")\ndef backup(p: Path, suffix: str):\n    b = p.with_name(p.name + suffix)",
        "detail": "apply_live_orders_cooldown_patch",
        "documentation": {}
    },
    {
        "label": "SITE",
        "kind": 5,
        "importPath": "apply_live_orders_cooldown_patch",
        "description": "apply_live_orders_cooldown_patch",
        "peekOfCode": "SITE = BASE / \"sitecustomize.py\"\nORDERS_ADDON = BASE / \"exchange\" / \"orders_cooldown_addon.py\"\ndef read(p: Path) -> str:\n    return p.read_text(encoding=\"utf-8\")\ndef write(p: Path, txt: str):\n    p.parent.mkdir(parents=True, exist_ok=True)\n    p.write_text(txt, encoding=\"utf-8\")\ndef backup(p: Path, suffix: str):\n    b = p.with_name(p.name + suffix)\n    try:",
        "detail": "apply_live_orders_cooldown_patch",
        "documentation": {}
    },
    {
        "label": "ORDERS_ADDON",
        "kind": 5,
        "importPath": "apply_live_orders_cooldown_patch",
        "description": "apply_live_orders_cooldown_patch",
        "peekOfCode": "ORDERS_ADDON = BASE / \"exchange\" / \"orders_cooldown_addon.py\"\ndef read(p: Path) -> str:\n    return p.read_text(encoding=\"utf-8\")\ndef write(p: Path, txt: str):\n    p.parent.mkdir(parents=True, exist_ok=True)\n    p.write_text(txt, encoding=\"utf-8\")\ndef backup(p: Path, suffix: str):\n    b = p.with_name(p.name + suffix)\n    try:\n        if p.exists():",
        "detail": "apply_live_orders_cooldown_patch",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "apply_live_orders_cooldown_patch",
        "description": "apply_live_orders_cooldown_patch",
        "peekOfCode": "log = logging.getLogger(\"orders_addon\")\ntry:\n    from exchange.orders import OrderManager\nexcept Exception as e:\n    print(\"orders_addon: cannot import OrderManager:\", e)\n    OrderManager = None\nif OrderManager is not None:\n    # class-level store (simple & cross-instances)\n    if not hasattr(OrderManager, \"_cooldowns\"):\n        OrderManager._cooldowns = {}",
        "detail": "apply_live_orders_cooldown_patch",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_live_signal_risk_guardrails_v8",
        "description": "apply_live_signal_risk_guardrails_v8",
        "peekOfCode": "def main():\n    if not LIVE_PATH.exists():\n        print(f\"File not found: {LIVE_PATH}\")\n        sys.exit(1)\n    src = LIVE_PATH.read_text(encoding=\"utf-8\")\n    # 0) Ensure \"import time\" exists at module level (safe duplicate ok)\n    if \"import time\" not in src:\n        # insert after first import block\n        src = src.replace(\"import os\", \"import os\\nimport time\")\n    # 1) Replace body of async def _process_trading_cycle(...)",
        "detail": "apply_live_signal_risk_guardrails_v8",
        "documentation": {}
    },
    {
        "label": "LIVE_PATH",
        "kind": 5,
        "importPath": "apply_live_signal_risk_guardrails_v8",
        "description": "apply_live_signal_risk_guardrails_v8",
        "peekOfCode": "LIVE_PATH = Path(\"runner\") / \"live.py\"\nNEW_BODY = r'''\n        \"\"\"\n        Process one complete trading cycle (v8 guardrails):\n        - normalize signals (accept dicts/objects; map id/signal_id)\n        - call generate_signal with keyword (symbol=...)\n        - coerce position size to float (handle tuples)\n        - optional cooldown check if method exists\n        \"\"\"\n        import time",
        "detail": "apply_live_signal_risk_guardrails_v8",
        "documentation": {}
    },
    {
        "label": "NEW_BODY",
        "kind": 5,
        "importPath": "apply_live_signal_risk_guardrails_v8",
        "description": "apply_live_signal_risk_guardrails_v8",
        "peekOfCode": "NEW_BODY = r'''\n        \"\"\"\n        Process one complete trading cycle (v8 guardrails):\n        - normalize signals (accept dicts/objects; map id/signal_id)\n        - call generate_signal with keyword (symbol=...)\n        - coerce position size to float (handle tuples)\n        - optional cooldown check if method exists\n        \"\"\"\n        import time\n        from datetime import datetime",
        "detail": "apply_live_signal_risk_guardrails_v8",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_marketdata_provider_stub_fix",
        "description": "apply_marketdata_provider_stub_fix",
        "peekOfCode": "def main():\n    if MD_PATH.exists():\n        backup = MD_PATH.with_suffix(\".bak_marketdata_stub\")\n        shutil.copy2(MD_PATH, backup)\n        txt = MD_PATH.read_text(encoding=\"utf-8\", errors=\"ignore\")\n        if \"class MarketDataProvider\" in txt:\n            # Класс уже есть — ничего не делаем\n            print(\"✔ exchange/market_data.py уже содержит MarketDataProvider (патч не нужен)\")\n            return\n        # Аппендим stub в конец (ничего не затираем)",
        "detail": "apply_marketdata_provider_stub_fix",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "apply_marketdata_provider_stub_fix",
        "description": "apply_marketdata_provider_stub_fix",
        "peekOfCode": "BASE = Path(__file__).resolve().parent\nMD_PATH = BASE / \"exchange\" / \"market_data.py\"\nSTUB = r'''\n# --- AUTO-ADDED SAFE STUB: MarketDataProvider ---------------------------------\n# Этот блок добавляется только если класс MarketDataProvider ещё не определён\n# в модуле. Ничего не ломает и не конфликтует с вашей логикой.\ntry:\n    MarketDataProvider  # type: ignore[name-defined]\nexcept NameError:  # nosec - проверяем наличие имени в модуле\n    import asyncio",
        "detail": "apply_marketdata_provider_stub_fix",
        "documentation": {}
    },
    {
        "label": "MD_PATH",
        "kind": 5,
        "importPath": "apply_marketdata_provider_stub_fix",
        "description": "apply_marketdata_provider_stub_fix",
        "peekOfCode": "MD_PATH = BASE / \"exchange\" / \"market_data.py\"\nSTUB = r'''\n# --- AUTO-ADDED SAFE STUB: MarketDataProvider ---------------------------------\n# Этот блок добавляется только если класс MarketDataProvider ещё не определён\n# в модуле. Ничего не ломает и не конфликтует с вашей логикой.\ntry:\n    MarketDataProvider  # type: ignore[name-defined]\nexcept NameError:  # nosec - проверяем наличие имени в модуле\n    import asyncio\n    import logging",
        "detail": "apply_marketdata_provider_stub_fix",
        "documentation": {}
    },
    {
        "label": "STUB",
        "kind": 5,
        "importPath": "apply_marketdata_provider_stub_fix",
        "description": "apply_marketdata_provider_stub_fix",
        "peekOfCode": "STUB = r'''\n# --- AUTO-ADDED SAFE STUB: MarketDataProvider ---------------------------------\n# Этот блок добавляется только если класс MarketDataProvider ещё не определён\n# в модуле. Ничего не ломает и не конфликтует с вашей логикой.\ntry:\n    MarketDataProvider  # type: ignore[name-defined]\nexcept NameError:  # nosec - проверяем наличие имени в модуле\n    import asyncio\n    import logging\n    from typing import Dict, List, Optional, Any",
        "detail": "apply_marketdata_provider_stub_fix",
        "documentation": {}
    },
    {
        "label": "backup",
        "kind": 2,
        "importPath": "apply_orders_enum_compat_patch",
        "description": "apply_orders_enum_compat_patch",
        "peekOfCode": "def backup(p: Path, suf=\".bak_orders\"): \n    if p.exists(): shutil.copy2(p, p.with_suffix(p.suffix + suf))\ndef inject_helpers(txt: str) -> tuple[str,bool]:\n    if \"_as_side\" in txt: return txt, False\n    # вставим helpers после импортов\n    lines = txt.splitlines(); idx = 0\n    for i,l in enumerate(lines[:120]):\n        if l.strip().startswith((\"import \",\"from \")): idx = i+1\n        elif l.strip()==\"\" or l.strip().startswith((\"#\",'\"\"\"',\"'''\")): continue\n        else: break",
        "detail": "apply_orders_enum_compat_patch",
        "documentation": {}
    },
    {
        "label": "inject_helpers",
        "kind": 2,
        "importPath": "apply_orders_enum_compat_patch",
        "description": "apply_orders_enum_compat_patch",
        "peekOfCode": "def inject_helpers(txt: str) -> tuple[str,bool]:\n    if \"_as_side\" in txt: return txt, False\n    # вставим helpers после импортов\n    lines = txt.splitlines(); idx = 0\n    for i,l in enumerate(lines[:120]):\n        if l.strip().startswith((\"import \",\"from \")): idx = i+1\n        elif l.strip()==\"\" or l.strip().startswith((\"#\",'\"\"\"',\"'''\")): continue\n        else: break\n    new = lines[:idx] + [HELPERS.strip(),\"\"] + lines[idx:]\n    return \"\\n\".join(new)+(\"\\n\" if not txt.endswith(\"\\n\") else \"\"), True",
        "detail": "apply_orders_enum_compat_patch",
        "documentation": {}
    },
    {
        "label": "normalize_header",
        "kind": 2,
        "importPath": "apply_orders_enum_compat_patch",
        "description": "apply_orders_enum_compat_patch",
        "peekOfCode": "def normalize_header(txt: str, fname: str, assigns: list[str]) -> tuple[str,bool]:\n    pat = re.compile(rf\"(def\\s+{fname}\\s*\\([^)]*\\)\\s*:\\s*\\n)(\\s+)\")\n    m = pat.search(txt); \n    if not m: return txt, False\n    start = m.end(1); indent = m.group(2)\n    body = txt[start:start+500]\n    if all(a in body for a in assigns): return txt, False\n    patch = \"\".join(f\"{indent}{a}\\n\" for a in assigns)\n    return txt[:start]+patch+txt[start:], True\ndef replace_value(txt: str) -> tuple[str,bool]:",
        "detail": "apply_orders_enum_compat_patch",
        "documentation": {}
    },
    {
        "label": "replace_value",
        "kind": 2,
        "importPath": "apply_orders_enum_compat_patch",
        "description": "apply_orders_enum_compat_patch",
        "peekOfCode": "def replace_value(txt: str) -> tuple[str,bool]:\n    changed=False; out=txt\n    maps = {\n        r\"\\bside\\.value\\b\":\"side\",\n        r\"\\btime_in_force\\.value\\b\":\"time_in_force\",\n        r\"\\btimeInForce\\.value\\b\":\"timeInForce\",\n        r\"\\bworking_type\\.value\\b\":\"working_type\",\n        r\"\\bworkingType\\.value\\b\":\"workingType\",\n    }\n    for p,r in maps.items():",
        "detail": "apply_orders_enum_compat_patch",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_orders_enum_compat_patch",
        "description": "apply_orders_enum_compat_patch",
        "peekOfCode": "def main():\n    if not ORDERS.exists():\n        print(f\"{WARN} {ORDERS} not found\"); return\n    backup(ORDERS)\n    txt = ORDERS.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    anyc=False\n    txt1,ch1 = inject_helpers(txt); anyc|=ch1\n    txt2,ch2 = normalize_header(txt1,\"place_market_order\",[\"try:\\n        side = _as_side(side)\\n    except NameError:\\n        pass\"]); anyc|=ch2\n    txt3,ch3 = normalize_header(txt2,\"place_limit_order\",[\n        \"try:\\n        side = _as_side(side)\\n    except NameError:\\n        pass\",",
        "detail": "apply_orders_enum_compat_patch",
        "documentation": {}
    },
    {
        "label": "OK",
        "kind": 5,
        "importPath": "apply_orders_enum_compat_patch",
        "description": "apply_orders_enum_compat_patch",
        "peekOfCode": "OK = \"\\u2705\"; WARN = \"\\u26A0\\uFE0F\"\nBASE = Path(__file__).resolve().parent\nORDERS = BASE / \"exchange\" / \"orders.py\"\nHELPERS = '''\n# --- ENUM/str normalization helpers (idempotent) ---\ndef _as_side(v):\n    try: return v.value\n    except Exception:\n        s = str(v).upper()\n        if s in (\"BUY\",\"SELL\"): return s",
        "detail": "apply_orders_enum_compat_patch",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "apply_orders_enum_compat_patch",
        "description": "apply_orders_enum_compat_patch",
        "peekOfCode": "BASE = Path(__file__).resolve().parent\nORDERS = BASE / \"exchange\" / \"orders.py\"\nHELPERS = '''\n# --- ENUM/str normalization helpers (idempotent) ---\ndef _as_side(v):\n    try: return v.value\n    except Exception:\n        s = str(v).upper()\n        if s in (\"BUY\",\"SELL\"): return s\n        if s in (\"LONG\",\"+\",\"B\",\"OPEN_LONG\"):  return \"BUY\"",
        "detail": "apply_orders_enum_compat_patch",
        "documentation": {}
    },
    {
        "label": "ORDERS",
        "kind": 5,
        "importPath": "apply_orders_enum_compat_patch",
        "description": "apply_orders_enum_compat_patch",
        "peekOfCode": "ORDERS = BASE / \"exchange\" / \"orders.py\"\nHELPERS = '''\n# --- ENUM/str normalization helpers (idempotent) ---\ndef _as_side(v):\n    try: return v.value\n    except Exception:\n        s = str(v).upper()\n        if s in (\"BUY\",\"SELL\"): return s\n        if s in (\"LONG\",\"+\",\"B\",\"OPEN_LONG\"):  return \"BUY\"\n        if s in (\"SHORT\",\"-\",\"S\",\"OPEN_SHORT\"): return \"SELL\"",
        "detail": "apply_orders_enum_compat_patch",
        "documentation": {}
    },
    {
        "label": "HELPERS",
        "kind": 5,
        "importPath": "apply_orders_enum_compat_patch",
        "description": "apply_orders_enum_compat_patch",
        "peekOfCode": "HELPERS = '''\n# --- ENUM/str normalization helpers (idempotent) ---\ndef _as_side(v):\n    try: return v.value\n    except Exception:\n        s = str(v).upper()\n        if s in (\"BUY\",\"SELL\"): return s\n        if s in (\"LONG\",\"+\",\"B\",\"OPEN_LONG\"):  return \"BUY\"\n        if s in (\"SHORT\",\"-\",\"S\",\"OPEN_SHORT\"): return \"SELL\"\n        return \"BUY\"",
        "detail": "apply_orders_enum_compat_patch",
        "documentation": {}
    },
    {
        "label": "TradeExecutor",
        "kind": 6,
        "importPath": "apply_patches",
        "description": "apply_patches",
        "peekOfCode": "class TradeExecutor:\n    def __init__(self, client: Optional[BinanceClient] = None):\n        self.cfg = get_config()\n        self.client = client or BinanceClient()\n    def _position_side_from_signal(self, signal_type: str) -> str:\n        s = str(signal_type or \"\").upper()\n        return \"LONG\" if s == \"BUY\" else \"SHORT\"\n    def _entry_side_from_signal(self, signal_type: str) -> str:\n        s = str(signal_type or \"\").upper()\n        return \"BUY\" if s == \"BUY\" else \"SELL\"",
        "detail": "apply_patches",
        "documentation": {}
    },
    {
        "label": "ensure_sl_on_exchange",
        "kind": 2,
        "importPath": "apply_patches",
        "description": "apply_patches",
        "peekOfCode": "def ensure_sl_on_exchange(\n    client: BinanceClient,\n    symbol: str,\n    position_side: str,\n    stop_price: float,\n    working_type: str = \"MARK_PRICE\",\n    eps_ticks: int = 3,\n) -> Dict[str, Any]:\n    cfg = get_config()\n    if not getattr(cfg, \"place_exits_on_exchange\", True):",
        "detail": "apply_patches",
        "documentation": {}
    },
    {
        "label": "ensure_tp_on_exchange",
        "kind": 2,
        "importPath": "apply_patches",
        "description": "apply_patches",
        "peekOfCode": "def ensure_tp_on_exchange(\n    client: BinanceClient,\n    symbol: str,\n    position_side: str,\n    qty: float,\n    entry_price: float,\n    tp_levels_pct: List[float],\n    tp_shares: List[float],\n    tif: str = \"GTC\",\n    tp_prefix: str = \"TP-\",",
        "detail": "apply_patches",
        "documentation": {}
    },
    {
        "label": "ensure_exits_on_exchange",
        "kind": 2,
        "importPath": "apply_patches",
        "description": "apply_patches",
        "peekOfCode": "def ensure_exits_on_exchange(\n    client: BinanceClient,\n    symbol: str,\n    position_side: str,\n    qty: float,\n    entry_price: float,\n    stop_price: float,\n    tp_levels_pct: List[float],\n    tp_shares: List[float],\n    working_type: str = \"MARK_PRICE\",",
        "detail": "apply_patches",
        "documentation": {}
    },
    {
        "label": "write_file",
        "kind": 2,
        "importPath": "apply_patches",
        "description": "apply_patches",
        "peekOfCode": "def write_file(path: Path, content: str, exist_ok: bool = True) -> bool:\n    path.parent.mkdir(parents=True, exist_ok=True)\n    if path.exists() and exist_ok:\n        # keep if identical\n        old = path.read_text(encoding=\"utf-8\", errors=\"ignore\")\n        if old == content:\n            return False\n    path.write_text(content, encoding=\"utf-8\")\n    return True\ndef backup(path: Path):",
        "detail": "apply_patches",
        "documentation": {}
    },
    {
        "label": "backup",
        "kind": 2,
        "importPath": "apply_patches",
        "description": "apply_patches",
        "peekOfCode": "def backup(path: Path):\n    if path.exists():\n        shutil.copy2(path, path.with_suffix(path.suffix + \".bak\"))\ndef ensure_imports(text: str) -> tuple[str, bool]:\n    changed = False\n    lines = text.splitlines()\n    has_os = any(l.strip() == \"import os\" or l.strip().startswith(\"import os,\") for l in lines)\n    has_exec = any(\"from runner.execution import TradeExecutor\" in l for l in lines)\n    # find import block end\n    insert_idx = 0",
        "detail": "apply_patches",
        "documentation": {}
    },
    {
        "label": "ensure_imports",
        "kind": 2,
        "importPath": "apply_patches",
        "description": "apply_patches",
        "peekOfCode": "def ensure_imports(text: str) -> tuple[str, bool]:\n    changed = False\n    lines = text.splitlines()\n    has_os = any(l.strip() == \"import os\" or l.strip().startswith(\"import os,\") for l in lines)\n    has_exec = any(\"from runner.execution import TradeExecutor\" in l for l in lines)\n    # find import block end\n    insert_idx = 0\n    for i, l in enumerate(lines[:50]):  # only top\n        if l.strip().startswith((\"import \", \"from \")):\n            insert_idx = i + 1",
        "detail": "apply_patches",
        "documentation": {}
    },
    {
        "label": "fix_executor_init",
        "kind": 2,
        "importPath": "apply_patches",
        "description": "apply_patches",
        "peekOfCode": "def fix_executor_init(text: str) -> tuple[str, bool]:\n    changed = False\n    new = text\n    # 1) replace explicit client pass\n    pat = re.compile(r\"self\\.trade_executor\\s*=\\s*TradeExecutor\\s*\\(\\s*client\\s*=\\s*self\\.client[^)]*\\)\", re.MULTILINE)\n    if pat.search(new):\n        new = pat.sub(\"self.trade_executor = TradeExecutor()\", new)\n        changed = True\n    # 2) ensure self.trade_executor created in __init__ if missing\n    if \"self.trade_executor = TradeExecutor()\" not in new:",
        "detail": "apply_patches",
        "documentation": {}
    },
    {
        "label": "ensure_client_binding",
        "kind": 2,
        "importPath": "apply_patches",
        "description": "apply_patches",
        "peekOfCode": "def ensure_client_binding(text: str) -> tuple[str, bool]:\n    changed = False\n    lines = text.splitlines()\n    new_lines = []\n    i = 0\n    while i < len(lines):\n        l = lines[i]\n        new_lines.append(l)\n        m = re.search(r\"self\\.client\\s*=\\s*.+\", l)\n        if m:",
        "detail": "apply_patches",
        "documentation": {}
    },
    {
        "label": "patch_file",
        "kind": 2,
        "importPath": "apply_patches",
        "description": "apply_patches",
        "peekOfCode": "def patch_file(p: Path) -> bool:\n    if not p.exists():\n        print(f\"{WARN} {p} not found, skip\")\n        return False\n    backup(p)\n    txt = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    any_change = False\n    txt1, ch1 = ensure_imports(txt); any_change |= ch1\n    txt2, ch2 = fix_executor_init(txt1); any_change |= ch2\n    txt3, ch3 = ensure_client_binding(txt2); any_change |= ch3",
        "detail": "apply_patches",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_patches",
        "description": "apply_patches",
        "peekOfCode": "def main():\n    created = 0\n    changed = 0\n    # 1) new files\n    ex_path = BASE / \"exchange\" / \"exits_addon.py\"\n    if write_file(ex_path, EXITS_ADDON, exist_ok=True):\n        created += 1\n        print(f\"{OK} Created/updated {ex_path.relative_to(BASE)}\")\n    else:\n        print(f\"{OK} {ex_path.relative_to(BASE)} up-to-date\")",
        "detail": "apply_patches",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "apply_patches",
        "description": "apply_patches",
        "peekOfCode": "BASE = Path(__file__).resolve().parent  # предполагаем запуск из crypto_trading_bot/work\nOK = \"\\u2705\"\nWARN = \"\\u26A0\\uFE0F\"\n# ---------- contents: new files ----------\nEXITS_ADDON = r'''# exchange/exits_addon.py\nfrom __future__ import annotations\nimport logging, time\nfrom decimal import Decimal, ROUND_DOWN\nfrom typing import Any, Dict, List, Optional\nfrom core.config import get_config",
        "detail": "apply_patches",
        "documentation": {}
    },
    {
        "label": "OK",
        "kind": 5,
        "importPath": "apply_patches",
        "description": "apply_patches",
        "peekOfCode": "OK = \"\\u2705\"\nWARN = \"\\u26A0\\uFE0F\"\n# ---------- contents: new files ----------\nEXITS_ADDON = r'''# exchange/exits_addon.py\nfrom __future__ import annotations\nimport logging, time\nfrom decimal import Decimal, ROUND_DOWN\nfrom typing import Any, Dict, List, Optional\nfrom core.config import get_config\nfrom exchange.client import BinanceClient",
        "detail": "apply_patches",
        "documentation": {}
    },
    {
        "label": "WARN",
        "kind": 5,
        "importPath": "apply_patches",
        "description": "apply_patches",
        "peekOfCode": "WARN = \"\\u26A0\\uFE0F\"\n# ---------- contents: new files ----------\nEXITS_ADDON = r'''# exchange/exits_addon.py\nfrom __future__ import annotations\nimport logging, time\nfrom decimal import Decimal, ROUND_DOWN\nfrom typing import Any, Dict, List, Optional\nfrom core.config import get_config\nfrom exchange.client import BinanceClient\nlog = logging.getLogger(__name__)",
        "detail": "apply_patches",
        "documentation": {}
    },
    {
        "label": "EXITS_ADDON",
        "kind": 5,
        "importPath": "apply_patches",
        "description": "apply_patches",
        "peekOfCode": "EXITS_ADDON = r'''# exchange/exits_addon.py\nfrom __future__ import annotations\nimport logging, time\nfrom decimal import Decimal, ROUND_DOWN\nfrom typing import Any, Dict, List, Optional\nfrom core.config import get_config\nfrom exchange.client import BinanceClient\nlog = logging.getLogger(__name__)\n_FILTERS: Dict[str, Dict[str, float]] = {}\n_EXIT_STATE: Dict[str, Dict[str, float]] = {}",
        "detail": "apply_patches",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "apply_patches",
        "description": "apply_patches",
        "peekOfCode": "log = logging.getLogger(__name__)\n_FILTERS: Dict[str, Dict[str, float]] = {}\n_EXIT_STATE: Dict[str, Dict[str, float]] = {}\ndef _dec_floor(x: float, step: float) -> float:\n    if step <= 0:\n        return float(x)\n    q = Decimal(str(step))\n    return float(Decimal(str(x)).quantize(q, rounding=ROUND_DOWN))\ndef _side_to_str(side: str) -> str:\n    s = str(side or \"\").upper()",
        "detail": "apply_patches",
        "documentation": {}
    },
    {
        "label": "EXECUTION",
        "kind": 5,
        "importPath": "apply_patches",
        "description": "apply_patches",
        "peekOfCode": "EXECUTION = r'''# runner/execution.py\nfrom __future__ import annotations\nimport logging, time\nfrom typing import Dict, Any, Optional, List\nfrom core.config import get_config\nfrom exchange.client import BinanceClient\nfrom exchange.exits_addon import ensure_exits_on_exchange\nlog = logging.getLogger(__name__)\nclass TradeExecutor:\n    def __init__(self, client: Optional[BinanceClient] = None):",
        "detail": "apply_patches",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "apply_patches",
        "description": "apply_patches",
        "peekOfCode": "log = logging.getLogger(__name__)\nclass TradeExecutor:\n    def __init__(self, client: Optional[BinanceClient] = None):\n        self.cfg = get_config()\n        self.client = client or BinanceClient()\n    def _position_side_from_signal(self, signal_type: str) -> str:\n        s = str(signal_type or \"\").upper()\n        return \"LONG\" if s == \"BUY\" else \"SHORT\"\n    def _entry_side_from_signal(self, signal_type: str) -> str:\n        s = str(signal_type or \"\").upper()",
        "detail": "apply_patches",
        "documentation": {}
    },
    {
        "label": "backup",
        "kind": 2,
        "importPath": "apply_runner_trace_patch",
        "description": "apply_runner_trace_patch",
        "peekOfCode": "def backup(p: Path, suf=\".bak_trace\"):\n    if p.exists(): shutil.copy2(p, p.with_suffix(p.suffix + suf))\ndef patch_file(p: Path):\n    if not p.exists():\n        print(f\"{WARN} {p} not found, skip\"); return\n    txt = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    changed=False\n    # типовая замена только в блоках 'except Exception as e: logger.error(...'\n    new = re.sub(r\"(\\.logger)\\.error\\(([^)]+)\\)\", r\"\\1.exception(\\2)\", txt)\n    if new != txt:",
        "detail": "apply_runner_trace_patch",
        "documentation": {}
    },
    {
        "label": "patch_file",
        "kind": 2,
        "importPath": "apply_runner_trace_patch",
        "description": "apply_runner_trace_patch",
        "peekOfCode": "def patch_file(p: Path):\n    if not p.exists():\n        print(f\"{WARN} {p} not found, skip\"); return\n    txt = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    changed=False\n    # типовая замена только в блоках 'except Exception as e: logger.error(...'\n    new = re.sub(r\"(\\.logger)\\.error\\(([^)]+)\\)\", r\"\\1.exception(\\2)\", txt)\n    if new != txt:\n        backup(p); p.write_text(new, encoding=\"utf-8\"); changed=True\n        print(f\"{OK} Patched {p.relative_to(BASE)} (exception trace enabled)\")",
        "detail": "apply_runner_trace_patch",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_runner_trace_patch",
        "description": "apply_runner_trace_patch",
        "peekOfCode": "def main():\n    for rel in (\"runner/paper.py\", \"runner/live.py\"):\n        patch_file(BASE / rel)\n    print(\"\\\\nDone.\")\nif __name__ == \"__main__\":\n    main()",
        "detail": "apply_runner_trace_patch",
        "documentation": {}
    },
    {
        "label": "OK",
        "kind": 5,
        "importPath": "apply_runner_trace_patch",
        "description": "apply_runner_trace_patch",
        "peekOfCode": "OK = \"\\u2705\"; WARN = \"\\u26A0\\uFE0F\"\nBASE = Path(__file__).resolve().parent\ndef backup(p: Path, suf=\".bak_trace\"):\n    if p.exists(): shutil.copy2(p, p.with_suffix(p.suffix + suf))\ndef patch_file(p: Path):\n    if not p.exists():\n        print(f\"{WARN} {p} not found, skip\"); return\n    txt = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    changed=False\n    # типовая замена только в блоках 'except Exception as e: logger.error(...'",
        "detail": "apply_runner_trace_patch",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "apply_runner_trace_patch",
        "description": "apply_runner_trace_patch",
        "peekOfCode": "BASE = Path(__file__).resolve().parent\ndef backup(p: Path, suf=\".bak_trace\"):\n    if p.exists(): shutil.copy2(p, p.with_suffix(p.suffix + suf))\ndef patch_file(p: Path):\n    if not p.exists():\n        print(f\"{WARN} {p} not found, skip\"); return\n    txt = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    changed=False\n    # типовая замена только в блоках 'except Exception as e: logger.error(...'\n    new = re.sub(r\"(\\.logger)\\.error\\(([^)]+)\\)\", r\"\\1.exception(\\2)\", txt)",
        "detail": "apply_runner_trace_patch",
        "documentation": {}
    },
    {
        "label": "insert_block",
        "kind": 2,
        "importPath": "apply_signals_input_adapter_patch",
        "description": "apply_signals_input_adapter_patch",
        "peekOfCode": "def insert_block(txt:str)->str:\n    if \"def _coerce_market_input(\" in txt:\n        return txt\n    # вставим после импортов\n    lines = txt.splitlines(True)\n    ins = 0\n    for i,l in enumerate(lines[:200]):\n        if l.strip().startswith((\"import \",\"from \")):\n            ins = i+1\n        elif l.strip()==\"\" or l.lstrip().startswith((\"#\",'\"\"\"',\"'''\")):",
        "detail": "apply_signals_input_adapter_patch",
        "documentation": {}
    },
    {
        "label": "tune_generate_signal",
        "kind": 2,
        "importPath": "apply_signals_input_adapter_patch",
        "description": "apply_signals_input_adapter_patch",
        "peekOfCode": "def tune_generate_signal(txt:str)->str:\n    # На старте тела функции generate_signal(...) добавим:\n    #   price, klike = _coerce_market_input(symbol, market_data)\n    pat = re.compile(r'^(\\s*)(?:async\\s+)?def\\s+generate_signal\\s*\\(([^)]*)\\)\\s*:\\s*$', re.M)\n    m = pat.search(txt)\n    if not m: return txt\n    indent = m.group(1)\n    # найдём первую строку тела\n    start = m.end()\n    # найдём конец сигнатуры/докстроки",
        "detail": "apply_signals_input_adapter_patch",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_signals_input_adapter_patch",
        "description": "apply_signals_input_adapter_patch",
        "peekOfCode": "def main():\n    if not TARGET.exists():\n        print(f\"{WARN} {TARGET} not found\"); return\n    src = TARGET.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    new = insert_block(src)\n    newer = tune_generate_signal(new)\n    if newer != src:\n        backup = TARGET.with_suffix(TARGET.suffix + \".bak_input\")\n        shutil.copy2(TARGET, backup)\n        TARGET.write_text(newer, encoding=\"utf-8\")",
        "detail": "apply_signals_input_adapter_patch",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "apply_signals_input_adapter_patch",
        "description": "apply_signals_input_adapter_patch",
        "peekOfCode": "BASE = Path(__file__).resolve().parent\nTARGET = BASE / \"strategy\" / \"signals.py\"\nBLOCK = r'''\n# --- INPUT ADAPTER (idempotent) ---\ndef _coerce_market_input(symbol, market_data):\n    \"\"\"\n    Превращаем разношёрстный market_data в (price, klines_like) без падений.\n    price: float|None\n    klines_like: list[(ts,o,h,l,c)]|None\n    \"\"\"",
        "detail": "apply_signals_input_adapter_patch",
        "documentation": {}
    },
    {
        "label": "TARGET",
        "kind": 5,
        "importPath": "apply_signals_input_adapter_patch",
        "description": "apply_signals_input_adapter_patch",
        "peekOfCode": "TARGET = BASE / \"strategy\" / \"signals.py\"\nBLOCK = r'''\n# --- INPUT ADAPTER (idempotent) ---\ndef _coerce_market_input(symbol, market_data):\n    \"\"\"\n    Превращаем разношёрстный market_data в (price, klines_like) без падений.\n    price: float|None\n    klines_like: list[(ts,o,h,l,c)]|None\n    \"\"\"\n    sym = str(symbol or \"UNKNOWN\").upper()",
        "detail": "apply_signals_input_adapter_patch",
        "documentation": {}
    },
    {
        "label": "BLOCK",
        "kind": 5,
        "importPath": "apply_signals_input_adapter_patch",
        "description": "apply_signals_input_adapter_patch",
        "peekOfCode": "BLOCK = r'''\n# --- INPUT ADAPTER (idempotent) ---\ndef _coerce_market_input(symbol, market_data):\n    \"\"\"\n    Превращаем разношёрстный market_data в (price, klines_like) без падений.\n    price: float|None\n    klines_like: list[(ts,o,h,l,c)]|None\n    \"\"\"\n    sym = str(symbol or \"UNKNOWN\").upper()\n    price = None",
        "detail": "apply_signals_input_adapter_patch",
        "documentation": {}
    },
    {
        "label": "backup",
        "kind": 2,
        "importPath": "apply_signals_module_sig_global_patch",
        "description": "apply_signals_module_sig_global_patch",
        "peekOfCode": "def backup(p: Path, suf=\".bak_sigglobal\"):\n    if p.exists():\n        shutil.copy2(p, p.with_suffix(p.suffix + suf))\ndef find_insert_index(lines):\n    i = 0\n    # shebang / encoding\n    if i < len(lines) and lines[i].startswith(\"#!\"):\n        i += 1\n    if i < len(lines) and \"coding\" in lines[i]:\n        i += 1",
        "detail": "apply_signals_module_sig_global_patch",
        "documentation": {}
    },
    {
        "label": "find_insert_index",
        "kind": 2,
        "importPath": "apply_signals_module_sig_global_patch",
        "description": "apply_signals_module_sig_global_patch",
        "peekOfCode": "def find_insert_index(lines):\n    i = 0\n    # shebang / encoding\n    if i < len(lines) and lines[i].startswith(\"#!\"):\n        i += 1\n    if i < len(lines) and \"coding\" in lines[i]:\n        i += 1\n    # пустые/комментарии\n    while i < len(lines) and (lines[i].strip() == \"\" or lines[i].lstrip().startswith(\"#\")):\n        i += 1",
        "detail": "apply_signals_module_sig_global_patch",
        "documentation": {}
    },
    {
        "label": "patch_text",
        "kind": 2,
        "importPath": "apply_signals_module_sig_global_patch",
        "description": "apply_signals_module_sig_global_patch",
        "peekOfCode": "def patch_text(txt: str) -> tuple[str, bool]:\n    # если блок уже вставлен — пропускаем\n    if \"Auto-guards for legacy 'sig' logging\" in txt:\n        return txt, False\n    lines = txt.splitlines(True)\n    ins_idx = find_insert_index(lines)\n    lines[ins_idx:ins_idx] = [GUARD_BLOCK + \"\\n\"]\n    return \"\".join(lines), True\ndef main():\n    if not TARGET.exists():",
        "detail": "apply_signals_module_sig_global_patch",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_signals_module_sig_global_patch",
        "description": "apply_signals_module_sig_global_patch",
        "peekOfCode": "def main():\n    if not TARGET.exists():\n        print(f\"{WARN} {TARGET} not found. Abort.\"); return\n    src = TARGET.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    new, changed = patch_text(src)\n    if changed:\n        backup(TARGET)\n        TARGET.write_text(new, encoding=\"utf-8\")\n        print(f\"{OK} Patched {TARGET.relative_to(BASE)} (module-level guards added)\")\n    else:",
        "detail": "apply_signals_module_sig_global_patch",
        "documentation": {}
    },
    {
        "label": "WARN",
        "kind": 5,
        "importPath": "apply_signals_module_sig_global_patch",
        "description": "apply_signals_module_sig_global_patch",
        "peekOfCode": "WARN = \"\\u26A0\\uFE0F\"\nBASE   = Path(__file__).resolve().parent\nTARGET = BASE / \"strategy\" / \"signals.py\"\nGUARD_BLOCK = \"\"\"# --- Auto-guards for legacy 'sig' logging (idempotent) ---\ntry:\n    sig\nexcept NameError:\n    sig = None\ntry:\n    signal",
        "detail": "apply_signals_module_sig_global_patch",
        "documentation": {}
    },
    {
        "label": "TARGET",
        "kind": 5,
        "importPath": "apply_signals_module_sig_global_patch",
        "description": "apply_signals_module_sig_global_patch",
        "peekOfCode": "TARGET = BASE / \"strategy\" / \"signals.py\"\nGUARD_BLOCK = \"\"\"# --- Auto-guards for legacy 'sig' logging (idempotent) ---\ntry:\n    sig\nexcept NameError:\n    sig = None\ntry:\n    signal\nexcept NameError:\n    signal = None",
        "detail": "apply_signals_module_sig_global_patch",
        "documentation": {}
    },
    {
        "label": "GUARD_BLOCK",
        "kind": 5,
        "importPath": "apply_signals_module_sig_global_patch",
        "description": "apply_signals_module_sig_global_patch",
        "peekOfCode": "GUARD_BLOCK = \"\"\"# --- Auto-guards for legacy 'sig' logging (idempotent) ---\ntry:\n    sig\nexcept NameError:\n    sig = None\ntry:\n    signal\nexcept NameError:\n    signal = None\ntry:",
        "detail": "apply_signals_module_sig_global_patch",
        "documentation": {}
    },
    {
        "label": "backup",
        "kind": 2,
        "importPath": "apply_signals_sig_autoguard_all",
        "description": "apply_signals_sig_autoguard_all",
        "peekOfCode": "def backup(p: Path, suf=\".bak_sigguard_all\"):\n    if p.exists():\n        shutil.copy2(p, p.with_suffix(p.suffix + suf))\ndef leading_spaces(s: str) -> int:\n    return len(s) - len(s.lstrip(\" \"))\ndef is_def_or_class(line: str) -> bool:\n    return bool(re.match(r'^\\s*(?:async\\s+)?def\\s+\\w+\\s*\\(|^\\s*class\\s+\\w+\\s*\\(', line))\ndef find_func_block(lines, start_idx):\n    \"\"\"\n    На входе: индекс строки с 'def ...:'",
        "detail": "apply_signals_sig_autoguard_all",
        "documentation": {}
    },
    {
        "label": "leading_spaces",
        "kind": 2,
        "importPath": "apply_signals_sig_autoguard_all",
        "description": "apply_signals_sig_autoguard_all",
        "peekOfCode": "def leading_spaces(s: str) -> int:\n    return len(s) - len(s.lstrip(\" \"))\ndef is_def_or_class(line: str) -> bool:\n    return bool(re.match(r'^\\s*(?:async\\s+)?def\\s+\\w+\\s*\\(|^\\s*class\\s+\\w+\\s*\\(', line))\ndef find_func_block(lines, start_idx):\n    \"\"\"\n    На входе: индекс строки с 'def ...:'\n    Возвращает: (body_start_idx, body_indent_str, func_end_idx_exclusive)\n    \"\"\"\n    header = lines[start_idx]",
        "detail": "apply_signals_sig_autoguard_all",
        "documentation": {}
    },
    {
        "label": "is_def_or_class",
        "kind": 2,
        "importPath": "apply_signals_sig_autoguard_all",
        "description": "apply_signals_sig_autoguard_all",
        "peekOfCode": "def is_def_or_class(line: str) -> bool:\n    return bool(re.match(r'^\\s*(?:async\\s+)?def\\s+\\w+\\s*\\(|^\\s*class\\s+\\w+\\s*\\(', line))\ndef find_func_block(lines, start_idx):\n    \"\"\"\n    На входе: индекс строки с 'def ...:'\n    Возвращает: (body_start_idx, body_indent_str, func_end_idx_exclusive)\n    \"\"\"\n    header = lines[start_idx]\n    indent = re.match(r'^(\\s*)', header).group(1)\n    i = start_idx + 1",
        "detail": "apply_signals_sig_autoguard_all",
        "documentation": {}
    },
    {
        "label": "find_func_block",
        "kind": 2,
        "importPath": "apply_signals_sig_autoguard_all",
        "description": "apply_signals_sig_autoguard_all",
        "peekOfCode": "def find_func_block(lines, start_idx):\n    \"\"\"\n    На входе: индекс строки с 'def ...:'\n    Возвращает: (body_start_idx, body_indent_str, func_end_idx_exclusive)\n    \"\"\"\n    header = lines[start_idx]\n    indent = re.match(r'^(\\s*)', header).group(1)\n    i = start_idx + 1\n    # пропустим пустые строки\n    while i < len(lines) and lines[i].strip() == \"\":",
        "detail": "apply_signals_sig_autoguard_all",
        "documentation": {}
    },
    {
        "label": "function_uses_sig",
        "kind": 2,
        "importPath": "apply_signals_sig_autoguard_all",
        "description": "apply_signals_sig_autoguard_all",
        "peekOfCode": "def function_uses_sig(body_lines):\n    # есть ли упоминания sig в теле?\n    return any(re.search(r'\\bsig\\b', ln) for ln in body_lines)\ndef function_defines_sig_early(body_lines):\n    # определён ли sig в первых ~50 строках?\n    limit = min(50, len(body_lines))\n    for ln in body_lines[:limit]:\n        if re.match(r'^\\s*sig\\s*=', ln):  # присваивание\n            return True\n    return False",
        "detail": "apply_signals_sig_autoguard_all",
        "documentation": {}
    },
    {
        "label": "function_defines_sig_early",
        "kind": 2,
        "importPath": "apply_signals_sig_autoguard_all",
        "description": "apply_signals_sig_autoguard_all",
        "peekOfCode": "def function_defines_sig_early(body_lines):\n    # определён ли sig в первых ~50 строках?\n    limit = min(50, len(body_lines))\n    for ln in body_lines[:limit]:\n        if re.match(r'^\\s*sig\\s*=', ln):  # присваивание\n            return True\n    return False\ndef insert_guard(lines, body_start, body_indent):\n    guard = f\"{body_indent}sig = locals().get('signal', locals().get('trade_signal', None))  # auto-guard to avoid NameError\\n\"\n    lines.insert(body_start, guard)",
        "detail": "apply_signals_sig_autoguard_all",
        "documentation": {}
    },
    {
        "label": "insert_guard",
        "kind": 2,
        "importPath": "apply_signals_sig_autoguard_all",
        "description": "apply_signals_sig_autoguard_all",
        "peekOfCode": "def insert_guard(lines, body_start, body_indent):\n    guard = f\"{body_indent}sig = locals().get('signal', locals().get('trade_signal', None))  # auto-guard to avoid NameError\\n\"\n    lines.insert(body_start, guard)\n    return lines\ndef patch_text(txt: str) -> tuple[str, int]:\n    lines = txt.splitlines(True)  # сохраняем \\n\n    i = 0\n    changes = 0\n    pat_header = re.compile(r'^(\\s*)(?:async\\s+)?def\\s+\\w+\\s*\\([^)]*\\)\\s*:\\s*$')\n    while i < len(lines):",
        "detail": "apply_signals_sig_autoguard_all",
        "documentation": {}
    },
    {
        "label": "patch_text",
        "kind": 2,
        "importPath": "apply_signals_sig_autoguard_all",
        "description": "apply_signals_sig_autoguard_all",
        "peekOfCode": "def patch_text(txt: str) -> tuple[str, int]:\n    lines = txt.splitlines(True)  # сохраняем \\n\n    i = 0\n    changes = 0\n    pat_header = re.compile(r'^(\\s*)(?:async\\s+)?def\\s+\\w+\\s*\\([^)]*\\)\\s*:\\s*$')\n    while i < len(lines):\n        if not pat_header.match(lines[i]):\n            i += 1\n            continue\n        body_start, body_indent, func_end = find_func_block(lines, i)",
        "detail": "apply_signals_sig_autoguard_all",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_signals_sig_autoguard_all",
        "description": "apply_signals_sig_autoguard_all",
        "peekOfCode": "def main():\n    if not TARGET.exists():\n        print(f\"{WARN} {TARGET} not found. Abort.\")\n        return\n    src = TARGET.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    new, n = patch_text(src)\n    if n > 0:\n        backup(TARGET)\n        TARGET.write_text(new, encoding=\"utf-8\")\n        print(f\"{OK} Patched {TARGET.relative_to(BASE)} — inserted guards in {n} function(s)\")",
        "detail": "apply_signals_sig_autoguard_all",
        "documentation": {}
    },
    {
        "label": "WARN",
        "kind": 5,
        "importPath": "apply_signals_sig_autoguard_all",
        "description": "apply_signals_sig_autoguard_all",
        "peekOfCode": "WARN = \"\\u26A0\\uFE0F\"\nBASE   = Path(__file__).resolve().parent\nTARGET = BASE / \"strategy\" / \"signals.py\"\ndef backup(p: Path, suf=\".bak_sigguard_all\"):\n    if p.exists():\n        shutil.copy2(p, p.with_suffix(p.suffix + suf))\ndef leading_spaces(s: str) -> int:\n    return len(s) - len(s.lstrip(\" \"))\ndef is_def_or_class(line: str) -> bool:\n    return bool(re.match(r'^\\s*(?:async\\s+)?def\\s+\\w+\\s*\\(|^\\s*class\\s+\\w+\\s*\\(', line))",
        "detail": "apply_signals_sig_autoguard_all",
        "documentation": {}
    },
    {
        "label": "TARGET",
        "kind": 5,
        "importPath": "apply_signals_sig_autoguard_all",
        "description": "apply_signals_sig_autoguard_all",
        "peekOfCode": "TARGET = BASE / \"strategy\" / \"signals.py\"\ndef backup(p: Path, suf=\".bak_sigguard_all\"):\n    if p.exists():\n        shutil.copy2(p, p.with_suffix(p.suffix + suf))\ndef leading_spaces(s: str) -> int:\n    return len(s) - len(s.lstrip(\" \"))\ndef is_def_or_class(line: str) -> bool:\n    return bool(re.match(r'^\\s*(?:async\\s+)?def\\s+\\w+\\s*\\(|^\\s*class\\s+\\w+\\s*\\(', line))\ndef find_func_block(lines, start_idx):\n    \"\"\"",
        "detail": "apply_signals_sig_autoguard_all",
        "documentation": {}
    },
    {
        "label": "backup",
        "kind": 2,
        "importPath": "apply_unified_hotfix_v4",
        "description": "apply_unified_hotfix_v4",
        "peekOfCode": "def backup(p: Path, suf: str):\n    if p.exists():\n        bk = p.with_suffix(p.suffix + suf)\n        shutil.copy2(p, bk)\n        return bk.name\n    return \"\"\ndef write_file(path: Path, content: str, bak_suffix: str):\n    path.parent.mkdir(parents=True, exist_ok=True)\n    bk = backup(path, bak_suffix)\n    path.write_text(content.rstrip()+\"\\n\", encoding=\"utf-8\")",
        "detail": "apply_unified_hotfix_v4",
        "documentation": {}
    },
    {
        "label": "write_file",
        "kind": 2,
        "importPath": "apply_unified_hotfix_v4",
        "description": "apply_unified_hotfix_v4",
        "peekOfCode": "def write_file(path: Path, content: str, bak_suffix: str):\n    path.parent.mkdir(parents=True, exist_ok=True)\n    bk = backup(path, bak_suffix)\n    path.write_text(content.rstrip()+\"\\n\", encoding=\"utf-8\")\n    print(f\"{OK} {'Updated' if bk else 'Created'} {path.relative_to(BASE)}{f' (backup: {bk})' if bk else ''}\")\ndef patch_text(path: Path, mutate, bak_suffix: str):\n    if not path.exists():\n        print(f\"{WARN} {path.relative_to(BASE)} not found — skip\")\n        return False\n    src = path.read_text(encoding=\"utf-8\", errors=\"ignore\")",
        "detail": "apply_unified_hotfix_v4",
        "documentation": {}
    },
    {
        "label": "patch_text",
        "kind": 2,
        "importPath": "apply_unified_hotfix_v4",
        "description": "apply_unified_hotfix_v4",
        "peekOfCode": "def patch_text(path: Path, mutate, bak_suffix: str):\n    if not path.exists():\n        print(f\"{WARN} {path.relative_to(BASE)} not found — skip\")\n        return False\n    src = path.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    out, changed = mutate(src)\n    if changed:\n        bk = backup(path, bak_suffix)\n        path.write_text(out, encoding=\"utf-8\")\n        print(f\"{OK} Patched {path.relative_to(BASE)}{f' (backup: {bk})' if bk else ''}\")",
        "detail": "apply_unified_hotfix_v4",
        "documentation": {}
    },
    {
        "label": "apply",
        "kind": 2,
        "importPath": "apply_unified_hotfix_v4",
        "description": "apply_unified_hotfix_v4",
        "peekOfCode": "def apply(config):\n    # Базовые переменные окружения\n    et = _truthy(os.getenv(\"TESTNET\"))\n    ed = _truthy(os.getenv(\"DRY_RUN\"))\n    if et is not None:\n        try: config.testnet = bool(et)\n        except Exception: pass\n    if ed is not None:\n        try: config.dry_run = bool(ed)\n        except Exception: pass",
        "detail": "apply_unified_hotfix_v4",
        "documentation": {}
    },
    {
        "label": "mutate_utils",
        "kind": 2,
        "importPath": "apply_unified_hotfix_v4",
        "description": "apply_unified_hotfix_v4",
        "peekOfCode": "def mutate_utils(src: str):\n    changed = False\n    if \"def validate_symbol(\" not in src:\n        src += \"\\n\\ndef validate_symbol(sym: str) -> str:\\n\"\n        src += \"    try:\\n        return str(sym).strip().upper()\\n\"\n        src += \"    except Exception:\\n        return \\\"\\\"\\n\"\n        changed = True\n    if \"def normalize_symbol(\" not in src:\n        src += \"\\n\\ndef normalize_symbol(sym: str) -> str:\\n\"\n        src += \"    return validate_symbol(sym)\\n\"",
        "detail": "apply_unified_hotfix_v4",
        "documentation": {}
    },
    {
        "label": "mutate_compat_complete",
        "kind": 2,
        "importPath": "apply_unified_hotfix_v4",
        "description": "apply_unified_hotfix_v4",
        "peekOfCode": "def mutate_compat_complete(src: str):\n    changed = False\n    if \"IMBA_FORCE_TESTNET_ENFORCER\" in src:\n        return src, changed\n    append = r'''\n# --- IMBA_FORCE_TESTNET_ENFORCER (idempotent) ---\ntry:\n    import os as _imba_os\n    import exchange.client as _imba_exclient\n    _orig_init = getattr(_imba_exclient.BinanceClient, \"__init__\", None)",
        "detail": "apply_unified_hotfix_v4",
        "documentation": {}
    },
    {
        "label": "mutate_runner_live",
        "kind": 2,
        "importPath": "apply_unified_hotfix_v4",
        "description": "apply_unified_hotfix_v4",
        "peekOfCode": "def mutate_runner_live(src: str):\n    changed = False\n    if \"from core.env_overrides import apply as _imba_apply_env_overrides\" not in src:\n        # вставим после импортов\n        lines = src.splitlines(True)\n        ins = 0\n        for i,l in enumerate(lines[:300]):\n            if l.strip().startswith((\"import \",\"from \")):\n                ins = i+1\n            elif l.strip()==\"\" or l.strip().startswith((\"#\",\"'''\",'\\\"\\\"\\\"')):",
        "detail": "apply_unified_hotfix_v4",
        "documentation": {}
    },
    {
        "label": "mutate_cli_integrated",
        "kind": 2,
        "importPath": "apply_unified_hotfix_v4",
        "description": "apply_unified_hotfix_v4",
        "peekOfCode": "def mutate_cli_integrated(src: str):\n    changed = False\n    if \"from core.env_overrides import apply as _imba_apply_env_overrides\" not in src:\n        lines = src.splitlines(True)\n        ins = 0\n        for i,l in enumerate(lines[:300]):\n            if l.strip().startswith((\"import \",\"from \")):\n                ins = i+1\n            elif l.strip()==\"\" or l.strip().startswith((\"#\",\"'''\",'\\\"\\\"\\\"')):\n                continue",
        "detail": "apply_unified_hotfix_v4",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_unified_hotfix_v4",
        "description": "apply_unified_hotfix_v4",
        "peekOfCode": "def main():\n    # 1) env_overrides\n    write_file(BASE/\"core\"/\"env_overrides.py\", ENV_OVR, \".bak_envovr_v4\")\n    # 2) utils\n    patch_text(BASE/\"core\"/\"utils.py\", mutate_utils, \".bak_utils_v4\")\n    # 3) compat_complete.py\n    if (BASE/\"compat_complete.py\").exists():\n        patch_text(BASE/\"compat_complete.py\", mutate_compat_complete, \".bak_cc_v4\")\n    else:\n        print(f\"{WARN} compat_complete.py not found — skip testnet enforcer\")",
        "detail": "apply_unified_hotfix_v4",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "apply_unified_hotfix_v4",
        "description": "apply_unified_hotfix_v4",
        "peekOfCode": "BASE = Path(__file__).resolve().parent\nOK=\"✅\"; WARN=\"⚠️\"\ndef backup(p: Path, suf: str):\n    if p.exists():\n        bk = p.with_suffix(p.suffix + suf)\n        shutil.copy2(p, bk)\n        return bk.name\n    return \"\"\ndef write_file(path: Path, content: str, bak_suffix: str):\n    path.parent.mkdir(parents=True, exist_ok=True)",
        "detail": "apply_unified_hotfix_v4",
        "documentation": {}
    },
    {
        "label": "ENV_OVR",
        "kind": 5,
        "importPath": "apply_unified_hotfix_v4",
        "description": "apply_unified_hotfix_v4",
        "peekOfCode": "ENV_OVR = r'''\nfrom __future__ import annotations\nimport os\ndef _truthy(v):\n    if v is None: return None\n    return str(v).strip().lower() in {\"1\",\"true\",\"t\",\"yes\",\"y\",\"on\"}\ndef _read_env_file(path: str) -> dict:\n    out = {}\n    try:\n        with open(path, \"r\", encoding=\"utf-8\", errors=\"ignore\") as f:",
        "detail": "apply_unified_hotfix_v4",
        "documentation": {}
    },
    {
        "label": "backup",
        "kind": 2,
        "importPath": "apply_unified_imba_patch",
        "description": "apply_unified_imba_patch",
        "peekOfCode": "def backup(p: Path, suf: str):\n    if p.exists():\n        p_bak = p.with_suffix(p.suffix + suf)\n        shutil.copy2(p, p_bak)\n        return p_bak.name\n    return None\ndef write_file(p: Path, content: str, bak_suffix: str):\n    p.parent.mkdir(parents=True, exist_ok=True)\n    bak = backup(p, bak_suffix)\n    p.write_text(content.rstrip() + \"\\n\", encoding=\"utf-8\")",
        "detail": "apply_unified_imba_patch",
        "documentation": {}
    },
    {
        "label": "write_file",
        "kind": 2,
        "importPath": "apply_unified_imba_patch",
        "description": "apply_unified_imba_patch",
        "peekOfCode": "def write_file(p: Path, content: str, bak_suffix: str):\n    p.parent.mkdir(parents=True, exist_ok=True)\n    bak = backup(p, bak_suffix)\n    p.write_text(content.rstrip() + \"\\n\", encoding=\"utf-8\")\n    if bak:\n        print(f\"{OK} Updated {p.relative_to(BASE)} (backup: {bak})\")\n    else:\n        print(f\"{OK} Created {p.relative_to(BASE)}\")\n# ---------------- sitecustomize.py (глобальные гварды + автозагрузка .env) ----------------\nSITECONTENT = r\"\"\"# IMBA sitecustomize (unified guard + config loader)",
        "detail": "apply_unified_imba_patch",
        "documentation": {}
    },
    {
        "label": "patch_compat",
        "kind": 2,
        "importPath": "apply_unified_imba_patch",
        "description": "apply_unified_imba_patch",
        "peekOfCode": "def patch_compat():\n    candidates = [BASE/\"compat_complete.py\", BASE/\"compat.py\"]\n    any_found=False\n    for p in candidates:\n        if not p.exists():\n            continue\n        any_found=True\n        src = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n        changed = False\n        out = src.rstrip() + \"\\n\\n\"",
        "detail": "apply_unified_imba_patch",
        "documentation": {}
    },
    {
        "label": "patch_cli",
        "kind": 2,
        "importPath": "apply_unified_imba_patch",
        "description": "apply_unified_imba_patch",
        "peekOfCode": "def patch_cli():\n    p = BASE/\"cli_integrated.py\"\n    if not p.exists():\n        print(f\"{WARN} cli_integrated.py not found — skipped\"); return\n    src = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    if \"IMBA CLI shim: allow '--config PATH'\" in src:\n        print(f\"{OK} cli_integrated.py already has CLI shim\"); return\n    lines = src.splitlines(True)\n    ins = 0\n    # shebang/encoding/__future__",
        "detail": "apply_unified_imba_patch",
        "documentation": {}
    },
    {
        "label": "patch_runner",
        "kind": 2,
        "importPath": "apply_unified_imba_patch",
        "description": "apply_unified_imba_patch",
        "peekOfCode": "def patch_runner(rel: str):\n    p = BASE / rel\n    if not p.exists():\n        print(f\"{WARN} {rel} not found — skipped\"); return\n    txt = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    changed=False\n    if \"_safe_pos_summary(\" not in txt:\n        # вставим helper сразу после импортов\n        lines = txt.splitlines(True)\n        ins = 0",
        "detail": "apply_unified_imba_patch",
        "documentation": {}
    },
    {
        "label": "patch_runners",
        "kind": 2,
        "importPath": "apply_unified_imba_patch",
        "description": "apply_unified_imba_patch",
        "peekOfCode": "def patch_runners():\n    for rel in (\"runner/paper.py\", \"runner/live.py\"):\n        patch_runner(rel)\n# ---------------- core/utils.py (мягкая заглушка validate_symbol/normalize_symbol) ----------------\nUTILS_STUB = r'''\n# --- compat stub: validate_symbol / normalize_symbol (idempotent) ---\ndef validate_symbol(sym: str) -> str:\n    try:\n        s = str(sym).strip().upper()\n    except Exception:",
        "detail": "apply_unified_imba_patch",
        "documentation": {}
    },
    {
        "label": "validate_symbol",
        "kind": 2,
        "importPath": "apply_unified_imba_patch",
        "description": "apply_unified_imba_patch",
        "peekOfCode": "def validate_symbol(sym: str) -> str:\n    try:\n        s = str(sym).strip().upper()\n    except Exception:\n        return \"\"\n    return s\ndef normalize_symbol(sym: str) -> str:\n    return validate_symbol(sym)\n'''\ndef patch_core_utils():",
        "detail": "apply_unified_imba_patch",
        "documentation": {}
    },
    {
        "label": "normalize_symbol",
        "kind": 2,
        "importPath": "apply_unified_imba_patch",
        "description": "apply_unified_imba_patch",
        "peekOfCode": "def normalize_symbol(sym: str) -> str:\n    return validate_symbol(sym)\n'''\ndef patch_core_utils():\n    p = BASE/\"core\"/\"utils.py\"\n    if not p.exists():\n        print(f\"{WARN} core/utils.py not found — skipped\"); return\n    txt = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    if \"def validate_symbol\" in txt:\n        print(f\"{OK} core/utils.py already has validate_symbol()\"); return",
        "detail": "apply_unified_imba_patch",
        "documentation": {}
    },
    {
        "label": "patch_core_utils",
        "kind": 2,
        "importPath": "apply_unified_imba_patch",
        "description": "apply_unified_imba_patch",
        "peekOfCode": "def patch_core_utils():\n    p = BASE/\"core\"/\"utils.py\"\n    if not p.exists():\n        print(f\"{WARN} core/utils.py not found — skipped\"); return\n    txt = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    if \"def validate_symbol\" in txt:\n        print(f\"{OK} core/utils.py already has validate_symbol()\"); return\n    lines = txt.splitlines(True)\n    ins = 0\n    for i,l in enumerate(lines[:150]):",
        "detail": "apply_unified_imba_patch",
        "documentation": {}
    },
    {
        "label": "ensure_sl_on_exchange",
        "kind": 2,
        "importPath": "apply_unified_imba_patch",
        "description": "apply_unified_imba_patch",
        "peekOfCode": "def ensure_sl_on_exchange(client: BinanceClient, symbol: str, position_side: str, stop_price: float,\n                          working_type: str = \"MARK_PRICE\", eps_ticks: int = 3) -> Dict[str, Any]:\n    cfg = get_config()\n    if not getattr(cfg, \"place_exits_on_exchange\", True):\n        return {\"status\":\"SKIP\", \"reason\":\"exits disabled\"}\n    if getattr(cfg, \"dry_run\", False):\n        return {\"status\":\"OK\", \"dry_run\": True}\n    cooldown = float(getattr(cfg, \"exit_replace_cooldown\", 20.0))\n    if not _ensure_gate(symbol, \"sl\", cooldown):\n        return {\"status\":\"SKIP\", \"reason\":\"cooldown\"}",
        "detail": "apply_unified_imba_patch",
        "documentation": {}
    },
    {
        "label": "ensure_tp_on_exchange",
        "kind": 2,
        "importPath": "apply_unified_imba_patch",
        "description": "apply_unified_imba_patch",
        "peekOfCode": "def ensure_tp_on_exchange(client: BinanceClient, symbol: str, position_side: str, qty: float, entry_price: float,\n                          tp_levels_pct: Optional[List[float]] = None, tp_shares: Optional[List[float]] = None,\n                          tif: str = \"GTC\", tp_prefix: str = \"TP-\") -> Dict[str, Any]:\n    cfg = get_config()\n    if not getattr(cfg, \"place_exits_on_exchange\", True):\n        return {\"status\":\"SKIP\", \"reason\":\"exits disabled\"}\n    if getattr(cfg, \"dry_run\", False):\n        return {\"status\":\"OK\", \"dry_run\": True, \"placed\": 0}\n    cooldown = float(getattr(cfg, \"exit_replace_cooldown\", 20.0))\n    if not _ensure_gate(symbol, \"tp\", cooldown):",
        "detail": "apply_unified_imba_patch",
        "documentation": {}
    },
    {
        "label": "ensure_exits_on_exchange",
        "kind": 2,
        "importPath": "apply_unified_imba_patch",
        "description": "apply_unified_imba_patch",
        "peekOfCode": "def ensure_exits_on_exchange(client: BinanceClient, symbol: str, position_side: str, qty: float, entry_price: float,\n                             stop_price: float, working_type: str = \"MARK_PRICE\",\n                             tp_levels_pct: Optional[List[float]] = None, tp_shares: Optional[List[float]] = None) -> Dict[str, Any]:\n    r1 = ensure_sl_on_exchange(client, symbol, position_side, stop_price, working_type=working_type)\n    r2 = ensure_tp_on_exchange(client, symbol, position_side, qty, entry_price, tp_levels_pct, tp_shares)\n    return {\"sl\": r1, \"tp\": r2}\n'''\ndef ensure_exits_addon():\n    p = BASE/\"exchange\"/\"exits_addon.py\"\n    if p.exists():",
        "detail": "apply_unified_imba_patch",
        "documentation": {}
    },
    {
        "label": "ensure_exits_addon",
        "kind": 2,
        "importPath": "apply_unified_imba_patch",
        "description": "apply_unified_imba_patch",
        "peekOfCode": "def ensure_exits_addon():\n    p = BASE/\"exchange\"/\"exits_addon.py\"\n    if p.exists():\n        # не перезаписываем без нужды: обновим, если нет ключевых сигнатур\n        txt = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n        if \"ensure_sl_on_exchange\" in txt and \"ensure_tp_on_exchange\" in txt:\n            print(f\"{OK} exchange/exits_addon.py already present\")\n            return\n    write_file(p, EXITS_ADDON, \".bak_exits\")\ndef main():",
        "detail": "apply_unified_imba_patch",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_unified_imba_patch",
        "description": "apply_unified_imba_patch",
        "peekOfCode": "def main():\n    # 1) sitecustomize (гварды + .env loader)\n    write_file(BASE/\"sitecustomize.py\", SITECONTENT, \".bak_site\")\n    # 2) compat (builtins guard + validate_symbol stub + balance time-sync + signals normalizer)\n    patch_compat()\n    # 3) CLI shim (--config после subcommand)\n    patch_cli()\n    # 4) runners (safe status log + tracebacks)\n    patch_runners()\n    # 5) core/utils validate_symbol stub (на случай прямых импортов)",
        "detail": "apply_unified_imba_patch",
        "documentation": {}
    },
    {
        "label": "WARN",
        "kind": 5,
        "importPath": "apply_unified_imba_patch",
        "description": "apply_unified_imba_patch",
        "peekOfCode": "WARN = \"⚠️\"\nBASE = Path(__file__).resolve().parent\ndef backup(p: Path, suf: str):\n    if p.exists():\n        p_bak = p.with_suffix(p.suffix + suf)\n        shutil.copy2(p, p_bak)\n        return p_bak.name\n    return None\ndef write_file(p: Path, content: str, bak_suffix: str):\n    p.parent.mkdir(parents=True, exist_ok=True)",
        "detail": "apply_unified_imba_patch",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "apply_unified_imba_patch",
        "description": "apply_unified_imba_patch",
        "peekOfCode": "BASE = Path(__file__).resolve().parent\ndef backup(p: Path, suf: str):\n    if p.exists():\n        p_bak = p.with_suffix(p.suffix + suf)\n        shutil.copy2(p, p_bak)\n        return p_bak.name\n    return None\ndef write_file(p: Path, content: str, bak_suffix: str):\n    p.parent.mkdir(parents=True, exist_ok=True)\n    bak = backup(p, bak_suffix)",
        "detail": "apply_unified_imba_patch",
        "documentation": {}
    },
    {
        "label": "SITECONTENT",
        "kind": 5,
        "importPath": "apply_unified_imba_patch",
        "description": "apply_unified_imba_patch",
        "peekOfCode": "SITECONTENT = r\"\"\"# IMBA sitecustomize (unified guard + config loader)\nimport os, sys, builtins\ntry:\n    print(\"✅ sitecustomize: global 'sig' guard & .env loader active\")\nexcept Exception:\n    pass\n# --- Global guards for legacy variables (idempotent) ---\nfor _name in (\"sig\", \"signal\", \"trade_signal\"):\n    if not hasattr(builtins, _name):\n        setattr(builtins, _name, None)",
        "detail": "apply_unified_imba_patch",
        "documentation": {}
    },
    {
        "label": "sys.argv",
        "kind": 5,
        "importPath": "apply_unified_imba_patch",
        "description": "apply_unified_imba_patch",
        "peekOfCode": "sys.argv = _argv\n\"\"\"\n# ---------------- compat_complete.py / compat.py (validate_symbol stub, builtins guard, balance time-sync, signal normalizer) ----------------\nCOMPAT_BLOCKS = {\n\"BUILTINS_GUARD\": r'''\n# --- COMPAT: GLOBAL SIG GUARD (builtins, idempotent) ---\nimport builtins as _blt\nfor _nm in (\"sig\", \"signal\", \"trade_signal\"):\n    if not hasattr(_blt, _nm):\n        setattr(_blt, _nm, None)",
        "detail": "apply_unified_imba_patch",
        "documentation": {}
    },
    {
        "label": "COMPAT_BLOCKS",
        "kind": 5,
        "importPath": "apply_unified_imba_patch",
        "description": "apply_unified_imba_patch",
        "peekOfCode": "COMPAT_BLOCKS = {\n\"BUILTINS_GUARD\": r'''\n# --- COMPAT: GLOBAL SIG GUARD (builtins, idempotent) ---\nimport builtins as _blt\nfor _nm in (\"sig\", \"signal\", \"trade_signal\"):\n    if not hasattr(_blt, _nm):\n        setattr(_blt, _nm, None)\n''',\n\"VALIDATE_SYMBOL_STUB\": r'''\n# --- COMPAT: safe stub for core.utils.validate_symbol (idempotent) ---",
        "detail": "apply_unified_imba_patch",
        "documentation": {}
    },
    {
        "label": "CLI_SHIM",
        "kind": 5,
        "importPath": "apply_unified_imba_patch",
        "description": "apply_unified_imba_patch",
        "peekOfCode": "CLI_SHIM = r'''\n# --- IMBA CLI shim: allow '--config PATH' after subcommand (idempotent) ---\ntry:\n    import sys as _sys, os as _os\n    if \"--config\" in _sys.argv:\n        j = _sys.argv.index(\"--config\")\n        if j+1 < len(_sys.argv):\n            _os.environ[\"IMBA_CONFIG_PATH\"] = _sys.argv[j+1]\n            # удалить пару, чтобы Click/Typer не ругался\n            try:",
        "detail": "apply_unified_imba_patch",
        "documentation": {}
    },
    {
        "label": "RUNNER_HELPER",
        "kind": 5,
        "importPath": "apply_unified_imba_patch",
        "description": "apply_unified_imba_patch",
        "peekOfCode": "RUNNER_HELPER = r'''\ndef _safe_pos_summary(pm):\n    try:\n        return pm.get_position_summary()\n    except Exception:\n        return {}\n'''\ndef patch_runner(rel: str):\n    p = BASE / rel\n    if not p.exists():",
        "detail": "apply_unified_imba_patch",
        "documentation": {}
    },
    {
        "label": "UTILS_STUB",
        "kind": 5,
        "importPath": "apply_unified_imba_patch",
        "description": "apply_unified_imba_patch",
        "peekOfCode": "UTILS_STUB = r'''\n# --- compat stub: validate_symbol / normalize_symbol (idempotent) ---\ndef validate_symbol(sym: str) -> str:\n    try:\n        s = str(sym).strip().upper()\n    except Exception:\n        return \"\"\n    return s\ndef normalize_symbol(sym: str) -> str:\n    return validate_symbol(sym)",
        "detail": "apply_unified_imba_patch",
        "documentation": {}
    },
    {
        "label": "EXITS_ADDON",
        "kind": 5,
        "importPath": "apply_unified_imba_patch",
        "description": "apply_unified_imba_patch",
        "peekOfCode": "EXITS_ADDON = r'''# exchange/exits_addon.py\nfrom __future__ import annotations\nimport logging, time\nfrom decimal import Decimal, ROUND_DOWN\nfrom typing import Any, Dict, List, Tuple, Optional\nfrom core.config import get_config\nfrom exchange.client import BinanceClient\nlog = logging.getLogger(__name__)\n_FILTERS: Dict[str, Dict[str, float]] = {}\n_LAST_ENSURE: Dict[str, Dict[str, float]] = {}",
        "detail": "apply_unified_imba_patch",
        "documentation": {}
    },
    {
        "label": "log",
        "kind": 5,
        "importPath": "apply_unified_imba_patch",
        "description": "apply_unified_imba_patch",
        "peekOfCode": "log = logging.getLogger(__name__)\n_FILTERS: Dict[str, Dict[str, float]] = {}\n_LAST_ENSURE: Dict[str, Dict[str, float]] = {}\ndef _flt(x, d=0.0) -> float:\n    try: return float(x)\n    except Exception: return d\ndef _floor_to_step(x: float, step: float) -> float:\n    if step <= 0: return float(x)\n    q = Decimal(str(step))\n    return float(Decimal(str(x)).quantize(q, rounding=ROUND_DOWN))",
        "detail": "apply_unified_imba_patch",
        "documentation": {}
    },
    {
        "label": "backup",
        "kind": 2,
        "importPath": "apply_unified_live_fix_v2",
        "description": "apply_unified_live_fix_v2",
        "peekOfCode": "def backup(p: Path, suf: str):\n    if p.exists():\n        bk = p.with_suffix(p.suffix + suf)\n        shutil.copy2(p, bk)\n        return bk.name\n    return None\ndef write_file(p: Path, content: str, bak_suffix: str):\n    p.parent.mkdir(parents=True, exist_ok=True)\n    bk = backup(p, bak_suffix)\n    p.write_text(content.rstrip()+\"\\n\", encoding=\"utf-8\")",
        "detail": "apply_unified_live_fix_v2",
        "documentation": {}
    },
    {
        "label": "write_file",
        "kind": 2,
        "importPath": "apply_unified_live_fix_v2",
        "description": "apply_unified_live_fix_v2",
        "peekOfCode": "def write_file(p: Path, content: str, bak_suffix: str):\n    p.parent.mkdir(parents=True, exist_ok=True)\n    bk = backup(p, bak_suffix)\n    p.write_text(content.rstrip()+\"\\n\", encoding=\"utf-8\")\n    if bk: print(f\"{OK} Updated {p.relative_to(BASE)} (backup: {bk})\")\n    else:  print(f\"{OK} Created {p.relative_to(BASE)}\")\n# 1) sitecustomize.py — ранняя подгрузка .env + validate_symbol stub\nSITE_PATH = BASE/\"sitecustomize.py\"\nSITE_PAYLOAD = r'''\n# sitecustomize — IMBA unified live fixes",
        "detail": "apply_unified_live_fix_v2",
        "documentation": {}
    },
    {
        "label": "patch_compat",
        "kind": 2,
        "importPath": "apply_unified_live_fix_v2",
        "description": "apply_unified_live_fix_v2",
        "peekOfCode": "def patch_compat():\n    for p in COMPAT_PATHS:\n        if not p.exists():\n            continue\n        txt = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n        changed = False\n        # вырежем все блоки вида: def _patched_init(...) ... BinanceClient.__init__ = _patched_init\n        pat = re.compile(r\"def\\s+_patched_init\\s*\\(.*?\\):.*?BinanceClient\\s*\\.\\s*__init__\\s*=\\s*_patched_init\", re.S)\n        if pat.search(txt):\n            txt = pat.sub(\"# -- removed recursive _patched_init --\", txt)",
        "detail": "apply_unified_live_fix_v2",
        "documentation": {}
    },
    {
        "label": "patch_cli_one",
        "kind": 2,
        "importPath": "apply_unified_live_fix_v2",
        "description": "apply_unified_live_fix_v2",
        "peekOfCode": "def patch_cli_one(path: Path):\n    if not path.exists():\n        print(f\"{WARN} {path.name} not found — skip\"); return\n    src = path.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    out = src\n    changed = False\n    # вставим helper после импортов\n    if \"_imba_apply_env_overrides(\" not in out:\n        lines = out.splitlines(True)\n        ins = 0",
        "detail": "apply_unified_live_fix_v2",
        "documentation": {}
    },
    {
        "label": "patch_cli",
        "kind": 2,
        "importPath": "apply_unified_live_fix_v2",
        "description": "apply_unified_live_fix_v2",
        "peekOfCode": "def patch_cli():\n    for name in (\"cli_integrated.py\", \"cli_updated.py\"):\n        patch_cli_one(BASE/name)\ndef main():\n    # 1) sitecustomize (ранний stub + .env loader)\n    write_file(SITE_PATH, SITE_PAYLOAD, \".bak_sitev2\")\n    # 2) compat (безопасный __init__)\n    patch_compat()\n    # 3) CLI (уважаем TESTNET/DRY_RUN из .env)\n    patch_cli()",
        "detail": "apply_unified_live_fix_v2",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_unified_live_fix_v2",
        "description": "apply_unified_live_fix_v2",
        "peekOfCode": "def main():\n    # 1) sitecustomize (ранний stub + .env loader)\n    write_file(SITE_PATH, SITE_PAYLOAD, \".bak_sitev2\")\n    # 2) compat (безопасный __init__)\n    patch_compat()\n    # 3) CLI (уважаем TESTNET/DRY_RUN из .env)\n    patch_cli()\n    print(\"\\nDone.\")\nif __name__ == \"__main__\":\n    main()",
        "detail": "apply_unified_live_fix_v2",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "apply_unified_live_fix_v2",
        "description": "apply_unified_live_fix_v2",
        "peekOfCode": "BASE = Path(__file__).resolve().parent\ndef backup(p: Path, suf: str):\n    if p.exists():\n        bk = p.with_suffix(p.suffix + suf)\n        shutil.copy2(p, bk)\n        return bk.name\n    return None\ndef write_file(p: Path, content: str, bak_suffix: str):\n    p.parent.mkdir(parents=True, exist_ok=True)\n    bk = backup(p, bak_suffix)",
        "detail": "apply_unified_live_fix_v2",
        "documentation": {}
    },
    {
        "label": "SITE_PATH",
        "kind": 5,
        "importPath": "apply_unified_live_fix_v2",
        "description": "apply_unified_live_fix_v2",
        "peekOfCode": "SITE_PATH = BASE/\"sitecustomize.py\"\nSITE_PAYLOAD = r'''\n# sitecustomize — IMBA unified live fixes\nimport os, sys, builtins\n# 1) Глобальные гварды (на всякий случай)\nfor _nm in (\"sig\",\"signal\",\"trade_signal\"):\n    if not hasattr(builtins, _nm):\n        setattr(builtins, _nm, None)\n# 2) Перехват --config и ранняя загрузка .env\ndef _imba_grab_config(argv):",
        "detail": "apply_unified_live_fix_v2",
        "documentation": {}
    },
    {
        "label": "SITE_PAYLOAD",
        "kind": 5,
        "importPath": "apply_unified_live_fix_v2",
        "description": "apply_unified_live_fix_v2",
        "peekOfCode": "SITE_PAYLOAD = r'''\n# sitecustomize — IMBA unified live fixes\nimport os, sys, builtins\n# 1) Глобальные гварды (на всякий случай)\nfor _nm in (\"sig\",\"signal\",\"trade_signal\"):\n    if not hasattr(builtins, _nm):\n        setattr(builtins, _nm, None)\n# 2) Перехват --config и ранняя загрузка .env\ndef _imba_grab_config(argv):\n    p = os.environ.get(\"IMBA_CONFIG_PATH\", \"\")",
        "detail": "apply_unified_live_fix_v2",
        "documentation": {}
    },
    {
        "label": "sys.argv",
        "kind": 5,
        "importPath": "apply_unified_live_fix_v2",
        "description": "apply_unified_live_fix_v2",
        "peekOfCode": "sys.argv = _argv\n# 3) validate_symbol stub (до compat)\ntry:\n    import importlib, types\n    cu = importlib.import_module(\"core.utils\")\n    if not hasattr(cu, \"validate_symbol\"):\n        def validate_symbol(sym: str) -> str:\n            try: s = str(sym).strip().upper()\n            except Exception: s = \"\"\n            return s",
        "detail": "apply_unified_live_fix_v2",
        "documentation": {}
    },
    {
        "label": "COMPAT_PATHS",
        "kind": 5,
        "importPath": "apply_unified_live_fix_v2",
        "description": "apply_unified_live_fix_v2",
        "peekOfCode": "COMPAT_PATHS = [BASE/\"compat_complete.py\", BASE/\"compat.py\"]\nSAFE_INIT_BLOCK = r'''\n# --- IMBA SAFE INIT PATCH (idempotent, anti-recursion) ---\ntry:\n    import logging, importlib\n    _lg = logging.getLogger(\"compat\")\n    _mod = importlib.import_module(\"exchange.client\")\n    _B = getattr(_mod, \"BinanceClient\", None)\n    if _B is not None:\n        # Удаляем прежние рекурсивные обёртки: заменяем __init__ на безопасную,",
        "detail": "apply_unified_live_fix_v2",
        "documentation": {}
    },
    {
        "label": "SAFE_INIT_BLOCK",
        "kind": 5,
        "importPath": "apply_unified_live_fix_v2",
        "description": "apply_unified_live_fix_v2",
        "peekOfCode": "SAFE_INIT_BLOCK = r'''\n# --- IMBA SAFE INIT PATCH (idempotent, anti-recursion) ---\ntry:\n    import logging, importlib\n    _lg = logging.getLogger(\"compat\")\n    _mod = importlib.import_module(\"exchange.client\")\n    _B = getattr(_mod, \"BinanceClient\", None)\n    if _B is not None:\n        # Удаляем прежние рекурсивные обёртки: заменяем __init__ на безопасную,\n        # где \"оригинал\" определяется как __imba_orig_init__ или текущий __init__ без повторной ребайндной цепочки.",
        "detail": "apply_unified_live_fix_v2",
        "documentation": {}
    },
    {
        "label": "CLI_HELPER",
        "kind": 5,
        "importPath": "apply_unified_live_fix_v2",
        "description": "apply_unified_live_fix_v2",
        "peekOfCode": "CLI_HELPER = r'''\n# --- IMBA: apply env overrides for TESTNET/DRY_RUN (idempotent) ---\ndef _imba_env_bool(name: str):\n    v = os.getenv(name, None)\n    if v is None: return None\n    return str(v).strip().lower() in {\"1\",\"true\",\"t\",\"yes\",\"y\",\"on\"}\ndef _imba_apply_env_overrides(cfg):\n    try:\n        et = _imba_env_bool(\"TESTNET\")\n        ed = _imba_env_bool(\"DRY_RUN\")",
        "detail": "apply_unified_live_fix_v2",
        "documentation": {}
    },
    {
        "label": "p",
        "kind": 2,
        "importPath": "apply_unified_master_patch",
        "description": "apply_unified_master_patch",
        "peekOfCode": "def p(*xs): print(*xs)\ndef write_file(path: Path, text: str, backup_tag: str|None=None):\n    path.parent.mkdir(parents=True, exist_ok=True)\n    if path.exists() and backup_tag:\n        bak = path.with_suffix(path.suffix + f\".bak_{backup_tag}\")\n        if not bak.exists():\n            bak.write_text(path.read_text(encoding=\"utf-8\"), encoding=\"utf-8\")\n    path.write_text(text, encoding=\"utf-8\")\ndef patch_text(path: Path, replacers: list[tuple[re.Pattern,str]], backup_tag: str):\n    if not path.exists():",
        "detail": "apply_unified_master_patch",
        "documentation": {}
    },
    {
        "label": "write_file",
        "kind": 2,
        "importPath": "apply_unified_master_patch",
        "description": "apply_unified_master_patch",
        "peekOfCode": "def write_file(path: Path, text: str, backup_tag: str|None=None):\n    path.parent.mkdir(parents=True, exist_ok=True)\n    if path.exists() and backup_tag:\n        bak = path.with_suffix(path.suffix + f\".bak_{backup_tag}\")\n        if not bak.exists():\n            bak.write_text(path.read_text(encoding=\"utf-8\"), encoding=\"utf-8\")\n    path.write_text(text, encoding=\"utf-8\")\ndef patch_text(path: Path, replacers: list[tuple[re.Pattern,str]], backup_tag: str):\n    if not path.exists():\n        p(f\"  ! Skip: {path} not found\")",
        "detail": "apply_unified_master_patch",
        "documentation": {}
    },
    {
        "label": "patch_text",
        "kind": 2,
        "importPath": "apply_unified_master_patch",
        "description": "apply_unified_master_patch",
        "peekOfCode": "def patch_text(path: Path, replacers: list[tuple[re.Pattern,str]], backup_tag: str):\n    if not path.exists():\n        p(f\"  ! Skip: {path} not found\")\n        return False\n    src = path.read_text(encoding=\"utf-8\")\n    out = src\n    changed = False\n    for pat, repl in replacers:\n        new = pat.sub(repl, out)\n        if new != out:",
        "detail": "apply_unified_master_patch",
        "documentation": {}
    },
    {
        "label": "ensure_env_overrides",
        "kind": 2,
        "importPath": "apply_unified_master_patch",
        "description": "apply_unified_master_patch",
        "peekOfCode": "def ensure_env_overrides():\n    path = ROOT / \"core\" / \"env_overrides.py\"\n    code = dedent(r\"\"\"\n    # core/env_overrides.py\n    # Мягкие .env-оверрайды и заполнение недостающих полей в конфиге.\n    from __future__ import annotations\n    import os\n    from typing import Any\n    def _get_bool(name: str, default: bool) -> bool:\n        v = os.getenv(name, None)",
        "detail": "apply_unified_master_patch",
        "documentation": {}
    },
    {
        "label": "ensure_utils_validate_symbol",
        "kind": 2,
        "importPath": "apply_unified_master_patch",
        "description": "apply_unified_master_patch",
        "peekOfCode": "def ensure_utils_validate_symbol():\n    path = ROOT / \"core\" / \"utils.py\"\n    if not path.exists():\n        p(\"  ! core/utils.py not found — skipping validate_symbol\")\n        return\n    src = path.read_text(encoding=\"utf-8\")\n    if \"def validate_symbol(\" in src:\n        p(\"  = validate_symbol() already exists\")\n        return\n    add = dedent(r\"\"\"",
        "detail": "apply_unified_master_patch",
        "documentation": {}
    },
    {
        "label": "patch_runner_live",
        "kind": 2,
        "importPath": "apply_unified_master_patch",
        "description": "apply_unified_master_patch",
        "peekOfCode": "def patch_runner_live():\n    path = ROOT / \"runner\" / \"live.py\"\n    if not path.exists():\n        p(\"  ! runner/live.py not found — skipping\")\n        return\n    reps = [\n        # 1) странный вызов self.getattr( ... ) → обычный getattr(\n        (re.compile(r\"\\bself\\.getattr\\s*\\(\"), \"getattr(\"),\n        # 2) getattr(config, 'min_account_balance' ...) → getattr(self.config, 'min_account_balance', 0.0)\n        (re.compile(r\"getattr\\(\\s*config\\s*,\\s*([\\\"'])min_account_balance\\1\\s*\\)\"),",
        "detail": "apply_unified_master_patch",
        "documentation": {}
    },
    {
        "label": "write_cli_integrated",
        "kind": 2,
        "importPath": "apply_unified_master_patch",
        "description": "apply_unified_master_patch",
        "peekOfCode": "def write_cli_integrated():\n    path = ROOT / \"cli_integrated.py\"\n    code = dedent(r\"\"\"\n    # cli_integrated.py — надёжный CLI с .env и оверрайдами, без IndentationError\n    from __future__ import annotations\n    import os, sys, asyncio\n    from typing import Optional\n    import typer\n    app = typer.Typer(name=\"trading-bot\")\n    # .env загрузка (мягкая)",
        "detail": "apply_unified_master_patch",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_unified_master_patch",
        "description": "apply_unified_master_patch",
        "peekOfCode": "def main():\n    p(\"Applying unified master patch …\")\n    ensure_env_overrides()\n    ensure_utils_validate_symbol()\n    patch_runner_live()\n    write_cli_integrated()\n    p(\"Done.\")\nif __name__ == \"__main__\":\n    main()",
        "detail": "apply_unified_master_patch",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "kind": 5,
        "importPath": "apply_unified_master_patch",
        "description": "apply_unified_master_patch",
        "peekOfCode": "ROOT = Path(__file__).resolve().parent\ndef p(*xs): print(*xs)\ndef write_file(path: Path, text: str, backup_tag: str|None=None):\n    path.parent.mkdir(parents=True, exist_ok=True)\n    if path.exists() and backup_tag:\n        bak = path.with_suffix(path.suffix + f\".bak_{backup_tag}\")\n        if not bak.exists():\n            bak.write_text(path.read_text(encoding=\"utf-8\"), encoding=\"utf-8\")\n    path.write_text(text, encoding=\"utf-8\")\ndef patch_text(path: Path, replacers: list[tuple[re.Pattern,str]], backup_tag: str):",
        "detail": "apply_unified_master_patch",
        "documentation": {}
    },
    {
        "label": "backup",
        "kind": 2,
        "importPath": "apply_unified_master_patch_v5",
        "description": "apply_unified_master_patch_v5",
        "peekOfCode": "def backup(path: Path):\n    if not path.exists():\n        return\n    bak = path.with_suffix(path.suffix + \".bak_unified_v5\")\n    if not bak.exists():\n        bak.write_bytes(path.read_bytes())\ndef write_text(path: Path, text: str):\n    path.parent.mkdir(parents=True, exist_ok=True)\n    path.write_text(text, encoding=\"utf-8\")\ndef patch_env_overrides():",
        "detail": "apply_unified_master_patch_v5",
        "documentation": {}
    },
    {
        "label": "write_text",
        "kind": 2,
        "importPath": "apply_unified_master_patch_v5",
        "description": "apply_unified_master_patch_v5",
        "peekOfCode": "def write_text(path: Path, text: str):\n    path.parent.mkdir(parents=True, exist_ok=True)\n    path.write_text(text, encoding=\"utf-8\")\ndef patch_env_overrides():\n    \"\"\"Создаёт/обновляет core/env_overrides.py — единое место для гибких оверрайдов из .env.\"\"\"\n    path = P_CORE / \"env_overrides.py\"\n    backup(path)\n    code = dedent(r'''\n        # -*- coding: utf-8 -*-\n        \"\"\"",
        "detail": "apply_unified_master_patch_v5",
        "documentation": {}
    },
    {
        "label": "patch_env_overrides",
        "kind": 2,
        "importPath": "apply_unified_master_patch_v5",
        "description": "apply_unified_master_patch_v5",
        "peekOfCode": "def patch_env_overrides():\n    \"\"\"Создаёт/обновляет core/env_overrides.py — единое место для гибких оверрайдов из .env.\"\"\"\n    path = P_CORE / \"env_overrides.py\"\n    backup(path)\n    code = dedent(r'''\n        # -*- coding: utf-8 -*-\n        \"\"\"\n        Env overrides (универсальные):\n        - .env подхватывается из BOT_CONFIG_PATH, CONFIG_PATH или аргумента функции\n        - переносит TESTNET/DRY_RUN/MIN_ACCOUNT_BALANCE/IMBA_RECV_WINDOW_MS/ALLOW_TIME_DRIFT_MS в объект config",
        "detail": "apply_unified_master_patch_v5",
        "documentation": {}
    },
    {
        "label": "patch_core_utils",
        "kind": 2,
        "importPath": "apply_unified_master_patch_v5",
        "description": "apply_unified_master_patch_v5",
        "peekOfCode": "def patch_core_utils():\n    \"\"\"Добавляет validate_symbol, если его нет, чтобы не падали сторонние патчи.\"\"\"\n    path = P_CORE / \"utils.py\"\n    if not path.exists():\n        return None, \"core/utils.py not found (skip, не критично)\"\n    backup(path)\n    txt = path.read_text(encoding=\"utf-8\")\n    if \"def validate_symbol(\" in txt:\n        return path, \"validate_symbol already present\"\n    # Вставим в конец файла простую безопасную реализацию",
        "detail": "apply_unified_master_patch_v5",
        "documentation": {}
    },
    {
        "label": "patch_runner_live",
        "kind": 2,
        "importPath": "apply_unified_master_patch_v5",
        "description": "apply_unified_master_patch_v5",
        "peekOfCode": "def patch_runner_live():\n    path = P_RUNNER / \"live.py\"\n    if not path.exists():\n        return None, \"runner/live.py not found\"\n    backup(path)\n    txt = path.read_text(encoding=\"utf-8\")\n    orig = txt\n    txt = _inject_import_env_overrides(txt)\n    txt = _inject_call_env_overrides_in_init(txt)\n    txt = _fix_self_getattr_and_config(txt)",
        "detail": "apply_unified_master_patch_v5",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "apply_unified_master_patch_v5",
        "description": "apply_unified_master_patch_v5",
        "peekOfCode": "def main():\n    changed = []\n    # 1) env_overrides (создание/обновление)\n    p = patch_env_overrides()\n    changed.append(f\"✓ updated {p.relative_to(BASE)}\")\n    # 2) utils: validate_symbol\n    p, msg = patch_core_utils()\n    if p:\n        changed.append(f\"✓ patched {p.relative_to(BASE)} — {msg}\")\n    else:",
        "detail": "apply_unified_master_patch_v5",
        "documentation": {}
    },
    {
        "label": "ROOT",
        "kind": 5,
        "importPath": "apply_unified_master_patch_v5",
        "description": "apply_unified_master_patch_v5",
        "peekOfCode": "ROOT = Path(__file__).resolve().parent\nBASE = ROOT  # текущая директория — у вас это .../crypto_trading_bot/work\n# Для большинства раскладок файлы есть именно тут:\nP_CORE = BASE / \"core\"\nP_RUNNER = BASE / \"runner\"\nP_EXCH = BASE / \"exchange\"\ndef backup(path: Path):\n    if not path.exists():\n        return\n    bak = path.with_suffix(path.suffix + \".bak_unified_v5\")",
        "detail": "apply_unified_master_patch_v5",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "apply_unified_master_patch_v5",
        "description": "apply_unified_master_patch_v5",
        "peekOfCode": "BASE = ROOT  # текущая директория — у вас это .../crypto_trading_bot/work\n# Для большинства раскладок файлы есть именно тут:\nP_CORE = BASE / \"core\"\nP_RUNNER = BASE / \"runner\"\nP_EXCH = BASE / \"exchange\"\ndef backup(path: Path):\n    if not path.exists():\n        return\n    bak = path.with_suffix(path.suffix + \".bak_unified_v5\")\n    if not bak.exists():",
        "detail": "apply_unified_master_patch_v5",
        "documentation": {}
    },
    {
        "label": "P_CORE",
        "kind": 5,
        "importPath": "apply_unified_master_patch_v5",
        "description": "apply_unified_master_patch_v5",
        "peekOfCode": "P_CORE = BASE / \"core\"\nP_RUNNER = BASE / \"runner\"\nP_EXCH = BASE / \"exchange\"\ndef backup(path: Path):\n    if not path.exists():\n        return\n    bak = path.with_suffix(path.suffix + \".bak_unified_v5\")\n    if not bak.exists():\n        bak.write_bytes(path.read_bytes())\ndef write_text(path: Path, text: str):",
        "detail": "apply_unified_master_patch_v5",
        "documentation": {}
    },
    {
        "label": "P_RUNNER",
        "kind": 5,
        "importPath": "apply_unified_master_patch_v5",
        "description": "apply_unified_master_patch_v5",
        "peekOfCode": "P_RUNNER = BASE / \"runner\"\nP_EXCH = BASE / \"exchange\"\ndef backup(path: Path):\n    if not path.exists():\n        return\n    bak = path.with_suffix(path.suffix + \".bak_unified_v5\")\n    if not bak.exists():\n        bak.write_bytes(path.read_bytes())\ndef write_text(path: Path, text: str):\n    path.parent.mkdir(parents=True, exist_ok=True)",
        "detail": "apply_unified_master_patch_v5",
        "documentation": {}
    },
    {
        "label": "P_EXCH",
        "kind": 5,
        "importPath": "apply_unified_master_patch_v5",
        "description": "apply_unified_master_patch_v5",
        "peekOfCode": "P_EXCH = BASE / \"exchange\"\ndef backup(path: Path):\n    if not path.exists():\n        return\n    bak = path.with_suffix(path.suffix + \".bak_unified_v5\")\n    if not bak.exists():\n        bak.write_bytes(path.read_bytes())\ndef write_text(path: Path, text: str):\n    path.parent.mkdir(parents=True, exist_ok=True)\n    path.write_text(text, encoding=\"utf-8\")",
        "detail": "apply_unified_master_patch_v5",
        "documentation": {}
    },
    {
        "label": "_PMPosition",
        "kind": 6,
        "importPath": "cli",
        "description": "cli",
        "peekOfCode": "class _PMPosition:\n    __slots__ = (\"symbol\",\"size\",\"entry_price\",\"side\",\"leverage\",\"unrealized_pnl\",\"margin\",\"timestamp\")\n    def __init__(self, symbol, size=0.0, entry_price=0.0, side=None, leverage=None,\n                 unrealized_pnl=0.0, margin=0.0, timestamp=None):\n        self.symbol = symbol\n        self.size = float(size)\n        self.entry_price = float(entry_price)\n        self.side = side\n        self.leverage = leverage\n        self.unrealized_pnl = float(unrealized_pnl)",
        "detail": "cli",
        "documentation": {}
    },
    {
        "label": "setup_logging",
        "kind": 2,
        "importPath": "cli",
        "description": "cli",
        "peekOfCode": "def setup_logging(verbose: bool = False) -> None:\n    \"\"\"Setup logging configuration.\"\"\"\n    level = logging.DEBUG if verbose else logging.INFO\n    logging.basicConfig(\n        level=level,\n        format=\"%(asctime)s | %(name)s | %(levelname)s | %(message)s\",\n        handlers=[\n            logging.StreamHandler(sys.stdout),\n            logging.FileHandler(\"trading_bot.log\"),\n        ],",
        "detail": "cli",
        "documentation": {}
    },
    {
        "label": "validate_symbols",
        "kind": 2,
        "importPath": "cli",
        "description": "cli",
        "peekOfCode": "def validate_symbols(symbols: list[str]) -> list[str]:\n    \"\"\"Validate and normalize trading symbols.\"\"\"\n    from core.utils import normalize_symbol\n    # Handle comma-separated symbols in a single string\n    all_symbols = []\n    for symbol_str in symbols:\n        if ',' in symbol_str:\n            all_symbols.extend([s.strip() for s in symbol_str.split(',') if s.strip()])\n        else:\n            all_symbols.append(symbol_str.strip())",
        "detail": "cli",
        "documentation": {}
    },
    {
        "label": "print_config_summary",
        "kind": 2,
        "importPath": "cli",
        "description": "cli",
        "peekOfCode": "def print_config_summary() -> None:\n    \"\"\"Print configuration summary.\"\"\"\n    config = get_config()\n    table = Table(title=\"Trading Bot Configuration\")\n    table.add_column(\"Setting\", style=\"cyan\")\n    table.add_column(\"Value\", style=\"green\")\n    table.add_row(\"Mode\", config.mode.value)\n    table.add_row(\"Testnet\", str(config.testnet))\n    table.add_row(\"Dry Run\", str(config.dry_run))\n    table.add_row(\"Symbols\", \", \".join(config.symbols))",
        "detail": "cli",
        "documentation": {}
    },
    {
        "label": "live",
        "kind": 2,
        "importPath": "cli",
        "description": "cli",
        "peekOfCode": "def live(\n    symbols: list[str] | None = typer.Option(\n        None, \"--symbols\", \"-s\", help=\"Trading symbols (e.g. BTCUSDT)\"\n    ),\n    timeframe: str | None = typer.Option(\n        None, \"--timeframe\", \"-t\", help=\"Timeframe (e.g. 1m, 5m, 1h)\"\n    ),\n    testnet: bool = typer.Option(\n        False, \"--testnet\", help=\"Use testnet instead of mainnet\"\n    ),",
        "detail": "cli",
        "documentation": {}
    },
    {
        "label": "paper",
        "kind": 2,
        "importPath": "cli",
        "description": "cli",
        "peekOfCode": "def paper(\n    symbols: list[str] | None = typer.Option(\n        None, \"--symbols\", \"-s\", help=\"Trading symbols\"\n    ),\n    timeframe: str | None = typer.Option(\n        None, \"--timeframe\", \"-t\", help=\"Timeframe\"\n    ),\n    verbose: bool = typer.Option(\n        False, \"--verbose\", \"-v\", help=\"Enable verbose logging\"\n    ),",
        "detail": "cli",
        "documentation": {}
    },
    {
        "label": "backtest",
        "kind": 2,
        "importPath": "cli",
        "description": "cli",
        "peekOfCode": "def backtest(\n    symbol: str = typer.Option(\"BTCUSDT\", \"--symbol\", \"-s\", help=\"Symbol to backtest\"),\n    timeframe: str = typer.Option(\"1m\", \"--timeframe\", \"-t\", help=\"Timeframe\"),\n    days: int = typer.Option(90, \"--days\", \"-d\", help=\"Days of historical data\"),\n    verbose: bool = typer.Option(\n        False, \"--verbose\", \"-v\", help=\"Enable verbose logging\"\n    ),\n    save_report: bool = typer.Option(\n        True, \"--save-report\", help=\"Save detailed report\"\n    ),",
        "detail": "cli",
        "documentation": {}
    },
    {
        "label": "portfolio",
        "kind": 2,
        "importPath": "cli",
        "description": "cli",
        "peekOfCode": "def portfolio(\n    symbols: list[str] = typer.Option(\n        [\"BTCUSDT\", \"ETHUSDT\"], \"--symbols\", \"-s\", help=\"Portfolio symbols\"\n    ),\n    timeframe: str = typer.Option(\"1m\", \"--timeframe\", \"-t\", help=\"Timeframe\"),\n    days: int = typer.Option(90, \"--days\", \"-d\", help=\"Days of historical data\"),\n    verbose: bool = typer.Option(\n        False, \"--verbose\", \"-v\", help=\"Enable verbose logging\"\n    ),\n    config_file: str | None = typer.Option(",
        "detail": "cli",
        "documentation": {}
    },
    {
        "label": "optimize",
        "kind": 2,
        "importPath": "cli",
        "description": "cli",
        "peekOfCode": "def optimize(\n    symbol: str = typer.Option(\"BTCUSDT\", \"--symbol\", \"-s\", help=\"Symbol to optimize\"),\n    timeframe: str = typer.Option(\"1m\", \"--timeframe\", \"-t\", help=\"Timeframe\"),\n    days: int = typer.Option(90, \"--days\", \"-d\", help=\"Days of data for optimization\"),\n    trials: int = typer.Option(100, \"--trials\", help=\"Number of optimization trials\"),\n    metric: str = typer.Option(\n        \"sharpe\", \"--metric\", help=\"Optimization metric (sharpe, return, drawdown)\"\n    ),\n    verbose: bool = typer.Option(\n        False, \"--verbose\", \"-v\", help=\"Enable verbose logging\"",
        "detail": "cli",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 2,
        "importPath": "cli",
        "description": "cli",
        "peekOfCode": "def config(\n    show: bool = typer.Option(False, \"--show\", help=\"Show current configuration\"),\n    validate: bool = typer.Option(False, \"--validate\", help=\"Validate configuration\"),\n    create_env: bool = typer.Option(\n        False, \"--create-env\", help=\"Create example .env file\"\n    ),\n) -> None:\n    \"\"\"\n    Configuration management utilities.\n    \"\"\"",
        "detail": "cli",
        "documentation": {}
    },
    {
        "label": "create_example_env",
        "kind": 2,
        "importPath": "cli",
        "description": "cli",
        "peekOfCode": "def create_example_env() -> None:\n    \"\"\"Create example .env file.\"\"\"\n    env_example = Path(\".env.example\")\n    env_file = Path(\".env\")\n    if env_file.exists():\n        if not typer.confirm(f\"{env_file} already exists. Overwrite?\"):\n            return\n    try:\n        import shutil\n        shutil.copy(env_example, env_file)",
        "detail": "cli",
        "documentation": {}
    },
    {
        "label": "print_backtest_results",
        "kind": 2,
        "importPath": "cli",
        "description": "cli",
        "peekOfCode": "def print_backtest_results(result: BacktestResult) -> None:\n    \"\"\"Print backtest results in a nice table.\"\"\"\n    table = Table(title=f\"Backtest Results: {result.symbol}\")\n    table.add_column(\"Metric\", style=\"cyan\")\n    table.add_column(\"Value\", style=\"green\")\n    table.add_row(\"Total Return\", f\"{result.total_return:.2%}\")\n    table.add_row(\"CAGR\", f\"{result.total_return:.2%}\")  # Simplified\n    table.add_row(\"Sharpe Ratio\", f\"{result.sharpe_ratio:.2f}\")\n    table.add_row(\"Max Drawdown\", f\"{result.max_drawdown:.2%}\")\n    table.add_row(\"Total Trades\", str(result.total_trades))",
        "detail": "cli",
        "documentation": {}
    },
    {
        "label": "print_portfolio_results",
        "kind": 2,
        "importPath": "cli",
        "description": "cli",
        "peekOfCode": "def print_portfolio_results(results: list[BacktestResult]) -> None:\n    \"\"\"Print portfolio backtest results.\"\"\"\n    table = Table(title=\"Portfolio Backtest Results\")\n    table.add_column(\"Symbol\", style=\"cyan\")\n    table.add_column(\"Return\", style=\"green\")\n    table.add_column(\"Sharpe\", style=\"blue\")\n    table.add_column(\"Max DD\", style=\"red\")\n    table.add_column(\"Trades\", style=\"magenta\")\n    table.add_column(\"Win Rate\", style=\"yellow\")\n    total_return = 0.0",
        "detail": "cli",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "cli",
        "description": "cli",
        "peekOfCode": "console = Console()\napp = typer.Typer(\n    name=\"trading-bot\",\n    help=\"AI Trading Bot with LSTM prediction and advanced risk management\",\n    add_completion=False,\n)\n# Global state for clean shutdown\n_shutdown_requested = False\ndef setup_logging(verbose: bool = False) -> None:\n    \"\"\"Setup logging configuration.\"\"\"",
        "detail": "cli",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "cli",
        "description": "cli",
        "peekOfCode": "app = typer.Typer(\n    name=\"trading-bot\",\n    help=\"AI Trading Bot with LSTM prediction and advanced risk management\",\n    add_completion=False,\n)\n# Global state for clean shutdown\n_shutdown_requested = False\ndef setup_logging(verbose: bool = False) -> None:\n    \"\"\"Setup logging configuration.\"\"\"\n    level = logging.DEBUG if verbose else logging.INFO",
        "detail": "cli",
        "documentation": {}
    },
    {
        "label": "_shutdown_requested",
        "kind": 5,
        "importPath": "cli",
        "description": "cli",
        "peekOfCode": "_shutdown_requested = False\ndef setup_logging(verbose: bool = False) -> None:\n    \"\"\"Setup logging configuration.\"\"\"\n    level = logging.DEBUG if verbose else logging.INFO\n    logging.basicConfig(\n        level=level,\n        format=\"%(asctime)s | %(name)s | %(levelname)s | %(message)s\",\n        handlers=[\n            logging.StreamHandler(sys.stdout),\n            logging.FileHandler(\"trading_bot.log\"),",
        "detail": "cli",
        "documentation": {}
    },
    {
        "label": "paper",
        "kind": 2,
        "importPath": "cli_integrated",
        "description": "cli_integrated",
        "peekOfCode": "def paper(\n    config: Optional[str] = typer.Option(None, \"--config\", help=\"Path to .env file\"),\n    symbols: Optional[str] = typer.Option(None, \"--symbols\", help=\"CSV symbols, e.g. BTCUSDT,ETHUSDT\"),\n    timeframe: Optional[str] = typer.Option(None, \"--timeframe\", help=\"Timeframe, e.g. 1m\"),\n    testnet: bool = typer.Option(True, \"--testnet/--no-testnet\", help=\"Use Binance Futures testnet\"),\n    dry_run: bool = typer.Option(True, \"--dry-run/--no-dry-run\", help=\"Do not send real orders\"),\n    verbose: bool = typer.Option(True, \"--verbose/--no-verbose\"),\n):\n    cfg = _build_config(\"paper\", config, symbols, timeframe, testnet, dry_run, verbose)\n    _print_cfg(cfg)",
        "detail": "cli_integrated",
        "documentation": {}
    },
    {
        "label": "live",
        "kind": 2,
        "importPath": "cli_integrated",
        "description": "cli_integrated",
        "peekOfCode": "def live(\n    config: Optional[str] = typer.Option(None, \"--config\", help=\"Path to .env file\"),\n    symbols: Optional[str] = typer.Option(None, \"--symbols\", help=\"CSV symbols, e.g. BTCUSDT,ETHUSDT\"),\n    timeframe: Optional[str] = typer.Option(None, \"--timeframe\", help=\"Timeframe, e.g. 1m\"),\n    testnet: bool = typer.Option(False, \"--testnet/--no-testnet\", help=\"Use Binance Futures testnet\"),\n    dry_run: bool = typer.Option(False, \"--dry-run/--no-dry-run\", help=\"Do not send real orders\"),\n    verbose: bool = typer.Option(True, \"--verbose/--no-verbose\"),\n):\n    cfg = _build_config(\"live\", config, symbols, timeframe, testnet, dry_run, verbose)\n    _print_cfg(cfg)",
        "detail": "cli_integrated",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "cli_integrated",
        "description": "cli_integrated",
        "peekOfCode": "app = typer.Typer(name=\"trading-bot\", add_completion=False)\ndef _load_env_file(path: Optional[str]):\n    data = {}\n    if not path:\n        return data\n    if not os.path.exists(path):\n        print(f\"WARNING: env file not found: {path}\")\n        return data\n    try:\n        # Try python-dotenv first",
        "detail": "cli_integrated",
        "documentation": {}
    },
    {
        "label": "setup_logging",
        "kind": 2,
        "importPath": "cli_updated",
        "description": "cli_updated",
        "peekOfCode": "def setup_logging(verbose: bool = False) -> None:\n    \"\"\"Setup logging configuration.\"\"\"\n    level = logging.DEBUG if verbose else logging.INFO\n    logging.basicConfig(\n        level=level,\n        format=\"%(asctime)s | %(name)s | %(levelname)s | %(message)s\",\n        handlers=[\n            logging.StreamHandler(sys.stdout),\n            logging.FileHandler(\"trading_bot.log\"),\n        ],",
        "detail": "cli_updated",
        "documentation": {}
    },
    {
        "label": "validate_symbols",
        "kind": 2,
        "importPath": "cli_updated",
        "description": "cli_updated",
        "peekOfCode": "def validate_symbols(symbols: list[str]) -> list[str]:\n    \"\"\"Validate and normalize trading symbols.\"\"\"\n    from core.utils import normalize_symbol\n    # Handle comma-separated symbols in a single string\n    all_symbols = []\n    for symbol_str in symbols:\n        if ',' in symbol_str:\n            all_symbols.extend([s.strip() for s in symbol_str.split(',') if s.strip()])\n        else:\n            all_symbols.append(symbol_str.strip())",
        "detail": "cli_updated",
        "documentation": {}
    },
    {
        "label": "print_config_summary",
        "kind": 2,
        "importPath": "cli_updated",
        "description": "cli_updated",
        "peekOfCode": "def print_config_summary() -> None:\n    \"\"\"Print configuration summary.\"\"\"\n    config = get_config()\n    table = Table(title=\"Trading Bot Configuration\")\n    table.add_column(\"Setting\", style=\"cyan\")\n    table.add_column(\"Value\", style=\"green\")\n    table.add_row(\"Mode\", config.mode.value)\n    table.add_row(\"Testnet\", str(config.testnet))\n    table.add_row(\"Dry Run\", str(config.dry_run))\n    table.add_row(\"Symbols\", \", \".join(config.symbols))",
        "detail": "cli_updated",
        "documentation": {}
    },
    {
        "label": "live",
        "kind": 2,
        "importPath": "cli_updated",
        "description": "cli_updated",
        "peekOfCode": "def live(\n    symbols: list[str] | None = typer.Option(\n        None, \"--symbols\", \"-s\", help=\"Trading symbols (e.g. BTCUSDT)\"\n    ),\n    timeframe: str | None = typer.Option(\n        None, \"--timeframe\", \"-t\", help=\"Timeframe (e.g. 1m, 5m, 1h)\"\n    ),\n    testnet: bool = typer.Option(\n        False, \"--testnet\", help=\"Use testnet instead of mainnet\"\n    ),",
        "detail": "cli_updated",
        "documentation": {}
    },
    {
        "label": "paper",
        "kind": 2,
        "importPath": "cli_updated",
        "description": "cli_updated",
        "peekOfCode": "def paper(\n    symbols: list[str] | None = typer.Option(\n        None, \"--symbols\", \"-s\", help=\"Trading symbols\"\n    ),\n    timeframe: str | None = typer.Option(\n        None, \"--timeframe\", \"-t\", help=\"Timeframe\"\n    ),\n    config: str | None = typer.Option(\n        None, \"--config\", \"-c\", help=\"Configuration file path (e.g., .env.testnet)\"\n    ),",
        "detail": "cli_updated",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "cli_updated",
        "description": "cli_updated",
        "peekOfCode": "def test(\n    component: str = typer.Option(\"all\", help=\"Component to test (all, imports, startup, positions)\")\n) -> None:\n    \"\"\"\n    Run tests to verify bot functionality.\n    \"\"\"\n    console.print(f\"[yellow]Testing {component}...[/yellow]\")\n    if component == \"imports\" or component == \"all\":\n        console.print(\"\\n🧪 Testing imports...\")\n        try:",
        "detail": "cli_updated",
        "documentation": {}
    },
    {
        "label": "fix",
        "kind": 2,
        "importPath": "cli_updated",
        "description": "cli_updated",
        "peekOfCode": "def fix(\n    clean_cache: bool = typer.Option(True, help=\"Clean Python cache files\"),\n    validate: bool = typer.Option(True, help=\"Validate configuration\")\n) -> None:\n    \"\"\"\n    Fix common issues with the trading bot.\n    \"\"\"\n    console.print(\"[yellow]Running bot fixes...[/yellow]\")\n    if clean_cache:\n        console.print(\"\\n🧹 Cleaning Python cache...\")",
        "detail": "cli_updated",
        "documentation": {}
    },
    {
        "label": "config",
        "kind": 2,
        "importPath": "cli_updated",
        "description": "cli_updated",
        "peekOfCode": "def config(\n    show: bool = typer.Option(False, \"--show\", help=\"Show current configuration\"),\n    validate: bool = typer.Option(False, \"--validate\", help=\"Validate configuration\"),\n    create_env: bool = typer.Option(\n        False, \"--create-env\", help=\"Create example .env file\"\n    ),\n) -> None:\n    \"\"\"\n    Configuration management utilities.\n    \"\"\"",
        "detail": "cli_updated",
        "documentation": {}
    },
    {
        "label": "create_example_env",
        "kind": 2,
        "importPath": "cli_updated",
        "description": "cli_updated",
        "peekOfCode": "def create_example_env() -> None:\n    \"\"\"Create example .env file.\"\"\"\n    env_example = Path(\".env.example\") \n    env_file = Path(\".env\")\n    if env_file.exists():\n        if not typer.confirm(f\"{env_file} already exists. Overwrite?\"):\n            return\n    try:\n        if env_example.exists():\n            import shutil",
        "detail": "cli_updated",
        "documentation": {}
    },
    {
        "label": "console",
        "kind": 5,
        "importPath": "cli_updated",
        "description": "cli_updated",
        "peekOfCode": "console = Console()\napp = typer.Typer(\n    name=\"trading-bot\",\n    help=\"AI Trading Bot with LSTM prediction and advanced risk management\",\n    add_completion=False,\n)\ndef setup_logging(verbose: bool = False) -> None:\n    \"\"\"Setup logging configuration.\"\"\"\n    level = logging.DEBUG if verbose else logging.INFO\n    logging.basicConfig(",
        "detail": "cli_updated",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "cli_updated",
        "description": "cli_updated",
        "peekOfCode": "app = typer.Typer(\n    name=\"trading-bot\",\n    help=\"AI Trading Bot with LSTM prediction and advanced risk management\",\n    add_completion=False,\n)\ndef setup_logging(verbose: bool = False) -> None:\n    \"\"\"Setup logging configuration.\"\"\"\n    level = logging.DEBUG if verbose else logging.INFO\n    logging.basicConfig(\n        level=level,",
        "detail": "cli_updated",
        "documentation": {}
    },
    {
        "label": "_PMPosition",
        "kind": 6,
        "importPath": "compat",
        "description": "compat",
        "peekOfCode": "class _PMPosition:\n    __slots__ = (\"symbol\", \"size\", \"entry_price\", \"side\", \"leverage\",\n                 \"unrealized_pnl\", \"margin\", \"timestamp\")\n    def __init__(self, symbol, size=0.0, entry_price=0.0, side=None, leverage=None,\n                 unrealized_pnl=0.0, margin=0.0, timestamp=None):\n        self.symbol = symbol\n        self.size = float(size)\n        self.entry_price = float(entry_price)\n        self.side = side\n        self.leverage = leverage",
        "detail": "compat",
        "documentation": {}
    },
    {
        "label": "_ExitDecision",
        "kind": 6,
        "importPath": "compat",
        "description": "compat",
        "peekOfCode": "class _ExitDecision:\n    __slots__ = (\"exit\", \"should_exit\", \"reason\", \"exit_price\")\n    def __init__(self, exit=False, reason=None, exit_price=None):\n        self.exit = bool(exit)\n        self.should_exit = bool(exit)\n        self.reason = reason\n        self.exit_price = exit_price\n    def __bool__(self):\n        return self.exit\n# --- Обёртка сигнала: await‑совместимый dict с обязательными полями",
        "detail": "compat",
        "documentation": {}
    },
    {
        "label": "_SignalEnvelope",
        "kind": 6,
        "importPath": "compat",
        "description": "compat",
        "peekOfCode": "class _SignalEnvelope(dict):\n    __slots__ = ()\n    def __getattr__(self, name):\n        if name in self: return self[name]\n        raise AttributeError(name)\n    def __await__(self):\n        async def _coro(): return self\n        return _coro().__await__()\n    def __bool__(self): return True\nclass _AwaitableNone:",
        "detail": "compat",
        "documentation": {}
    },
    {
        "label": "_AwaitableNone",
        "kind": 6,
        "importPath": "compat",
        "description": "compat",
        "peekOfCode": "class _AwaitableNone:\n    __slots__ = ()\n    def __await__(self):\n        async def _coro(): return None\n        return _coro().__await__()\n    def __bool__(self): return False\ndef _pm_balance_from_client(client):\n    for attr in (\"get_account_balance\", \"get_balance\", \"balance\"):\n        if hasattr(client, attr):\n            obj = getattr(client, attr)",
        "detail": "compat",
        "documentation": {}
    },
    {
        "label": "_CfgWrapper",
        "kind": 6,
        "importPath": "compat",
        "description": "compat",
        "peekOfCode": "class _CfgWrapper:\n    __slots__ = (\"_base\", \"_extra\")\n    def __init__(self, base, extra: dict):\n        object.__setattr__(self, \"_base\", base)\n        object.__setattr__(self, \"_extra\", dict(extra))\n    def __getattr__(self, name):\n        ex = object.__getattribute__(self, \"_extra\")\n        if name in ex: return ex[name]\n        return getattr(object.__getattribute__(self, \"_base\"), name)\n    def __setattr__(self, name, value):",
        "detail": "compat",
        "documentation": {}
    },
    {
        "label": "normalize_config",
        "kind": 2,
        "importPath": "compat",
        "description": "compat",
        "peekOfCode": "def normalize_config(cfg):\n    \"\"\"\n    Обязательные безопасные дефолты (доли/флаги):\n      - max_daily_loss → 0.05\n      - max_drawdown → 0.20\n      - min_account_balance → 0.0\n      - close_positions_on_exit → False\n      - sl_fixed_pct → 0.003\n      - trading_hours_enabled → False\n      - trading_session_tz → \"UTC\"",
        "detail": "compat",
        "documentation": {}
    },
    {
        "label": "apply",
        "kind": 2,
        "importPath": "compat",
        "description": "compat",
        "peekOfCode": "def apply():\n    global __COMPAT_APPLIED__\n    if __COMPAT_APPLIED__: return\n    __COMPAT_APPLIED__ = True\n    _ensure_pm()\n    # _ensure_exits()\n    # _ensure_signal_wrappers() \n    # _ensure_om()\n    # _ensure_client()\n    # _ensure_metrics()",
        "detail": "compat",
        "documentation": {}
    },
    {
        "label": "__COMPAT_APPLIED__",
        "kind": 5,
        "importPath": "compat",
        "description": "compat",
        "peekOfCode": "__COMPAT_APPLIED__ = False\n# ====================== Утилиты ======================\nclass _PMPosition:\n    __slots__ = (\"symbol\", \"size\", \"entry_price\", \"side\", \"leverage\",\n                 \"unrealized_pnl\", \"margin\", \"timestamp\")\n    def __init__(self, symbol, size=0.0, entry_price=0.0, side=None, leverage=None,\n                 unrealized_pnl=0.0, margin=0.0, timestamp=None):\n        self.symbol = symbol\n        self.size = float(size)\n        self.entry_price = float(entry_price)",
        "detail": "compat",
        "documentation": {}
    },
    {
        "label": "_PMPosition",
        "kind": 6,
        "importPath": "compat_complete",
        "description": "compat_complete",
        "peekOfCode": "class _PMPosition:\n    __slots__ = (\"symbol\", \"size\", \"entry_price\", \"side\", \"leverage\",\n                 \"unrealized_pnl\", \"margin\", \"timestamp\")\n    def __init__(self, symbol, size=0.0, entry_price=0.0, side=None, leverage=None,\n                 unrealized_pnl=0.0, margin=0.0, timestamp=None):\n        self.symbol = symbol\n        self.size = float(size)\n        self.entry_price = float(entry_price)\n        self.side = side\n        self.leverage = leverage",
        "detail": "compat_complete",
        "documentation": {}
    },
    {
        "label": "_ExitDecision",
        "kind": 6,
        "importPath": "compat_complete",
        "description": "compat_complete",
        "peekOfCode": "class _ExitDecision:\n    __slots__ = (\"exit\", \"should_exit\", \"reason\", \"exit_price\")\n    def __init__(self, exit=False, reason=None, exit_price=None):\n        self.exit = bool(exit)\n        self.should_exit = bool(exit)\n        self.reason = reason\n        self.exit_price = exit_price\n    def __bool__(self):\n        return self.exit\n# --- Обёртка сигнала: await‑совместимый dict с обязательными полями",
        "detail": "compat_complete",
        "documentation": {}
    },
    {
        "label": "_SignalEnvelope",
        "kind": 6,
        "importPath": "compat_complete",
        "description": "compat_complete",
        "peekOfCode": "class _SignalEnvelope(dict):\n    __slots__ = ()\n    def __getattr__(self, name):\n        if name in self: return self[name]\n        raise AttributeError(name)\n    def __await__(self):\n        async def _coro(): return self\n        return _coro().__await__()\n    def __bool__(self): return True\nclass _AwaitableNone:",
        "detail": "compat_complete",
        "documentation": {}
    },
    {
        "label": "_AwaitableNone",
        "kind": 6,
        "importPath": "compat_complete",
        "description": "compat_complete",
        "peekOfCode": "class _AwaitableNone:\n    __slots__ = ()\n    def __await__(self):\n        async def _coro(): return None\n        return _coro().__await__()\n    def __bool__(self): return False\ndef _pm_balance_from_client(client):\n    for attr in (\"get_account_balance\", \"get_balance\", \"balance\"):\n        if hasattr(client, attr):\n            obj = getattr(client, attr)",
        "detail": "compat_complete",
        "documentation": {}
    },
    {
        "label": "_CfgWrapper",
        "kind": 6,
        "importPath": "compat_complete",
        "description": "compat_complete",
        "peekOfCode": "class _CfgWrapper:\n    __slots__ = (\"_base\", \"_extra\")\n    def __init__(self, base, extra: dict):\n        object.__setattr__(self, \"_base\", base)\n        object.__setattr__(self, \"_extra\", dict(extra))\n    def __getattr__(self, name):\n        ex = object.__getattribute__(self, \"_extra\")\n        if name in ex: return ex[name]\n        return getattr(object.__getattribute__(self, \"_base\"), name)\n    def __setattr__(self, name, value):",
        "detail": "compat_complete",
        "documentation": {}
    },
    {
        "label": "_BinanceNoiseFilter",
        "kind": 6,
        "importPath": "compat_complete",
        "description": "compat_complete",
        "peekOfCode": "class _BinanceNoiseFilter(logging.Filter):\n    def filter(self, record: logging.LogRecord) -> bool:\n        msg = record.getMessage()\n        if not isinstance(msg, str): msg = str(msg)\n        noise = (\"No need to change margin type\",\"No need to change position side\",\"No need to change leverage\")\n        return not any(n in msg for n in noise)\ndef _install_noise_filter():\n    lg = logging.getLogger(\"exchange.client\")\n    if not any(isinstance(f, _BinanceNoiseFilter) for f in lg.filters):\n        lg.addFilter(_BinanceNoiseFilter())",
        "detail": "compat_complete",
        "documentation": {}
    },
    {
        "label": "normalize_config",
        "kind": 2,
        "importPath": "compat_complete",
        "description": "compat_complete",
        "peekOfCode": "def normalize_config(cfg):\n    \"\"\"\n    КРИТИЧЕСКИЕ ИСПРАВЛЕНИЯ - Все отсутствующие свойства из пользовательских ошибок:\n      - max_daily_loss → 0.05\n      - close_positions_on_exit → False  \n      - risk_per_trade → risk_per_trade_pct / 100.0  # КРИТИЧЕСКИЙ ФИX\n      - consecutive_errors → 0 (будет добавлено в MetricsCollector)\n    \"\"\"\n    defaults = {\n        \"max_daily_loss\": 0.05,",
        "detail": "compat_complete",
        "documentation": {}
    },
    {
        "label": "apply",
        "kind": 2,
        "importPath": "compat_complete",
        "description": "compat_complete",
        "peekOfCode": "def apply():\n    \"\"\"Применить все патчи совместимости\"\"\"\n    global __COMPAT_APPLIED__\n    if __COMPAT_APPLIED__: \n        logging.debug(\"compat: Already applied, skipping\")\n        return\n    logging.info(\"compat: Applying comprehensive compatibility patches...\")\n    __COMPAT_APPLIED__ = True\n    try:\n        _install_radical_import_interceptor()  # РАДИКАЛЬНЫЙ: перехват на уровне import!",
        "detail": "compat_complete",
        "documentation": {}
    },
    {
        "label": "__COMPAT_APPLIED__",
        "kind": 5,
        "importPath": "compat_complete",
        "description": "compat_complete",
        "peekOfCode": "__COMPAT_APPLIED__ = False\n# ====================== Утилиты ======================\nclass _PMPosition:\n    __slots__ = (\"symbol\", \"size\", \"entry_price\", \"side\", \"leverage\",\n                 \"unrealized_pnl\", \"margin\", \"timestamp\")\n    def __init__(self, symbol, size=0.0, entry_price=0.0, side=None, leverage=None,\n                 unrealized_pnl=0.0, margin=0.0, timestamp=None):\n        self.symbol = symbol\n        self.size = float(size)\n        self.entry_price = float(entry_price)",
        "detail": "compat_complete",
        "documentation": {}
    },
    {
        "label": "_MC_ERRORS",
        "kind": 5,
        "importPath": "compat_complete",
        "description": "compat_complete",
        "peekOfCode": "_MC_ERRORS = {}\ndef _ensure_metrics():\n    try: mc_mod = importlib.import_module(\"infra.metrics\")\n    except Exception: return\n    MC = getattr(mc_mod, \"MetricsCollector\", None)\n    if MC is None: return\n    # КРИТИЧЕСКИЙ ФИX: consecutive_errors свойство\n    if not isinstance(getattr(MC, \"consecutive_errors\", None), property):\n        def _get(self): return int(_MC_ERRORS.get(id(self), 0))\n        def _set(self, v):",
        "detail": "compat_complete",
        "documentation": {}
    },
    {
        "label": "_PMPosition",
        "kind": 6,
        "importPath": "compat_integrate",
        "description": "compat_integrate",
        "peekOfCode": "class _PMPosition:\n    __slots__ = (\"symbol\", \"size\", \"entry_price\", \"side\", \"leverage\",\n                 \"unrealized_pnl\", \"margin\", \"timestamp\")\n    def __init__(self, symbol, size=0.0, entry_price=0.0, side=None, leverage=None,\n                 unrealized_pnl=0.0, margin=0.0, timestamp=None):\n        self.symbol = symbol\n        self.size = float(size)\n        self.entry_price = float(entry_price)\n        self.side = side\n        self.leverage = leverage",
        "detail": "compat_integrate",
        "documentation": {}
    },
    {
        "label": "_ExitDecision",
        "kind": 6,
        "importPath": "compat_integrate",
        "description": "compat_integrate",
        "peekOfCode": "class _ExitDecision:\n    __slots__ = (\"exit\", \"should_exit\", \"reason\", \"exit_price\")\n    def __init__(self, exit=False, reason=None, exit_price=None):\n        self.exit = bool(exit)\n        self.should_exit = bool(exit)\n        self.reason = reason\n        self.exit_price = exit_price\n    def __bool__(self):\n        return self.exit\n# --- Обёртка сигнала: await‑совместимый dict с обязательными полями",
        "detail": "compat_integrate",
        "documentation": {}
    },
    {
        "label": "_SignalEnvelope",
        "kind": 6,
        "importPath": "compat_integrate",
        "description": "compat_integrate",
        "peekOfCode": "class _SignalEnvelope(dict):\n    __slots__ = ()\n    def __getattr__(self, name):\n        if name in self: return self[name]\n        raise AttributeError(name)\n    def __await__(self):\n        async def _coro(): return self\n        return _coro().__await__()\n    def __bool__(self): return True\nclass _AwaitableNone:",
        "detail": "compat_integrate",
        "documentation": {}
    },
    {
        "label": "_AwaitableNone",
        "kind": 6,
        "importPath": "compat_integrate",
        "description": "compat_integrate",
        "peekOfCode": "class _AwaitableNone:\n    __slots__ = ()\n    def __await__(self):\n        async def _coro(): return None\n        return _coro().__await__()\n    def __bool__(self): return False\ndef _pm_balance_from_client(client):\n    for attr in (\"get_account_balance\", \"get_balance\", \"balance\"):\n        if hasattr(client, attr):\n            obj = getattr(client, attr)",
        "detail": "compat_integrate",
        "documentation": {}
    },
    {
        "label": "_CfgWrapper",
        "kind": 6,
        "importPath": "compat_integrate",
        "description": "compat_integrate",
        "peekOfCode": "class _CfgWrapper:\n    __slots__ = (\"_base\", \"_extra\")\n    def __init__(self, base, extra: dict):\n        object.__setattr__(self, \"_base\", base)\n        object.__setattr__(self, \"_extra\", dict(extra))\n    def __getattr__(self, name):\n        ex = object.__getattribute__(self, \"_extra\")\n        if name in ex: return ex[name]\n        return getattr(object.__getattribute__(self, \"_base\"), name)\n    def __setattr__(self, name, value):",
        "detail": "compat_integrate",
        "documentation": {}
    },
    {
        "label": "save_user_file",
        "kind": 2,
        "importPath": "compat_integrate",
        "description": "compat_integrate",
        "peekOfCode": "def save_user_file(filename: str, content: str) -> None:\n    \"\"\"Save user's uploaded file content to proper location.\"\"\"\n    filepath = Path(filename)\n    print(f\"📁 Creating {filepath}\")\n    # Create directories if needed\n    filepath.parent.mkdir(parents=True, exist_ok=True)\n    with open(filepath, 'w', encoding='utf-8') as f:\n        f.write(content)\n    print(f\"✅ Saved {filepath} ({len(content)} chars)\")\ndef integrate_user_compat_system():",
        "detail": "compat_integrate",
        "documentation": {}
    },
    {
        "label": "integrate_user_compat_system",
        "kind": 2,
        "importPath": "compat_integrate",
        "description": "compat_integrate",
        "peekOfCode": "def integrate_user_compat_system():\n    \"\"\"Integrate user's advanced compat.py with our current system.\"\"\"\n    # User's compat.py content (from uploaded file)\n    COMPAT_PY_CONTENT = \"\"\"# compat.py\n# Совместимость и защитные обёртки для runner.paper / runner.live и клиентов биржи.\nimport importlib\nimport inspect\nimport time\nimport logging\nimport math",
        "detail": "compat_integrate",
        "documentation": {}
    },
    {
        "label": "normalize_config",
        "kind": 2,
        "importPath": "compat_integrate",
        "description": "compat_integrate",
        "peekOfCode": "def normalize_config(cfg):\n    \\\"\\\"\\\"\n    Обязательные безопасные дефолты (доли/флаги):\n      - max_daily_loss → 0.05\n      - max_drawdown → 0.20\n      - min_account_balance → 0.0\n      - close_positions_on_exit → False\n      - sl_fixed_pct → 0.003\n      - trading_hours_enabled → False\n      - trading_session_tz → \"UTC\"",
        "detail": "compat_integrate",
        "documentation": {}
    },
    {
        "label": "apply",
        "kind": 2,
        "importPath": "compat_integrate",
        "description": "compat_integrate",
        "peekOfCode": "def apply():\n    global __COMPAT_APPLIED__\n    if __COMPAT_APPLIED__: return\n    __COMPAT_APPLIED__ = True\n    _ensure_pm()\n    # _ensure_exits()\n    # _ensure_signal_wrappers() \n    # _ensure_om()\n    # _ensure_client()\n    # _ensure_metrics()",
        "detail": "compat_integrate",
        "documentation": {}
    },
    {
        "label": "create_integrated_cli",
        "kind": 2,
        "importPath": "compat_integrate",
        "description": "compat_integrate",
        "peekOfCode": "def create_integrated_cli():\n    \"\"\"Create integrated CLI that uses user's system.\"\"\"\n    CLI_INTEGRATED = '''#!/usr/bin/env python3\n\"\"\"\nINTEGRATED AI Trading Bot CLI - User's Advanced System + Our Critical Fixes\nCombines user's sophisticated 30+ file modular architecture with critical fixes.\n\"\"\"\nimport sys\nimport logging\n# Apply compatibility patches FIRST",
        "detail": "compat_integrate",
        "documentation": {}
    },
    {
        "label": "integrate_user_system",
        "kind": 2,
        "importPath": "compat_integrate",
        "description": "compat_integrate",
        "peekOfCode": "def integrate_user_system():\n    \"\"\"Main integration function.\"\"\"\n    print(\"🔄 INTEGRATING USER'S ADVANCED SYSTEM WITH OUR CRITICAL FIXES\")\n    print(\"=\" * 70)\n    print(\"\\n1. 📦 Integrating advanced compat.py system...\")\n    integrate_user_compat_system()\n    print(\"\\n2. 🖥️ Creating integrated CLI...\")\n    create_integrated_cli()\n    print(\"\\n3. ✅ Integration completed!\")\n    print(\"\\n🎯 RESULT:\")",
        "detail": "compat_integrate",
        "documentation": {}
    },
    {
        "label": "__COMPAT_APPLIED__",
        "kind": 5,
        "importPath": "compat_integrate",
        "description": "compat_integrate",
        "peekOfCode": "__COMPAT_APPLIED__ = False\n# ====================== Утилиты ======================\nclass _PMPosition:\n    __slots__ = (\"symbol\", \"size\", \"entry_price\", \"side\", \"leverage\",\n                 \"unrealized_pnl\", \"margin\", \"timestamp\")\n    def __init__(self, symbol, size=0.0, entry_price=0.0, side=None, leverage=None,\n                 unrealized_pnl=0.0, margin=0.0, timestamp=None):\n        self.symbol = symbol\n        self.size = float(size)\n        self.entry_price = float(entry_price)",
        "detail": "compat_integrate",
        "documentation": {}
    },
    {
        "label": "check_current_settings",
        "kind": 2,
        "importPath": "debug_trading_activity",
        "description": "debug_trading_activity",
        "peekOfCode": "def check_current_settings():\n    \"\"\"Check the current .env settings that affect trading.\"\"\"\n    # Load environment variables\n    load_dotenv()\n    print(\"🔍 Current Trading Settings Analysis\")\n    print(\"=\" * 50)\n    # Key settings that affect trade execution\n    key_settings = {\n        'MIN_ADX': 'Minimum ADX for signals (lower = more signals)',\n        'BT_CONF_MIN': 'Minimum confidence for trades (lower = more trades)', ",
        "detail": "debug_trading_activity",
        "documentation": {}
    },
    {
        "label": "create_ultra_aggressive_env",
        "kind": 2,
        "importPath": "debug_trading_activity",
        "description": "debug_trading_activity",
        "peekOfCode": "def create_ultra_aggressive_env():\n    \"\"\"Create ultra-aggressive settings for maximum trading.\"\"\"\n    ultra_settings = \"\"\"# ULTRA AGGRESSIVE TRADING PROFILE - MAXIMUM ACTIVITY\nMODE=paper\nDRY_RUN=true\nTESTNET=true\nSYMBOL=BTCUSDT\nSYMBOLS=BTCUSDT,ETHUSDT\nTIMEFRAME=1m\nLEVERAGE=5",
        "detail": "debug_trading_activity",
        "documentation": {}
    },
    {
        "label": "suggest_fixes",
        "kind": 2,
        "importPath": "debug_trading_activity",
        "description": "debug_trading_activity",
        "peekOfCode": "def suggest_fixes():\n    \"\"\"Suggest fixes based on current settings.\"\"\"\n    print(\"\\n🔧 IMMEDIATE FIXES:\")\n    print(\"=\" * 30)\n    print(\"1. 📊 Check if aggressive profile is loaded:\")\n    print(\"   python cli_updated.py config --show\")\n    print(\"\\n2. 🔥 Apply ultra-aggressive settings:\")\n    print(\"   cp .env.ultra_debug .env\")\n    print(\"   python cli_updated.py config --show\")\n    print(\"\\n3. 🎯 If still no trades, try environment override:\")",
        "detail": "debug_trading_activity",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "debug_trading_activity",
        "description": "debug_trading_activity",
        "peekOfCode": "def main():\n    \"\"\"Main diagnostic function.\"\"\"\n    print(\"🔍 TRADING ACTIVITY DEBUG\")\n    print(\"=\" * 50)\n    print(\"Problem: Bot generates signals every second but no trades occur\")\n    print(\"=\" * 50)\n    check_current_settings()\n    create_ultra_aggressive_env()\n    suggest_fixes()\n    print(\"\\n\" + \"=\" * 50)",
        "detail": "debug_trading_activity",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "demo_sample_data",
        "description": "demo_sample_data",
        "peekOfCode": "def main():\n    \"\"\"Main demo function.\"\"\"\n    print(\"🚀 Crypto Trading Bot - Sample Data Demo\")\n    print(\"=\" * 50)\n    # Show available symbols\n    print(\"\\n📊 Available Sample Symbols:\")\n    symbols = get_available_symbols()\n    for symbol in symbols:\n        print(f\"  • {symbol}\")\n    # Validate data",
        "detail": "demo_sample_data",
        "documentation": {}
    },
    {
        "label": "diagnose_binance_connection",
        "kind": 2,
        "importPath": "diagnose_binance_api",
        "description": "diagnose_binance_api",
        "peekOfCode": "def diagnose_binance_connection():\n    \"\"\"Диагностирует проблемы с Binance API подключением\"\"\"\n    print(\"🔍 ДИАГНОСТИКА BINANCE API ПОДКЛЮЧЕНИЯ\")\n    print(\"=\" * 50)\n    # Загружаем .env.testnet\n    env_file = \".env.testnet\"\n    if os.path.exists(env_file):\n        load_dotenv(env_file)\n        print(f\"✅ Загружен файл: {env_file}\")\n    else:",
        "detail": "diagnose_binance_api",
        "documentation": {}
    },
    {
        "label": "show_testnet_guide",
        "kind": 2,
        "importPath": "diagnose_binance_api",
        "description": "diagnose_binance_api",
        "peekOfCode": "def show_testnet_guide():\n    \"\"\"Показать инструкции по получению Testnet ключей\"\"\"\n    print(\"\\n\" + \"=\"*50)\n    print(\"📝 КАК ПОЛУЧИТЬ ПРАВИЛЬНЫЕ TESTNET API КЛЮЧИ:\")\n    print(\"=\"*50)\n    print()\n    print(\"1. Перейдите на: https://testnet.binance.vision/\")\n    print(\"2. Войдите через GitHub аккаунт\")  \n    print(\"3. Нажмите 'Generate HMAC_SHA256 Key'\")\n    print(\"4. Скопируйте API Key и Secret Key\")",
        "detail": "diagnose_binance_api",
        "documentation": {}
    },
    {
        "label": "OrderStatus",
        "kind": 6,
        "importPath": "emergency_constants_fix",
        "description": "emergency_constants_fix",
        "peekOfCode": "class OrderStatus(Enum):\n    \"\"\"Order status types.\"\"\"\n    NEW = \"NEW\"\n    PARTIALLY_FILLED = \"PARTIALLY_FILLED\"\n    FILLED = \"FILLED\"\n    CANCELED = \"CANCELED\"\n    REJECTED = \"REJECTED\"\n    EXPIRED = \"EXPIRED\"\nclass Regime(Enum):\n    \"\"\"Market regime types.\"\"\"",
        "detail": "emergency_constants_fix",
        "documentation": {}
    },
    {
        "label": "Regime",
        "kind": 6,
        "importPath": "emergency_constants_fix",
        "description": "emergency_constants_fix",
        "peekOfCode": "class Regime(Enum):\n    \"\"\"Market regime types.\"\"\"\n    TRENDING = \"TRENDING\"\n    RANGING = \"RANGING\"\n    VOLATILE = \"VOLATILE\"\n    STABLE = \"STABLE\"\nclass SignalDirection(Enum):\n    \"\"\"Signal direction types.\"\"\"\n    LONG = \"LONG\"\n    SHORT = \"SHORT\"",
        "detail": "emergency_constants_fix",
        "documentation": {}
    },
    {
        "label": "SignalDirection",
        "kind": 6,
        "importPath": "emergency_constants_fix",
        "description": "emergency_constants_fix",
        "peekOfCode": "class SignalDirection(Enum):\n    \"\"\"Signal direction types.\"\"\"\n    LONG = \"LONG\"\n    SHORT = \"SHORT\"\n    NEUTRAL = \"NEUTRAL\"\n    CLOSE = \"CLOSE\"\n'''\n    # Update __all__ exports\n    updated_exports = '''\n# Explicit exports for better compatibility",
        "detail": "emergency_constants_fix",
        "documentation": {}
    },
    {
        "label": "fix_missing_constants",
        "kind": 2,
        "importPath": "emergency_constants_fix",
        "description": "emergency_constants_fix",
        "peekOfCode": "def fix_missing_constants():\n    \"\"\"Add missing constants to core/constants.py\"\"\"\n    print(\"🔧 Emergency fix for missing constants...\")\n    # Read current constants\n    constants_file = \"core/constants.py\"\n    with open(constants_file, 'r', encoding='utf-8') as f:\n        current_content = f.read()\n    print(\"📋 Current constants found:\")\n    if \"OrderStatus\" in current_content:\n        print(\"✅ OrderStatus already exists\")",
        "detail": "emergency_constants_fix",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "emergency_constants_fix",
        "description": "emergency_constants_fix",
        "peekOfCode": "__all__ = [\n    \"TradingMode\",\n    \"OrderSide\", \n    \"OrderType\",\n    \"OrderStatus\",\n    \"PositionSide\",\n    \"SignalType\",\n    \"ExitReason\",\n    \"Regime\",\n    \"SignalDirection\",",
        "detail": "emergency_constants_fix",
        "documentation": {}
    },
    {
        "label": "TradingMode",
        "kind": 6,
        "importPath": "emergency_import_fix",
        "description": "emergency_import_fix",
        "peekOfCode": "class TradingMode(Enum):\n    \"\"\"Trading execution modes.\"\"\"\n    LIVE = \"live\"\n    PAPER = \"paper\"\n    BACKTEST = \"backtest\"\nclass OrderSide(Enum):\n    \"\"\"Order side directions.\"\"\"\n    BUY = \"BUY\"\n    SELL = \"SELL\"\nclass OrderType(Enum):",
        "detail": "emergency_import_fix",
        "documentation": {}
    },
    {
        "label": "OrderSide",
        "kind": 6,
        "importPath": "emergency_import_fix",
        "description": "emergency_import_fix",
        "peekOfCode": "class OrderSide(Enum):\n    \"\"\"Order side directions.\"\"\"\n    BUY = \"BUY\"\n    SELL = \"SELL\"\nclass OrderType(Enum):\n    \"\"\"Order types.\"\"\"\n    MARKET = \"MARKET\"\n    LIMIT = \"LIMIT\"\n    STOP = \"STOP\"\n    STOP_MARKET = \"STOP_MARKET\"",
        "detail": "emergency_import_fix",
        "documentation": {}
    },
    {
        "label": "OrderType",
        "kind": 6,
        "importPath": "emergency_import_fix",
        "description": "emergency_import_fix",
        "peekOfCode": "class OrderType(Enum):\n    \"\"\"Order types.\"\"\"\n    MARKET = \"MARKET\"\n    LIMIT = \"LIMIT\"\n    STOP = \"STOP\"\n    STOP_MARKET = \"STOP_MARKET\"\n    TAKE_PROFIT = \"TAKE_PROFIT\"\n    TAKE_PROFIT_MARKET = \"TAKE_PROFIT_MARKET\"\nclass PositionSide(Enum):\n    \"\"\"Position sides for futures trading.\"\"\"",
        "detail": "emergency_import_fix",
        "documentation": {}
    },
    {
        "label": "PositionSide",
        "kind": 6,
        "importPath": "emergency_import_fix",
        "description": "emergency_import_fix",
        "peekOfCode": "class PositionSide(Enum):\n    \"\"\"Position sides for futures trading.\"\"\"\n    LONG = \"LONG\"\n    SHORT = \"SHORT\"\n    BOTH = \"BOTH\"\nclass SignalType(Enum):\n    \"\"\"Trading signal types.\"\"\"\n    BUY = \"BUY\"\n    SELL = \"SELL\"\n    HOLD = \"HOLD\"",
        "detail": "emergency_import_fix",
        "documentation": {}
    },
    {
        "label": "SignalType",
        "kind": 6,
        "importPath": "emergency_import_fix",
        "description": "emergency_import_fix",
        "peekOfCode": "class SignalType(Enum):\n    \"\"\"Trading signal types.\"\"\"\n    BUY = \"BUY\"\n    SELL = \"SELL\"\n    HOLD = \"HOLD\"\nclass ExitReason(Enum):\n    \"\"\"Reasons for position exits.\"\"\"\n    STOP_LOSS = \"STOP_LOSS\"\n    TAKE_PROFIT = \"TAKE_PROFIT\"\n    TRAILING_STOP = \"TRAILING_STOP\"",
        "detail": "emergency_import_fix",
        "documentation": {}
    },
    {
        "label": "ExitReason",
        "kind": 6,
        "importPath": "emergency_import_fix",
        "description": "emergency_import_fix",
        "peekOfCode": "class ExitReason(Enum):\n    \"\"\"Reasons for position exits.\"\"\"\n    STOP_LOSS = \"STOP_LOSS\"\n    TAKE_PROFIT = \"TAKE_PROFIT\"\n    TRAILING_STOP = \"TRAILING_STOP\"\n    SIGNAL_REVERSE = \"SIGNAL_REVERSE\"\n    RISK_MANAGEMENT = \"RISK_MANAGEMENT\"\n    MANUAL = \"MANUAL\"\n# Explicit exports for better compatibility\n__all__ = [",
        "detail": "emergency_import_fix",
        "documentation": {}
    },
    {
        "label": "fix_import_cache",
        "kind": 2,
        "importPath": "emergency_import_fix",
        "description": "emergency_import_fix",
        "peekOfCode": "def fix_import_cache():\n    \"\"\"Clear Python cache and fix imports\"\"\"\n    print(\"🧹 Emergency import cache cleanup...\")\n    # Clear Python cache\n    import glob\n    cache_dirs = glob.glob('**/__pycache__', recursive=True)\n    for cache_dir in cache_dirs:\n        try:\n            shutil.rmtree(cache_dir)\n            print(f\"✅ Cleared {cache_dir}\")",
        "detail": "emergency_import_fix",
        "documentation": {}
    },
    {
        "label": "__all__",
        "kind": 5,
        "importPath": "emergency_import_fix",
        "description": "emergency_import_fix",
        "peekOfCode": "__all__ = [\n    \"TradingMode\",\n    \"OrderSide\", \n    \"OrderType\",\n    \"PositionSide\",\n    \"SignalType\",\n    \"ExitReason\",\n]\n'''\n        # Backup and recreate constants.py",
        "detail": "emergency_import_fix",
        "documentation": {}
    },
    {
        "label": "backup",
        "kind": 2,
        "importPath": "fix_bridge_continue_patch",
        "description": "fix_bridge_continue_patch",
        "peekOfCode": "def backup(path: Path, suffix: str = \".bak2\"):\n    if path.exists():\n        shutil.copy2(path, path.with_suffix(path.suffix + suffix))\ndef patch_file(p: Path) -> bool:\n    if not p.exists():\n        print(f\"{WARN} {p} not found, skip\")\n        return False\n    txt = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    # Ищем наш ранее вставленный блок\n    if \"ORDER BRIDGE: executor path\" not in txt:",
        "detail": "fix_bridge_continue_patch",
        "documentation": {}
    },
    {
        "label": "patch_file",
        "kind": 2,
        "importPath": "fix_bridge_continue_patch",
        "description": "fix_bridge_continue_patch",
        "peekOfCode": "def patch_file(p: Path) -> bool:\n    if not p.exists():\n        print(f\"{WARN} {p} not found, skip\")\n        return False\n    txt = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    # Ищем наш ранее вставленный блок\n    if \"ORDER BRIDGE: executor path\" not in txt:\n        print(f\"{WARN} {p} has no ORDER BRIDGE block, skip\")\n        return False\n    lines = txt.splitlines()",
        "detail": "fix_bridge_continue_patch",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "fix_bridge_continue_patch",
        "description": "fix_bridge_continue_patch",
        "peekOfCode": "def main():\n    changed = 0\n    for rel in (\"runner/paper.py\", \"runner/live.py\"):\n        if patch_file(BASE / rel):\n            changed += 1\n    print(\"\\nSummary:\")\n    print(f\"  Fixed files: {changed}\")\n    print(\"\\nDone.\")\nif __name__ == \"__main__\":\n    main()",
        "detail": "fix_bridge_continue_patch",
        "documentation": {}
    },
    {
        "label": "OK",
        "kind": 5,
        "importPath": "fix_bridge_continue_patch",
        "description": "fix_bridge_continue_patch",
        "peekOfCode": "OK = \"\\u2705\"\nWARN = \"\\u26A0\\uFE0F\"\nBASE = Path(__file__).resolve().parent  # предполагаем запуск из crypto_trading_bot/work\ndef backup(path: Path, suffix: str = \".bak2\"):\n    if path.exists():\n        shutil.copy2(path, path.with_suffix(path.suffix + suffix))\ndef patch_file(p: Path) -> bool:\n    if not p.exists():\n        print(f\"{WARN} {p} not found, skip\")\n        return False",
        "detail": "fix_bridge_continue_patch",
        "documentation": {}
    },
    {
        "label": "WARN",
        "kind": 5,
        "importPath": "fix_bridge_continue_patch",
        "description": "fix_bridge_continue_patch",
        "peekOfCode": "WARN = \"\\u26A0\\uFE0F\"\nBASE = Path(__file__).resolve().parent  # предполагаем запуск из crypto_trading_bot/work\ndef backup(path: Path, suffix: str = \".bak2\"):\n    if path.exists():\n        shutil.copy2(path, path.with_suffix(path.suffix + suffix))\ndef patch_file(p: Path) -> bool:\n    if not p.exists():\n        print(f\"{WARN} {p} not found, skip\")\n        return False\n    txt = p.read_text(encoding=\"utf-8\", errors=\"ignore\")",
        "detail": "fix_bridge_continue_patch",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "fix_bridge_continue_patch",
        "description": "fix_bridge_continue_patch",
        "peekOfCode": "BASE = Path(__file__).resolve().parent  # предполагаем запуск из crypto_trading_bot/work\ndef backup(path: Path, suffix: str = \".bak2\"):\n    if path.exists():\n        shutil.copy2(path, path.with_suffix(path.suffix + suffix))\ndef patch_file(p: Path) -> bool:\n    if not p.exists():\n        print(f\"{WARN} {p} not found, skip\")\n        return False\n    txt = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    # Ищем наш ранее вставленный блок",
        "detail": "fix_bridge_continue_patch",
        "documentation": {}
    },
    {
        "label": "SignalGenerator",
        "kind": 6,
        "importPath": "force_fix_signals",
        "description": "force_fix_signals",
        "peekOfCode": "class SignalGenerator:\n    \"\"\"Generates trading signals with ultra-low thresholds for demo trading.\"\"\"\n    def __init__(self, config: Config):\n        \"\"\"Initialize signal generator with AGGRESSIVE configuration.\"\"\"\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n        # ULTRA AGGRESSIVE Signal parameters - GUARANTEED to generate signals\n        self.fast_ma_period = 5      # Very fast MA\n        self.slow_ma_period = 10     # Very slow MA  \n        self.min_signal_strength = 0.01  # Only 1% strength needed!",
        "detail": "force_fix_signals",
        "documentation": {}
    },
    {
        "label": "SimpleScalper",
        "kind": 6,
        "importPath": "force_fix_signals",
        "description": "force_fix_signals",
        "peekOfCode": "class SimpleScalper:\n    \"\"\"Ultra aggressive scalping strategy - ALWAYS generates signals.\"\"\"\n    def __init__(self, config: Config):\n        \"\"\"Initialize scalper with ULTRA aggressive configuration.\"\"\"\n        self.config = config\n        self.logger = logging.getLogger(__name__)\n        # ULTRA AGGRESSIVE Scalping parameters\n        self.momentum_period = 3  # Very short period\n        self.momentum_threshold = 0.0001  # 0.01% threshold\n        self.signal_count = 0",
        "detail": "force_fix_signals",
        "documentation": {}
    },
    {
        "label": "create_working_signals_py",
        "kind": 2,
        "importPath": "force_fix_signals",
        "description": "force_fix_signals",
        "peekOfCode": "def create_working_signals_py():\n    \"\"\"Create a new signals.py that WILL generate trades.\"\"\"\n    signals_content = '''\"\"\"\nTrading signal generation optimized for MAXIMUM demo trading activity.\nThis version is specifically designed to generate frequent, realistic trading signals\nfor demonstration purposes with very low thresholds.\n\"\"\"\nimport logging\nfrom typing import Optional, List\nfrom decimal import Decimal",
        "detail": "force_fix_signals",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "force_fix_signals",
        "description": "force_fix_signals",
        "peekOfCode": "def main():\n    \"\"\"Main function - force fix the signals.\"\"\"\n    print(\"🔧 FORCE FIXING SIGNAL GENERATION\")\n    print(\"=\" * 50)\n    print(\"Since patches didn't apply, creating NEW optimized signals.py\")\n    print(\"=\" * 50)\n    create_working_signals_py()\n    print(\"\\\\n\" + \"=\" * 50)\n    print(\"🎯 IMMEDIATE TESTING:\")\n    print(\"1. python cli_updated.py paper --symbols BTCUSDT --verbose\")",
        "detail": "force_fix_signals",
        "documentation": {}
    },
    {
        "label": "FreeMarketDataClient",
        "kind": 6,
        "importPath": "free_market_data",
        "description": "free_market_data",
        "peekOfCode": "class FreeMarketDataClient:\n    \"\"\"Клиент получения реальных данных через бесплатные API\"\"\"\n    def __init__(self):\n        self.session = None\n        # Используем бесплатные источники без геоблокировки\n        self.sources = {\n            \"coinbase\": {\n                \"url\": \"https://api.exchange.coinbase.com/products/{symbol}/ticker\",\n                \"symbol_format\": \"BTC-USD\"\n            },",
        "detail": "free_market_data",
        "documentation": {}
    },
    {
        "label": "RealMarketDataBinanceClient",
        "kind": 6,
        "importPath": "free_market_data",
        "description": "free_market_data",
        "peekOfCode": "class RealMarketDataBinanceClient:\n    \"\"\"Замена MockBinanceClient с РЕАЛЬНЫМИ рыночными данными\"\"\"\n    def __init__(self, balance: float = 10000.0):\n        self.balance = balance\n        self.data_client = None\n        self.last_price = 67000.0  # Fallback\n        self.price_cache = {}\n        self.cache_timeout = 30  # 30 секунд кеш\n    async def __aenter__(self):\n        self.data_client = FreeMarketDataClient()",
        "detail": "free_market_data",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "install_site_sig_guard",
        "description": "install_site_sig_guard",
        "peekOfCode": "def main():\n    SITE.write_text(CONTENT, encoding=\"utf-8\")\n    print(f\"✅ Created {SITE.name} in {SITE.parent}\")\n    print(\"   Python will auto-import it on start (via 'site').\")\nif __name__ == \"__main__\":\n    main()",
        "detail": "install_site_sig_guard",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "install_site_sig_guard",
        "description": "install_site_sig_guard",
        "peekOfCode": "BASE = Path(__file__).resolve().parent\nSITE = BASE / \"sitecustomize.py\"\nCONTENT = \"\"\"# Auto-installed by install_site_sig_guard.py\n# This file is imported automatically by Python (via 'site') if present on sys.path.\n# It prevents NameError for legacy 'sig' usage across any module.\nimport builtins\n# define only if not already defined to avoid side effects\nif not hasattr(builtins, \"sig\"):\n    builtins.sig = None\nif not hasattr(builtins, \"trade_signal\"):",
        "detail": "install_site_sig_guard",
        "documentation": {}
    },
    {
        "label": "SITE",
        "kind": 5,
        "importPath": "install_site_sig_guard",
        "description": "install_site_sig_guard",
        "peekOfCode": "SITE = BASE / \"sitecustomize.py\"\nCONTENT = \"\"\"# Auto-installed by install_site_sig_guard.py\n# This file is imported automatically by Python (via 'site') if present on sys.path.\n# It prevents NameError for legacy 'sig' usage across any module.\nimport builtins\n# define only if not already defined to avoid side effects\nif not hasattr(builtins, \"sig\"):\n    builtins.sig = None\nif not hasattr(builtins, \"trade_signal\"):\n    builtins.trade_signal = None",
        "detail": "install_site_sig_guard",
        "documentation": {}
    },
    {
        "label": "CONTENT",
        "kind": 5,
        "importPath": "install_site_sig_guard",
        "description": "install_site_sig_guard",
        "peekOfCode": "CONTENT = \"\"\"# Auto-installed by install_site_sig_guard.py\n# This file is imported automatically by Python (via 'site') if present on sys.path.\n# It prevents NameError for legacy 'sig' usage across any module.\nimport builtins\n# define only if not already defined to avoid side effects\nif not hasattr(builtins, \"sig\"):\n    builtins.sig = None\nif not hasattr(builtins, \"trade_signal\"):\n    builtins.trade_signal = None\n# optional: a tiny breadcrumb to stdout so we know it's active",
        "detail": "install_site_sig_guard",
        "documentation": {}
    },
    {
        "label": "backup",
        "kind": 2,
        "importPath": "purge_bridge_sig_refs",
        "description": "purge_bridge_sig_refs",
        "peekOfCode": "def backup(p: Path, suffix: str):\n    if p.exists(): shutil.copy2(p, p.with_suffix(p.suffix + suffix))\ndef replace_bridge_block(txt: str) -> tuple[str, bool]:\n    if ANCHOR not in txt: return txt, False\n    lines = txt.splitlines()\n    out = []; i = 0; changed = False\n    while i < len(lines):\n        if ANCHOR in lines[i]:\n            indent = re.match(r\"^(\\s*)\", lines[i]).group(1)\n            # вырежем старый блок до except‑логгера",
        "detail": "purge_bridge_sig_refs",
        "documentation": {}
    },
    {
        "label": "replace_bridge_block",
        "kind": 2,
        "importPath": "purge_bridge_sig_refs",
        "description": "purge_bridge_sig_refs",
        "peekOfCode": "def replace_bridge_block(txt: str) -> tuple[str, bool]:\n    if ANCHOR not in txt: return txt, False\n    lines = txt.splitlines()\n    out = []; i = 0; changed = False\n    while i < len(lines):\n        if ANCHOR in lines[i]:\n            indent = re.match(r\"^(\\s*)\", lines[i]).group(1)\n            # вырежем старый блок до except‑логгера\n            j = i\n            end = None",
        "detail": "purge_bridge_sig_refs",
        "documentation": {}
    },
    {
        "label": "strip_loose_sig_lines",
        "kind": 2,
        "importPath": "purge_bridge_sig_refs",
        "description": "purge_bridge_sig_refs",
        "peekOfCode": "def strip_loose_sig_lines(txt: str) -> tuple[str, bool]:\n    # подчистим случайные одиночные строки вида \"sig = None\"\n    lines = txt.splitlines(); changed = False\n    new_lines = []\n    for l in lines:\n        if re.match(r\"^\\s*sig\\s*=\", l):\n            changed = True\n            continue\n        new_lines.append(l)\n    return \"\\n\".join(new_lines) + (\"\\n\" if not txt.endswith(\"\\n\") else \"\"), changed",
        "detail": "purge_bridge_sig_refs",
        "documentation": {}
    },
    {
        "label": "patch_one",
        "kind": 2,
        "importPath": "purge_bridge_sig_refs",
        "description": "purge_bridge_sig_refs",
        "peekOfCode": "def patch_one(p: Path) -> bool:\n    if not p.exists():\n        print(f\"{WARN} {p} not found, skip\"); return False\n    src = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    txt, ch1 = replace_bridge_block(src)\n    txt2, ch2 = strip_loose_sig_lines(txt)\n    if ch1 or ch2:\n        backup(p, \".bak_sigfix\")\n        p.write_text(txt2, encoding=\"utf-8\")\n        print(f\"{OK} Patched {p.relative_to(BASE)} (bridge fixed)\")",
        "detail": "purge_bridge_sig_refs",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "purge_bridge_sig_refs",
        "description": "purge_bridge_sig_refs",
        "peekOfCode": "def main():\n    changed = 0\n    for rel in (\"runner/paper.py\", \"runner/live.py\"):\n        if patch_one(BASE / rel): changed += 1\n    print(\"\\nSummary:\\n  Updated files:\", changed, \"\\nDone.\")\nif __name__ == \"__main__\":\n    main()",
        "detail": "purge_bridge_sig_refs",
        "documentation": {}
    },
    {
        "label": "OK",
        "kind": 5,
        "importPath": "purge_bridge_sig_refs",
        "description": "purge_bridge_sig_refs",
        "peekOfCode": "OK = \"\\u2705\"; WARN = \"\\u26A0\\uFE0F\"\nBASE = Path(__file__).resolve().parent\nANCHOR = \"ORDER BRIDGE: executor path\"\nEXCEPT_LINE = \"except Exception as _ex:\"\nNEW_BLOCK = \"\"\"{indent}# ORDER BRIDGE: executor path (final safe)\n{indent}try:\n{indent}    _bridge_enabled = (getattr(self.config, \"order_bridge_enable\", False) or os.getenv(\"ORDER_BRIDGE_ENABLE\",\"false\").lower()==\"true\")\n{indent}    _bridge_sig = None\n{indent}    try:\n{indent}        _loc = locals()",
        "detail": "purge_bridge_sig_refs",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "purge_bridge_sig_refs",
        "description": "purge_bridge_sig_refs",
        "peekOfCode": "BASE = Path(__file__).resolve().parent\nANCHOR = \"ORDER BRIDGE: executor path\"\nEXCEPT_LINE = \"except Exception as _ex:\"\nNEW_BLOCK = \"\"\"{indent}# ORDER BRIDGE: executor path (final safe)\n{indent}try:\n{indent}    _bridge_enabled = (getattr(self.config, \"order_bridge_enable\", False) or os.getenv(\"ORDER_BRIDGE_ENABLE\",\"false\").lower()==\"true\")\n{indent}    _bridge_sig = None\n{indent}    try:\n{indent}        _loc = locals()\n{indent}    except Exception:",
        "detail": "purge_bridge_sig_refs",
        "documentation": {}
    },
    {
        "label": "ANCHOR",
        "kind": 5,
        "importPath": "purge_bridge_sig_refs",
        "description": "purge_bridge_sig_refs",
        "peekOfCode": "ANCHOR = \"ORDER BRIDGE: executor path\"\nEXCEPT_LINE = \"except Exception as _ex:\"\nNEW_BLOCK = \"\"\"{indent}# ORDER BRIDGE: executor path (final safe)\n{indent}try:\n{indent}    _bridge_enabled = (getattr(self.config, \"order_bridge_enable\", False) or os.getenv(\"ORDER_BRIDGE_ENABLE\",\"false\").lower()==\"true\")\n{indent}    _bridge_sig = None\n{indent}    try:\n{indent}        _loc = locals()\n{indent}    except Exception:\n{indent}        _loc = dict()",
        "detail": "purge_bridge_sig_refs",
        "documentation": {}
    },
    {
        "label": "EXCEPT_LINE",
        "kind": 5,
        "importPath": "purge_bridge_sig_refs",
        "description": "purge_bridge_sig_refs",
        "peekOfCode": "EXCEPT_LINE = \"except Exception as _ex:\"\nNEW_BLOCK = \"\"\"{indent}# ORDER BRIDGE: executor path (final safe)\n{indent}try:\n{indent}    _bridge_enabled = (getattr(self.config, \"order_bridge_enable\", False) or os.getenv(\"ORDER_BRIDGE_ENABLE\",\"false\").lower()==\"true\")\n{indent}    _bridge_sig = None\n{indent}    try:\n{indent}        _loc = locals()\n{indent}    except Exception:\n{indent}        _loc = dict()\n{indent}    for _n in (\"signal\",\"trade_signal\",\"sig\"):",
        "detail": "purge_bridge_sig_refs",
        "documentation": {}
    },
    {
        "label": "NEW_BLOCK",
        "kind": 5,
        "importPath": "purge_bridge_sig_refs",
        "description": "purge_bridge_sig_refs",
        "peekOfCode": "NEW_BLOCK = \"\"\"{indent}# ORDER BRIDGE: executor path (final safe)\n{indent}try:\n{indent}    _bridge_enabled = (getattr(self.config, \"order_bridge_enable\", False) or os.getenv(\"ORDER_BRIDGE_ENABLE\",\"false\").lower()==\"true\")\n{indent}    _bridge_sig = None\n{indent}    try:\n{indent}        _loc = locals()\n{indent}    except Exception:\n{indent}        _loc = dict()\n{indent}    for _n in (\"signal\",\"trade_signal\",\"sig\"):\n{indent}        if _n in _loc:",
        "detail": "purge_bridge_sig_refs",
        "documentation": {}
    },
    {
        "label": "backup",
        "kind": 2,
        "importPath": "reinstall_bridge_call_clean",
        "description": "reinstall_bridge_call_clean",
        "peekOfCode": "def backup(p: Path, suf=\".bak_bridge\"):\n    if p.exists(): shutil.copy2(p, p.with_suffix(p.suffix + suf))\ndef ensure_imports(txt: str) -> tuple[str,bool]:\n    changed=False\n    lines = txt.splitlines()\n    insert_idx = 0\n    for i,l in enumerate(lines[:100]):\n        if l.strip().startswith((\"import \",\"from \")): insert_idx = i+1\n        elif l.strip()==\"\" or l.lstrip().startswith((\"#\",'\"\"\"',\"'''\")): continue\n        else: break",
        "detail": "reinstall_bridge_call_clean",
        "documentation": {}
    },
    {
        "label": "ensure_imports",
        "kind": 2,
        "importPath": "reinstall_bridge_call_clean",
        "description": "reinstall_bridge_call_clean",
        "peekOfCode": "def ensure_imports(txt: str) -> tuple[str,bool]:\n    changed=False\n    lines = txt.splitlines()\n    insert_idx = 0\n    for i,l in enumerate(lines[:100]):\n        if l.strip().startswith((\"import \",\"from \")): insert_idx = i+1\n        elif l.strip()==\"\" or l.lstrip().startswith((\"#\",'\"\"\"',\"'''\")): continue\n        else: break\n    need_os       = not any(re.match(r\"\\s*import\\s+os(\\s|,|$)\", l) for l in lines)\n    need_asyncio  = not any(re.match(r\"\\s*import\\s+asyncio(\\s|,|$)\", l) for l in lines)",
        "detail": "reinstall_bridge_call_clean",
        "documentation": {}
    },
    {
        "label": "remove_old_bridge_blocks",
        "kind": 2,
        "importPath": "reinstall_bridge_call_clean",
        "description": "reinstall_bridge_call_clean",
        "peekOfCode": "def remove_old_bridge_blocks(txt: str) -> tuple[str,bool]:\n    changed=False\n    lines = txt.splitlines()\n    out=[]; i=0\n    while i < len(lines):\n        if \"ORDER BRIDGE:\" in lines[i]:\n            # выкинуть блок до первой строки с 'except Exception as _ex:'\n            j=i\n            end=None\n            while j < len(lines):",
        "detail": "reinstall_bridge_call_clean",
        "documentation": {}
    },
    {
        "label": "inject_bridge_after_generate",
        "kind": 2,
        "importPath": "reinstall_bridge_call_clean",
        "description": "reinstall_bridge_call_clean",
        "peekOfCode": "def inject_bridge_after_generate(txt: str) -> tuple[str,bool]:\n    \"\"\"\n    Найдём строку вида:   <sigvar> = ...generate_signal(...\n    и вставим мост сразу после неё.\n    \"\"\"\n    lines = txt.splitlines()\n    pat = re.compile(r\"^(\\s*)(\\w+)\\s*=\\s*.*generate_signal\\s*\\(\", re.IGNORECASE)\n    for idx, line in enumerate(lines):\n        m = pat.match(line)\n        if not m: continue",
        "detail": "reinstall_bridge_call_clean",
        "documentation": {}
    },
    {
        "label": "ensure_executor_init_and_bind",
        "kind": 2,
        "importPath": "reinstall_bridge_call_clean",
        "description": "reinstall_bridge_call_clean",
        "peekOfCode": "def ensure_executor_init_and_bind(txt: str) -> tuple[str,bool]:\n    changed=False\n    t=txt\n    # 1) создать self.trade_executor = TradeExecutor() в __init__, если нет\n    if \"self.trade_executor = TradeExecutor()\" not in t:\n        m = re.search(r\"(def\\s+__init__\\s*\\([^)]*\\)\\s*:\\s*\\n)(\\s+)\", t)\n        if m:\n            pos=m.end(1); indent=m.group(2)\n            t = t[:pos] + f\"{indent}self.trade_executor = TradeExecutor()\\n\" + t[pos:]\n            changed=True",
        "detail": "reinstall_bridge_call_clean",
        "documentation": {}
    },
    {
        "label": "process_file",
        "kind": 2,
        "importPath": "reinstall_bridge_call_clean",
        "description": "reinstall_bridge_call_clean",
        "peekOfCode": "def process_file(p: Path):\n    if not p.exists():\n        print(f\"{WARN} {p} not found, skip\"); return\n    src = p.read_text(encoding=\"utf-8\", errors=\"ignore\")\n    backup(p)\n    t1,ch1 = ensure_imports(src)\n    t2,ch2 = remove_old_bridge_blocks(t1)\n    t3,ch3 = inject_bridge_after_generate(t2)\n    t4,ch4 = ensure_executor_init_and_bind(t3)\n    if any([ch1,ch2,ch3,ch4]):",
        "detail": "reinstall_bridge_call_clean",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "reinstall_bridge_call_clean",
        "description": "reinstall_bridge_call_clean",
        "peekOfCode": "def main():\n    for f in FILES: process_file(f)\n    print(\"\\nDone.\")\nif __name__ == \"__main__\":\n    main()",
        "detail": "reinstall_bridge_call_clean",
        "documentation": {}
    },
    {
        "label": "OK",
        "kind": 5,
        "importPath": "reinstall_bridge_call_clean",
        "description": "reinstall_bridge_call_clean",
        "peekOfCode": "OK = \"\\u2705\"; WARN = \"\\u26A0\\uFE0F\"\nBASE = Path(__file__).resolve().parent  # запуск из crypto_trading_bot/work\nFILES = [BASE/\"runner\"/\"paper.py\", BASE/\"runner\"/\"live.py\"]\nBRIDGE_SNIPPET = \"\"\"{indent}# ORDER BRIDGE: executor path (clean reinstall)\n{indent}try:\n{indent}    _bridge_enabled = (getattr(self.config, \"order_bridge_enable\", False) or os.getenv(\"ORDER_BRIDGE_ENABLE\",\"false\").lower()==\"true\")\n{indent}    if _bridge_enabled and {sigvar} and isinstance({sigvar}, dict) and {sigvar}.get(\"signal_type\") in (\"BUY\",\"SELL\"):\n{indent}        if getattr(self, \"trade_executor\", None) and getattr(self.trade_executor, \"client\", None) is None and getattr(self, \"client\", None):\n{indent}            self.trade_executor.client = self.client\n{indent}        res = await asyncio.to_thread(",
        "detail": "reinstall_bridge_call_clean",
        "documentation": {}
    },
    {
        "label": "BASE",
        "kind": 5,
        "importPath": "reinstall_bridge_call_clean",
        "description": "reinstall_bridge_call_clean",
        "peekOfCode": "BASE = Path(__file__).resolve().parent  # запуск из crypto_trading_bot/work\nFILES = [BASE/\"runner\"/\"paper.py\", BASE/\"runner\"/\"live.py\"]\nBRIDGE_SNIPPET = \"\"\"{indent}# ORDER BRIDGE: executor path (clean reinstall)\n{indent}try:\n{indent}    _bridge_enabled = (getattr(self.config, \"order_bridge_enable\", False) or os.getenv(\"ORDER_BRIDGE_ENABLE\",\"false\").lower()==\"true\")\n{indent}    if _bridge_enabled and {sigvar} and isinstance({sigvar}, dict) and {sigvar}.get(\"signal_type\") in (\"BUY\",\"SELL\"):\n{indent}        if getattr(self, \"trade_executor\", None) and getattr(self.trade_executor, \"client\", None) is None and getattr(self, \"client\", None):\n{indent}            self.trade_executor.client = self.client\n{indent}        res = await asyncio.to_thread(\n{indent}            self.trade_executor.handle_signal,",
        "detail": "reinstall_bridge_call_clean",
        "documentation": {}
    },
    {
        "label": "FILES",
        "kind": 5,
        "importPath": "reinstall_bridge_call_clean",
        "description": "reinstall_bridge_call_clean",
        "peekOfCode": "FILES = [BASE/\"runner\"/\"paper.py\", BASE/\"runner\"/\"live.py\"]\nBRIDGE_SNIPPET = \"\"\"{indent}# ORDER BRIDGE: executor path (clean reinstall)\n{indent}try:\n{indent}    _bridge_enabled = (getattr(self.config, \"order_bridge_enable\", False) or os.getenv(\"ORDER_BRIDGE_ENABLE\",\"false\").lower()==\"true\")\n{indent}    if _bridge_enabled and {sigvar} and isinstance({sigvar}, dict) and {sigvar}.get(\"signal_type\") in (\"BUY\",\"SELL\"):\n{indent}        if getattr(self, \"trade_executor\", None) and getattr(self.trade_executor, \"client\", None) is None and getattr(self, \"client\", None):\n{indent}            self.trade_executor.client = self.client\n{indent}        res = await asyncio.to_thread(\n{indent}            self.trade_executor.handle_signal,\n{indent}            symbol,",
        "detail": "reinstall_bridge_call_clean",
        "documentation": {}
    },
    {
        "label": "BRIDGE_SNIPPET",
        "kind": 5,
        "importPath": "reinstall_bridge_call_clean",
        "description": "reinstall_bridge_call_clean",
        "peekOfCode": "BRIDGE_SNIPPET = \"\"\"{indent}# ORDER BRIDGE: executor path (clean reinstall)\n{indent}try:\n{indent}    _bridge_enabled = (getattr(self.config, \"order_bridge_enable\", False) or os.getenv(\"ORDER_BRIDGE_ENABLE\",\"false\").lower()==\"true\")\n{indent}    if _bridge_enabled and {sigvar} and isinstance({sigvar}, dict) and {sigvar}.get(\"signal_type\") in (\"BUY\",\"SELL\"):\n{indent}        if getattr(self, \"trade_executor\", None) and getattr(self.trade_executor, \"client\", None) is None and getattr(self, \"client\", None):\n{indent}            self.trade_executor.client = self.client\n{indent}        res = await asyncio.to_thread(\n{indent}            self.trade_executor.handle_signal,\n{indent}            symbol,\n{indent}            {sigvar},",
        "detail": "reinstall_bridge_call_clean",
        "documentation": {}
    },
    {
        "label": "RealBinanceClient",
        "kind": 6,
        "importPath": "setup_binance_testnet",
        "description": "setup_binance_testnet",
        "peekOfCode": "class RealBinanceClient:\n    \"\"\"Real Binance API client for testnet demo trading.\"\"\"\n    def __init__(self, config):\n        \"\"\"Initialize with REAL Binance API connection.\"\"\"\n        self.config = config\n        # Get API credentials\n        api_key = os.getenv('BINANCE_API_KEY')\n        secret_key = os.getenv('BINANCE_SECRET_KEY') \n        testnet = os.getenv('BINANCE_TESTNET', 'true').lower() == 'true'\n        if not api_key or not secret_key:",
        "detail": "setup_binance_testnet",
        "documentation": {}
    },
    {
        "label": "create_testnet_config",
        "kind": 2,
        "importPath": "setup_binance_testnet",
        "description": "setup_binance_testnet",
        "peekOfCode": "def create_testnet_config():\n    \"\"\"Create configuration for Binance Testnet API connection.\"\"\"\n    env_content = \"\"\"# Binance Testnet Configuration for REAL Demo Trading\n# Get your testnet API keys from: https://testnet.binance.vision/\n# Binance Testnet API Credentials\nBINANCE_API_KEY=your_testnet_api_key_here\nBINANCE_SECRET_KEY=your_testnet_secret_key_here\n# Testnet Settings (DO NOT CHANGE)\nBINANCE_TESTNET=true\nBINANCE_BASE_URL=https://testnet.binance.vision",
        "detail": "setup_binance_testnet",
        "documentation": {}
    },
    {
        "label": "create_api_setup_guide",
        "kind": 2,
        "importPath": "setup_binance_testnet",
        "description": "setup_binance_testnet",
        "peekOfCode": "def create_api_setup_guide():\n    \"\"\"Create guide for setting up Binance Testnet API.\"\"\"\n    guide_content = \"\"\"# 🚀 Binance Testnet Setup Guide\n## Step 1: Get Testnet API Keys\n1. Go to: https://testnet.binance.vision/\n2. Click \"Login\" and sign up with your email\n3. Go to API Management\n4. Create new API key\n5. **IMPORTANT**: Enable \"Enable Futures\" for futures trading\n6. Copy your API Key and Secret Key",
        "detail": "setup_binance_testnet",
        "documentation": {}
    },
    {
        "label": "create_real_api_client",
        "kind": 2,
        "importPath": "setup_binance_testnet",
        "description": "setup_binance_testnet",
        "peekOfCode": "def create_real_api_client():\n    \"\"\"Create enhanced client configuration for real API connection.\"\"\"\n    client_config = '''\"\"\"\nEnhanced Binance Client Configuration for Real API Connection\nThis configuration enables REAL Binance Testnet API instead of mock client.\n\"\"\"\nimport os\nimport logging\nfrom typing import Optional, Dict, Any\nfrom binance.client import Client",
        "detail": "setup_binance_testnet",
        "documentation": {}
    },
    {
        "label": "get_real_api_client",
        "kind": 2,
        "importPath": "setup_binance_testnet",
        "description": "setup_binance_testnet",
        "peekOfCode": "def get_real_api_client(config):\n    \"\"\"Get configured real API client.\"\"\"\n    use_real_api = os.getenv('ENABLE_REAL_API', 'true').lower() == 'true'\n    if use_real_api:\n        return RealBinanceClient(config)\n    else:\n        # Fallback to mock if requested\n        from exchange.client import MockBinanceClient\n        return MockBinanceClient(config)\n'''",
        "detail": "setup_binance_testnet",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "setup_binance_testnet",
        "description": "setup_binance_testnet",
        "peekOfCode": "def main():\n    \"\"\"Main setup function.\"\"\"\n    print(\"🔧 SETTING UP BINANCE TESTNET CONNECTION\")\n    print(\"=\" * 60)\n    print(\"Current: Mock client with synthetic data\")\n    print(\"Target: Real Binance Testnet API with live prices\")\n    print(\"=\" * 60)\n    create_testnet_config()\n    create_api_setup_guide() \n    create_real_api_client()",
        "detail": "setup_binance_testnet",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "setup_binance_testnet",
        "description": "setup_binance_testnet",
        "peekOfCode": "logger = logging.getLogger(__name__)\nclass RealBinanceClient:\n    \"\"\"Real Binance API client for testnet demo trading.\"\"\"\n    def __init__(self, config):\n        \"\"\"Initialize with REAL Binance API connection.\"\"\"\n        self.config = config\n        # Get API credentials\n        api_key = os.getenv('BINANCE_API_KEY')\n        secret_key = os.getenv('BINANCE_SECRET_KEY') \n        testnet = os.getenv('BINANCE_TESTNET', 'true').lower() == 'true'",
        "detail": "setup_binance_testnet",
        "documentation": {}
    },
    {
        "label": "apply_fixes",
        "kind": 2,
        "importPath": "simple_live_fixes",
        "description": "simple_live_fixes",
        "peekOfCode": "def apply_fixes():\n    \"\"\"Apply all live trading fixes without import conflicts.\"\"\"\n    print(\"🔧 Applying simple live trading fixes...\")\n    # Fix 1: Add logger to LiveTradingEngine at runtime\n    def add_logger_attribute():\n        \"\"\"Add logger attribute to LiveTradingEngine instances.\"\"\"\n        try:\n            import sys\n            if 'runner.live' in sys.modules:\n                live_module = sys.modules['runner.live']",
        "detail": "simple_live_fixes",
        "documentation": {}
    },
    {
        "label": "sys.argv",
        "kind": 5,
        "importPath": "sitecustomize",
        "description": "sitecustomize",
        "peekOfCode": "sys.argv = _argv\n# 3) validate_symbol stub (до compat)\ntry:\n    import importlib, types\n    cu = importlib.import_module(\"core.utils\")\n    if not hasattr(cu, \"validate_symbol\"):\n        def validate_symbol(sym: str) -> str:\n            try: s = str(sym).strip().upper()\n            except Exception: s = \"\"\n            return s",
        "detail": "sitecustomize",
        "documentation": {}
    }
]