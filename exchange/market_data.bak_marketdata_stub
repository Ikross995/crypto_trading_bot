# --- AUTO-ADDED SAFE STUB: MarketDataProvider ---------------------------------
try:
    MarketDataProvider  # type: ignore[name-defined]
except NameError:
    import asyncio
    import logging
    from typing import Dict, List, Optional, Any

    class MarketDataProvider:
        """
        Minimal/compatible MarketDataProvider для live/paper:
          - start()/stop() — no-op
          - last_price(symbol) -> float|None
          - fetch_klines(symbol, limit=200) -> List[dict]
          - update_from_ws(symbol, price)
        """
        def __init__(self, client: Any = None, *, symbols=None, timeframe: str = "1m", logger=None) -> None:
            self.client = client
            self.symbols = list(symbols or [])
            self.timeframe = timeframe
            self.log = logger or logging.getLogger(__name__)
            self._last_price: Dict[str, float] = {}

        async def start(self) -> None:
            return

        async def stop(self) -> None:
            return

        async def last_price(self, symbol: str) -> Optional[float]:
            p = self._last_price.get(symbol)
            if p:
                return p
            try:
                if self.client and hasattr(self.client, "get_price_ticker"):
                    data = await self._maybe_await(self.client.get_price_ticker(symbol))
                    if isinstance(data, (int, float)):
                        p = float(data)
                    elif isinstance(data, dict) and "price" in data:
                        p = float(data["price"])
                    else:
                        p = None
                    if p:
                        self._last_price[symbol] = p
                    return p
            except Exception as e:
                self.log.debug("last_price(%s) via REST failed: %s", symbol, e)
            return None

        async def fetch_klines(self, symbol: str, limit: int = 200) -> List[dict]:
            try:
                if self.client and hasattr(self.client, "get_klines"):
                    kl = await self._maybe_await(self.client.get_klines(symbol=symbol, interval=self.timeframe, limit=limit))
                    out: List[dict] = []
                    for row in kl or []:
                        if isinstance(row, dict):
                            out.append(row)
                        elif isinstance(row, (list, tuple)) and len(row) >= 6:
                            out.append({
                                "open_time": row[0],
                                "open": float(row[1]),
                                "high": float(row[2]),
                                "low": float(row[3]),
                                "close": float(row[4]),
                                "volume": float(row[5]),
                                "close_time": row[6] if len(row) > 6 else None,
                            })
                    return out
            except Exception as e:
                self.log.debug("fetch_klines(%s) failed: %s", symbol, e)
            return []

        def update_from_ws(self, symbol: str, price: float) -> None:
            try:
                self._last_price[symbol] = float(price)
            except Exception:
                pass

        async def _maybe_await(self, x):
            if asyncio.iscoroutine(x):
                return await x
            return x

    __all__ = [*(globals().get("__all__", []) or []), "MarketDataProvider"]
# --- END OF STUB ---------------------------------------------------------------
